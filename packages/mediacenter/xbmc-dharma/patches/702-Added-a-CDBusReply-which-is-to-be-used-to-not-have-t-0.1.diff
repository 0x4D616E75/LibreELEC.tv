diff -Naur xbmc-dharma-35100/xbmc/linux/ConsoleDeviceKitPowerSyscall.cpp xbmc-dharma-35100.patch/xbmc/linux/ConsoleDeviceKitPowerSyscall.cpp
--- xbmc-dharma-35100/xbmc/linux/ConsoleDeviceKitPowerSyscall.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/ConsoleDeviceKitPowerSyscall.cpp	2010-11-01 21:15:30.815797383 +0100
@@ -26,13 +26,15 @@
 #ifdef HAS_DBUS
 #include "Application.h"
 #include "LocalizeStrings.h"
+#include "DBusMessage.h"
 #include "DBusUtil.h"
+#include <dbus/dbus.h>
 
 CConsoleDeviceKitPowerSyscall::CConsoleDeviceKitPowerSyscall()
 {
   m_CanPowerdown = ConsoleKitMethodCall("CanStop");
-  m_CanSuspend   = CDBusUtil::GetVariant("org.freedesktop.DeviceKit.Power", "/org/freedesktop/DeviceKit/Power",    "org.freedesktop.DeviceKit.Power", "can_suspend").asBoolean();
-  m_CanHibernate = CDBusUtil::GetVariant("org.freedesktop.DeviceKit.Power", "/org/freedesktop/DeviceKit/Power",    "org.freedesktop.DeviceKit.Power", "can_hibernate").asBoolean();
+  m_CanSuspend   = CDBusUtil::GetProperty("org.freedesktop.DeviceKit.Power", "/org/freedesktop/DeviceKit/Power",    "org.freedesktop.DeviceKit.Power", "can_suspend").asBoolean();
+  m_CanHibernate = CDBusUtil::GetProperty("org.freedesktop.DeviceKit.Power", "/org/freedesktop/DeviceKit/Power",    "org.freedesktop.DeviceKit.Power", "can_hibernate").asBoolean();
   m_CanReboot    = ConsoleKitMethodCall("CanRestart");
 }
 
@@ -125,15 +127,9 @@
 bool CConsoleDeviceKitPowerSyscall::ConsoleKitMethodCall(const char *method)
 {
   CDBusMessage message("org.freedesktop.ConsoleKit", "/org/freedesktop/ConsoleKit/Manager", "org.freedesktop.ConsoleKit.Manager", method);
-  DBusMessage *reply = message.SendSystem();
-  if (reply)
-  {
-    dbus_bool_t boolean = FALSE;
-
-    if (dbus_message_get_args (reply, NULL, DBUS_TYPE_BOOLEAN, &boolean, DBUS_TYPE_INVALID))
-      return boolean;
-  }
+  CDBusReplyPtr reply = message.SendSystem();
+  CVariant result = reply->GetNextArgument();
 
-  return false;
+  return result.asBoolean();
 }
 #endif
diff -Naur xbmc-dharma-35100/xbmc/linux/ConsoleDeviceKitPowerSyscall.h xbmc-dharma-35100.patch/xbmc/linux/ConsoleDeviceKitPowerSyscall.h
--- xbmc-dharma-35100/xbmc/linux/ConsoleDeviceKitPowerSyscall.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/ConsoleDeviceKitPowerSyscall.h	2010-11-01 21:15:30.817797406 +0100
@@ -19,6 +19,7 @@
  *
  */
 
+#include "system.h"
 #ifdef HAS_DBUS
 #ifndef _DBUS_POWER_SYSCALL_H_
 #define _DBUS_POWER_SYSCALL_H_
diff -Naur xbmc-dharma-35100/xbmc/linux/ConsoleUPowerSyscall.cpp xbmc-dharma-35100.patch/xbmc/linux/ConsoleUPowerSyscall.cpp
--- xbmc-dharma-35100/xbmc/linux/ConsoleUPowerSyscall.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/ConsoleUPowerSyscall.cpp	2010-11-01 21:15:30.818797417 +0100
@@ -19,13 +19,13 @@
  *
  */
 
-#include "system.h"
 #include "ConsoleUPowerSyscall.h"
-#include "utils/log.h"
-
 #ifdef HAS_DBUS
+#include "DBusUtil.h"
+#include "DBusMessage.h"
 #include "Application.h"
 #include "LocalizeStrings.h"
+#include "log.h"
 
 CConsoleUPowerSyscall::CConsoleUPowerSyscall()
 {
@@ -196,22 +196,16 @@
 
 void CConsoleUPowerSyscall::UpdateUPower()
 {
-  m_CanSuspend   = CDBusUtil::GetVariant("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "CanSuspend").asBoolean(false);
-  m_CanHibernate = CDBusUtil::GetVariant("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "CanHibernate").asBoolean(false);
+  m_CanSuspend   = CDBusUtil::GetProperty("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "CanSuspend").asBoolean(false);
+  m_CanHibernate = CDBusUtil::GetProperty("org.freedesktop.UPower", "/org/freedesktop/UPower", "org.freedesktop.UPower", "CanHibernate").asBoolean(false);
 }
 
 bool CConsoleUPowerSyscall::ConsoleKitMethodCall(const char *method)
 {
   CDBusMessage message("org.freedesktop.ConsoleKit", "/org/freedesktop/ConsoleKit/Manager", "org.freedesktop.ConsoleKit.Manager", method);
-  DBusMessage *reply = message.SendSystem();
-  if (reply)
-  {
-    dbus_bool_t boolean = FALSE;
-
-    if (dbus_message_get_args (reply, NULL, DBUS_TYPE_BOOLEAN, &boolean, DBUS_TYPE_INVALID))
-      return boolean;
-  }
+  CDBusReplyPtr reply = message.SendSystem();
+  CVariant result = reply->GetNextArgument();
 
-  return false;
+  return result.asBoolean();
 }
 #endif
diff -Naur xbmc-dharma-35100/xbmc/linux/ConsoleUPowerSyscall.h xbmc-dharma-35100.patch/xbmc/linux/ConsoleUPowerSyscall.h
--- xbmc-dharma-35100/xbmc/linux/ConsoleUPowerSyscall.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/ConsoleUPowerSyscall.h	2010-11-01 21:15:30.820797441 +0100
@@ -19,9 +19,10 @@
  *
  */
 
+#include "system.h"
 #ifdef HAS_DBUS
 #include "IPowerSyscall.h"
-#include "DBusUtil.h"
+#include <dbus/dbus.h>
 
 class CConsoleUPowerSyscall : public IPowerSyscall
 {
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusMessage.cpp xbmc-dharma-35100.patch/xbmc/linux/DBusMessage.cpp
--- xbmc-dharma-35100/xbmc/linux/DBusMessage.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusMessage.cpp	2010-11-01 21:15:30.823797477 +0100
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2009 Team XBMC
+ *      Copyright (C) 2005-2010 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -18,16 +18,18 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
+
 #include "DBusMessage.h"
 #ifdef HAS_DBUS
 #include "log.h"
 
 CDBusMessage::CDBusMessage(const char *destination, const char *object, const char *interface, const char *method)
 {
-  m_reply = NULL;
-  m_message = dbus_message_new_method_call (destination, object, interface, method);
   m_haveArgs = false;
-  CLog::Log(LOGDEBUG, "DBus: Creating message to %s on %s with interface %s and method %s\n", destination, object, interface, method);
+  m_message = dbus_message_new_method_call (destination, object, interface, method);
+
+  if (m_message == NULL)
+    CLog::Log(LOGDEBUG, "DBus: Failed to create message to %s on %s with interface %s and method %s\n", destination, object, interface, method);
 }
 
 CDBusMessage::~CDBusMessage()
@@ -37,36 +39,44 @@
 
 bool CDBusMessage::AppendObjectPath(const char *object)
 {
-  PrepareArgument();
-  return dbus_message_iter_append_basic(&m_args, DBUS_TYPE_OBJECT_PATH, &object);
+  if (PrepareArgument())
+    return dbus_message_iter_append_basic(&m_args, DBUS_TYPE_OBJECT_PATH, &object);
+  else
+    return false;
 }
 
 bool CDBusMessage::AppendArgument(const char *string)
 {
-  PrepareArgument();
-  return dbus_message_iter_append_basic(&m_args, DBUS_TYPE_STRING, &string);
+  if (PrepareArgument())
+    return dbus_message_iter_append_basic(&m_args, DBUS_TYPE_STRING, &string);
+  else
+    return false;
 }
 
 bool CDBusMessage::AppendArgument(const char **arrayString, unsigned int length)
 {
-  PrepareArgument();
-  DBusMessageIter sub;
-  bool success = dbus_message_iter_open_container(&m_args, DBUS_TYPE_ARRAY, DBUS_TYPE_STRING_AS_STRING, &sub);
+  if (PrepareArgument())
+  {
+    DBusMessageIter sub;
+    bool success = dbus_message_iter_open_container(&m_args, DBUS_TYPE_ARRAY, DBUS_TYPE_STRING_AS_STRING, &sub);
 
-  for (unsigned int i = 0; i < length && success; i++)
-    success &= dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &arrayString[i]);
+    for (unsigned int i = 0; i < length && success; i++)
+      success &= dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &arrayString[i]);
 
-  success &= dbus_message_iter_close_container(&m_args, &sub);
+    success &= dbus_message_iter_close_container(&m_args, &sub);
 
-  return success;
+    return success;
+  }
+  else
+    return false;
 }
 
-DBusMessage *CDBusMessage::SendSystem()
+CDBusReplyPtr CDBusMessage::SendSystem()
 {
   return Send(DBUS_BUS_SYSTEM);
 }
 
-DBusMessage *CDBusMessage::SendSession()
+CDBusReplyPtr CDBusMessage::SendSession()
 {
   return Send(DBUS_BUS_SESSION);
 }
@@ -81,13 +91,13 @@
   return SendAsync(DBUS_BUS_SESSION);
 }
 
-DBusMessage *CDBusMessage::Send(DBusBusType type)
+CDBusReplyPtr CDBusMessage::Send(DBusBusType type)
 {
   DBusError error;
   dbus_error_init (&error);
   DBusConnection *con = dbus_bus_get(type, &error);
 
-  DBusMessage *returnMessage = Send(con, &error);
+  CDBusReplyPtr returnMessage = Send(con, &error);
 
   if (dbus_error_is_set(&error))
     CLog::Log(LOGERROR, "DBus: Error %s - %s", error.name, error.message);
@@ -110,33 +120,39 @@
     return false;
 }
 
-DBusMessage *CDBusMessage::Send(DBusConnection *con, DBusError *error)
+CDBusReplyPtr CDBusMessage::Send(DBusConnection *con, DBusError *error)
 {
+  CDBusReplyPtr reply = CDBusReplyPtr(new CDBusReply());
+
   if (con && m_message)
   {
-    if (m_reply)
-      dbus_message_unref(m_reply);
+    DBusMessage *msg = dbus_connection_send_with_reply_and_block(con, m_message, -1, error);
 
-    m_reply = dbus_connection_send_with_reply_and_block(con, m_message, -1, error);
+    if (!dbus_error_is_set(error))
+      reply = CDBusReplyPtr(new CDBusReply(msg));
+
+    if (msg)
+      dbus_message_unref(msg);
   }
 
-  return m_reply;
+  return reply;
 }
 
 void CDBusMessage::Close()
 {
   if (m_message)
     dbus_message_unref(m_message);
-
-  if (m_reply)
-    dbus_message_unref(m_reply);
 }
 
-void CDBusMessage::PrepareArgument()
+bool CDBusMessage::PrepareArgument()
 {
+  if (m_message == NULL)
+    return false;
+
   if (!m_haveArgs)
     dbus_message_iter_init_append(m_message, &m_args);
 
   m_haveArgs = true;
+  return true;
 }
 #endif
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusMessage.h xbmc-dharma-35100.patch/xbmc/linux/DBusMessage.h
--- xbmc-dharma-35100/xbmc/linux/DBusMessage.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusMessage.h	2010-11-01 21:15:30.826797511 +0100
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2009 Team XBMC
+ *      Copyright (C) 2005-2010 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -19,8 +19,10 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
+
 #include "system.h"
 #ifdef HAS_DBUS
+#include "DBusReply.h"
 #include <dbus/dbus.h>
 
 class CDBusMessage
@@ -33,23 +35,22 @@
   bool AppendArgument(const char *string);
   bool AppendArgument(const char **arrayString, unsigned int length);
 
-  DBusMessage *SendSystem();
-  DBusMessage *SendSession();
+  CDBusReplyPtr SendSystem();
+  CDBusReplyPtr SendSession();
 
   bool SendAsyncSystem();
   bool SendAsyncSession();
 
-  DBusMessage *Send(DBusBusType type);
-  DBusMessage *Send(DBusConnection *con, DBusError *error);
+  CDBusReplyPtr Send(DBusBusType type);
+  CDBusReplyPtr Send(DBusConnection *con, DBusError *error);
 private:
 
   bool SendAsync(DBusBusType type);
 
   void Close();
-  void PrepareArgument();
+  bool PrepareArgument();
 
   DBusMessage *m_message;
-  DBusMessage *m_reply;
   DBusMessageIter m_args;
   bool m_haveArgs;
 };
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusReply.cpp xbmc-dharma-35100.patch/xbmc/linux/DBusReply.cpp
--- xbmc-dharma-35100/xbmc/linux/DBusReply.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusReply.cpp	2010-11-01 21:15:30.859797897 +0100
@@ -0,0 +1,218 @@
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DBusReply.h"
+#ifdef HAS_DBUS
+#include "log.h"
+#include <dbus/dbus.h>
+
+using namespace std;
+
+CDBusReply::CDBusReply(DBusMessage *message)
+{
+  m_message = message;
+  m_iterator = NULL;
+  m_hasMoreArguments = true;
+  m_error = false;
+
+  if (m_message)
+  {
+    m_iterator = new DBusMessageIter();
+    dbus_message_iter_init (m_message, m_iterator);
+    dbus_message_ref(m_message);
+  }
+}
+
+CDBusReply::CDBusReply()
+{
+  m_message = NULL;
+  m_iterator = NULL;
+  m_hasMoreArguments = false;
+  m_error = true;
+}
+
+CDBusReply::~CDBusReply()
+{
+  delete m_iterator;
+  m_iterator = NULL;
+
+  if (m_message)
+    dbus_message_unref(m_message);
+}
+
+CVariant CDBusReply::GetNextArgument()
+{
+  CVariant argument;
+
+  if (m_iterator && m_hasMoreArguments)
+  {
+    ParseIter(m_iterator, argument);
+    m_hasMoreArguments = dbus_message_iter_next(m_iterator);
+  }
+
+  return argument;
+}
+
+bool CDBusReply::IsErrorSet()
+{
+  return m_error;
+}
+
+string CDBusReply::ParseIter(DBusMessageIter *iter, CVariant &parsed)
+{
+  int type = dbus_message_iter_get_arg_type (iter);
+  string key;
+
+  if (type == DBUS_TYPE_INVALID)
+    return key;
+    
+  switch (type)
+  {
+    case DBUS_TYPE_OBJECT_PATH:
+    case DBUS_TYPE_STRING:
+    {
+      char *val;
+      dbus_message_iter_get_basic (iter, &val);
+
+      parsed = val;
+      break;
+    }
+
+    case DBUS_TYPE_BOOLEAN:
+    {
+      dbus_bool_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (bool)val;
+      break;
+    }
+
+    case DBUS_TYPE_INT16:
+    {
+      dbus_int16_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (int64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_INT32:
+    {
+      dbus_int32_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (int64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_INT64:
+    {
+      dbus_int64_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (int64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_UINT16:
+    {
+      dbus_uint16_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (uint64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_UINT32:
+    {
+      dbus_uint32_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (uint64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_UINT64:
+    {
+      dbus_uint64_t val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (uint64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_BYTE:
+    {
+      // TODO variant should have byte support since it could be used for useful stuff.
+      unsigned char val;
+      dbus_message_iter_get_basic (iter, &val);
+      parsed = (int64_t)val;
+      break;
+    }
+
+    case DBUS_TYPE_VARIANT:
+    {
+      DBusMessageIter variant;
+      dbus_message_iter_recurse (iter, &variant);
+
+      ParseIter(&variant, parsed);
+      break;
+    }
+
+    case DBUS_TYPE_DICT_ENTRY:
+    {
+      DBusMessageIter dictIter;
+
+      dbus_message_iter_recurse (iter, &dictIter);
+
+      CVariant keyVariant;
+      ParseIter(&dictIter, keyVariant);
+      key = keyVariant.asString();
+
+      dbus_message_iter_next (&dictIter);
+      ParseIter(&dictIter, parsed);
+      break;
+    }
+
+    case DBUS_TYPE_STRUCT:
+    case DBUS_TYPE_ARRAY:
+    {
+      DBusMessageIter containerIter;
+
+      dbus_message_iter_recurse (iter, &containerIter);
+
+      do
+      {
+        CVariant value;
+
+        string key = ParseIter(&containerIter, value);
+        if (key.size() == 0)
+          parsed.push_back(value);
+        else if (!value.isNull())
+          parsed[key] = value;
+        else
+          CLog::Log(LOGWARNING, "DBus: recieved a key '%s' with no value. Don't add to map", key.c_str());
+
+      } while (dbus_message_iter_next(&containerIter));
+      break;
+    }
+
+    default:
+      CLog::Log(LOGWARNING, "DBus: unkown argument type '%c'", type);
+      break;
+  }
+
+  return key;
+}
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusReply.h xbmc-dharma-35100.patch/xbmc/linux/DBusReply.h
--- xbmc-dharma-35100/xbmc/linux/DBusReply.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusReply.h	2010-11-01 21:15:30.866797980 +0100
@@ -0,0 +1,50 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#ifdef HAS_DBUS
+#include "Variant.h"
+#include <boost/shared_ptr.hpp>
+
+struct DBusMessage;
+struct DBusMessageIter;
+
+class CDBusReply : public CVariant
+{
+public:
+  CDBusReply(DBusMessage *message);
+  CDBusReply();
+  virtual ~CDBusReply();
+
+  CVariant GetNextArgument();
+  bool IsErrorSet();
+private:
+  std::string ParseIter(DBusMessageIter *iter, CVariant &parsed);
+
+  DBusMessageIter *m_iterator;
+  DBusMessage *m_message;
+  bool m_hasMoreArguments;
+  bool m_error;
+};
+
+typedef boost::shared_ptr<CDBusReply> CDBusReplyPtr;
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusUtil.cpp xbmc-dharma-35100.patch/xbmc/linux/DBusUtil.cpp
--- xbmc-dharma-35100/xbmc/linux/DBusUtil.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusUtil.cpp	2010-11-01 21:15:30.868798004 +0100
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2005-2009 Team XBMC
+ *      Copyright (C) 2005-2010 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -18,32 +18,22 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
+
 #include "DBusUtil.h"
 #ifdef HAS_DBUS
+#include "DBusMessage.h"
 #include "log.h"
 
-CVariant CDBusUtil::GetVariant(const char *destination, const char *object, const char *interface, const char *property)
+CVariant CDBusUtil::GetProperty(const char *destination, const char *object, const char *interface, const char *property)
 {
 //dbus-send --system --print-reply --dest=destination object org.freedesktop.DBus.Properties.Get string:interface string:property
-  CDBusMessage message(destination, object, "org.freedesktop.DBus.Properties", "Get");
+  CDBusMessage message(destination, object, DBUS_INTERFACE_PROPERTIES, "Get");
   CVariant result;
 
   if (message.AppendArgument(interface) && message.AppendArgument(property))
   {
-    DBusMessage *reply = message.SendSystem();
-
-    if (reply)
-    {
-      DBusMessageIter iter;
-
-      if (dbus_message_iter_init(reply, &iter))
-      {
-        if (!dbus_message_has_signature(reply, "v"))
-          CLog::Log(LOGERROR, "DBus: wrong signature on Get - should be \"v\" but was %s", dbus_message_iter_get_signature(&iter));
-        else
-          result = ParseVariant(&iter);
-      }
-    }
+    CDBusReplyPtr reply = message.SendSystem();
+    result = reply->GetNextArgument();
   }
   else
     CLog::Log(LOGERROR, "DBus: append arguments failed");
@@ -53,113 +43,12 @@
 
 CVariant CDBusUtil::GetAll(const char *destination, const char *object, const char *interface)
 {
-  CDBusMessage message(destination, object, "org.freedesktop.DBus.Properties", "GetAll");
+  CDBusMessage message(destination, object, DBUS_INTERFACE_PROPERTIES, "GetAll");
   CVariant properties;
   message.AppendArgument(interface);
-  DBusMessage *reply = message.SendSystem();
-  if (reply)
-  {
-    DBusMessageIter iter;
-    if (dbus_message_iter_init(reply, &iter))
-    {
-      if (!dbus_message_has_signature(reply, "a{sv}"))
-        CLog::Log(LOGERROR, "DBus: wrong signature on GetAll - should be \"a{sv}\" but was %s", dbus_message_iter_get_signature(&iter));
-      else
-      {
-        do
-        {
-          DBusMessageIter sub;
-          dbus_message_iter_recurse(&iter, &sub);
-          do
-          {
-            DBusMessageIter dict;
-            dbus_message_iter_recurse(&sub, &dict);
-            do
-            {
-              const char * key = NULL;
-
-              dbus_message_iter_get_basic(&dict, &key);
-              dbus_message_iter_next(&dict);
-
-              CVariant value = ParseVariant(&dict);
-
-              if (!value.isNull())
-                properties[key] = value;
-
-            } while (dbus_message_iter_next(&dict));
-
-          } while (dbus_message_iter_next(&sub));
-
-        } while (dbus_message_iter_next(&iter));
-      }
-    }
-  }
+  CDBusReplyPtr reply = message.SendSystem();
+  properties = reply->GetNextArgument();
 
   return properties;
 }
-
-CVariant CDBusUtil::ParseVariant(DBusMessageIter *itr)
-{
-  DBusMessageIter variant;
-  dbus_message_iter_recurse(itr, &variant);
-
-  return ParseType(&variant);
-}
-
-CVariant CDBusUtil::ParseType(DBusMessageIter *itr)
-{
-  CVariant value;
-  const char *    string  = NULL;
-  dbus_int32_t    int32   = 0;
-  dbus_uint32_t   uint32  = 0;
-  dbus_int64_t    int64   = 0;
-  dbus_uint64_t   uint64  = 0;
-  dbus_bool_t     boolean = false;
-
-  int type = dbus_message_iter_get_arg_type(itr);
-  switch (type)
-  {
-  case DBUS_TYPE_OBJECT_PATH:
-  case DBUS_TYPE_STRING:
-    dbus_message_iter_get_basic(itr, &string);
-    value = string;
-    break;
-  case DBUS_TYPE_UINT32:
-    dbus_message_iter_get_basic(itr, &uint32);
-    value = (uint64_t)uint32;
-    break;
-  case DBUS_TYPE_BYTE:
-  case DBUS_TYPE_INT32:
-    dbus_message_iter_get_basic(itr, &int32);
-    value = (int64_t)int32;
-    break;
-  case DBUS_TYPE_UINT64:
-    dbus_message_iter_get_basic(itr, &uint64);
-    value = (uint64_t)uint64;
-    break;
-  case DBUS_TYPE_INT64:
-    dbus_message_iter_get_basic(itr, &int64);
-    value = (int64_t)int64;
-    break;
-  case DBUS_TYPE_BOOLEAN:
-    dbus_message_iter_get_basic(itr, &boolean);
-    value = (bool)boolean;
-    break;
-  case DBUS_TYPE_ARRAY:
-    DBusMessageIter array;
-    dbus_message_iter_recurse(itr, &array);
-
-    value = CVariant::VariantTypeArray;
-
-    do
-    {
-      CVariant item = ParseType(&array);
-      if (!item.isNull())
-        value.push_back(item);
-    } while (dbus_message_iter_next(&array));
-    break;
-  }
-
-  return value;
-}
 #endif
diff -Naur xbmc-dharma-35100/xbmc/linux/DBusUtil.h xbmc-dharma-35100.patch/xbmc/linux/DBusUtil.h
--- xbmc-dharma-35100/xbmc/linux/DBusUtil.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DBusUtil.h	2010-11-01 21:15:30.869798016 +0100
@@ -1,6 +1,6 @@
 #pragma once
 /*
- *      Copyright (C) 2005-2009 Team XBMC
+ *      Copyright (C) 2005-2010 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -19,19 +19,16 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
+
 #include "system.h"
 #ifdef HAS_DBUS
-#include "DBusMessage.h"
 #include "Variant.h"
 
 class CDBusUtil
 {
 public:
   static CVariant GetAll(const char *destination, const char *object, const char *interface);
-
-  static CVariant GetVariant(const char *destination, const char *object, const char *interface, const char *property);
+  static CVariant GetProperty(const char *destination, const char *object, const char *interface, const char *property);
 private:
-  static CVariant ParseType(DBusMessageIter *itr);
-  static CVariant ParseVariant(DBusMessageIter *itr);
 };
 #endif
diff -Naur xbmc-dharma-35100/xbmc/linux/DeviceKitDisksProvider.cpp xbmc-dharma-35100.patch/xbmc/linux/DeviceKitDisksProvider.cpp
--- xbmc-dharma-35100/xbmc/linux/DeviceKitDisksProvider.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DeviceKitDisksProvider.cpp	2010-11-01 21:15:30.872798050 +0100
@@ -21,6 +21,8 @@
 #include "DeviceKitDisksProvider.h"
 #ifdef HAS_DBUS
 #include "Util.h"
+#include "DBusUtil.h"
+#include "DBusMessage.h"
 #include "AdvancedSettings.h"
 #include "LocalizeStrings.h"
 #include "log.h"
@@ -53,7 +55,7 @@
   m_isSystemInternal = properties["device-is-system-internal"].asBoolean();
   m_isOptical = properties["device-is-optical-disc"].asBoolean();
   if (m_isPartition)
-    m_isRemovable = CDBusUtil::GetVariant("org.freedesktop.DeviceKit.Disks", properties["partition-slave"].asString(), "org.freedesktop.DeviceKit.Disks.Device", "device-is-removable").asBoolean();
+    m_isRemovable = CDBusUtil::GetProperty("org.freedesktop.DeviceKit.Disks", properties["partition-slave"].asString(), "org.freedesktop.DeviceKit.Disks.Device", "device-is-removable").asBoolean();
   else
     m_isRemovable = properties["device-is-removable"].asBoolean();
 }
@@ -87,7 +89,7 @@
   m_isSystemInternal = properties["DeviceIsSystemInternal"].asBoolean();
   m_isOptical = properties["DeviceIsOpticalDisc"].asBoolean();
   if (m_isPartition)
-    m_isRemovable = CDBusUtil::GetVariant("org.freedesktop.DeviceKit.Disks", properties["PartitionSlave"].asString(), "org.freedesktop.DeviceKit.Disks.Device", "DeviceIsRemovable").asBoolean();
+    m_isRemovable = CDBusUtil::GetProperty("org.freedesktop.DeviceKit.Disks", properties["PartitionSlave"].asString(), "org.freedesktop.DeviceKit.Disks.Device", "DeviceIsRemovable").asBoolean();
   else
     m_isRemovable = properties["DeviceIsRemovable"].asBoolean();
 }
@@ -118,16 +120,13 @@
     const char *array[] = {};
     message.AppendArgument(array, 0);
 
-    DBusMessage *reply = message.SendSystem();
-    if (reply)
+    CDBusReplyPtr reply = message.SendSystem();
+    CVariant arg = reply->GetNextArgument();
+    if (arg.isString())
     {
-      char *mountPoint;
-      if (dbus_message_get_args (reply, NULL, DBUS_TYPE_STRING, &mountPoint, DBUS_TYPE_INVALID))
-      {
-        m_MountPath = mountPoint;
-        CLog::Log(LOGDEBUG, "DeviceKit.Disks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
-        m_isMountedByUs = m_isMounted = true;
-      }
+      m_MountPath = arg.asString();
+      CLog::Log(LOGDEBUG, "DeviceKit.Disks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), m_MountPath.c_str());
+      m_isMountedByUs = m_isMounted = true;
     }
 
     return m_isMounted;
@@ -147,8 +146,8 @@
     const char *array[1];
     message.AppendArgument(array, 0);
 
-    DBusMessage *reply = message.SendSystem();
-    if (reply)
+    CDBusReplyPtr reply = message.SendSystem();
+    if (!reply->IsErrorSet())
       m_isMountedByUs = m_isMounted = false;
 
     return !m_isMounted;
@@ -238,7 +237,7 @@
 void CDeviceKitDisksProvider::Initialize()
 {
   CLog::Log(LOGDEBUG, "Selected DeviceKit.Disks as storage provider");
-  m_DaemonVersion = atoi(CDBusUtil::GetVariant("org.freedesktop.DeviceKit.Disks", "/org/freedesktop/DeviceKit/Disks", "org.freedesktop.DeviceKit.Disks", "DaemonVersion").asString());
+  m_DaemonVersion = atoi(CDBusUtil::GetProperty("org.freedesktop.DeviceKit.Disks", "/org/freedesktop/DeviceKit/Disks", "org.freedesktop.DeviceKit.Disks", "DaemonVersion").asString());
   CLog::Log(LOGDEBUG, "DeviceKit.Disks: DaemonVersion %i", m_DaemonVersion);
 
   CLog::Log(LOGDEBUG, "DeviceKit.Disks: Querying available devices");
@@ -404,20 +403,11 @@
 {
   std::vector<CStdString> devices;
   CDBusMessage message("org.freedesktop.DeviceKit.Disks", "/org/freedesktop/DeviceKit/Disks", "org.freedesktop.DeviceKit.Disks", "EnumerateDevices");
-  DBusMessage *reply = message.SendSystem();
-  if (reply)
-  {
-    char** disks  = NULL;
-    int    length = 0;
+  CDBusReplyPtr reply = message.SendSystem();
+  CVariant objectPaths = reply->GetNextArgument();
 
-    if (dbus_message_get_args (reply, NULL, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &disks, &length, DBUS_TYPE_INVALID))
-    {
-      for (int i = 0; i < length; i++)
-        devices.push_back(disks[i]);
-
-      dbus_free_string_array(disks);
-    }
-  }
+  for (int i = 0; i < objectPaths.size(); i++)
+    devices.push_back(objectPaths[i].asString());
 
   return devices;
 }
diff -Naur xbmc-dharma-35100/xbmc/linux/DeviceKitDisksProvider.h xbmc-dharma-35100.patch/xbmc/linux/DeviceKitDisksProvider.h
--- xbmc-dharma-35100/xbmc/linux/DeviceKitDisksProvider.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/DeviceKitDisksProvider.h	2010-11-01 21:15:30.873798062 +0100
@@ -20,8 +20,9 @@
  *
  */
 #include "IStorageProvider.h"
+#include "system.h"
 #ifdef HAS_DBUS
-#include "DBusUtil.h"
+#include <dbus/dbus.h>
 
 class CDeviceKitDiskDevice
 {
diff -Naur xbmc-dharma-35100/xbmc/linux/Makefile.in xbmc-dharma-35100.patch/xbmc/linux/Makefile.in
--- xbmc-dharma-35100/xbmc/linux/Makefile.in	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/Makefile.in	2010-11-01 21:15:30.874798074 +0100
@@ -7,7 +7,7 @@
 
 CXXFLAGS+=-fPIC #-DHAS_SDL
 
-SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp NetworkLinux.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp DBusUtil.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp ConsoleUPowerSyscall.cpp
+SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp NetworkLinux.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp ConsoleUPowerSyscall.cpp DBusUtil.cpp DBusReply.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp
 
 LIB=linux.a
 
diff -Naur xbmc-dharma-35100/xbmc/linux/UDisksProvider.cpp xbmc-dharma-35100.patch/xbmc/linux/UDisksProvider.cpp
--- xbmc-dharma-35100/xbmc/linux/UDisksProvider.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/UDisksProvider.cpp	2010-11-01 21:15:30.877798110 +0100
@@ -21,6 +21,8 @@
 #include "UDisksProvider.h"
 #ifdef HAS_DBUS
 #include "Util.h"
+#include "DBusUtil.h"
+#include "DBusMessage.h"
 #include "AdvancedSettings.h"
 #include "LocalizeStrings.h"
 #include "log.h"
@@ -72,7 +74,7 @@
   m_isOptical = properties["DeviceIsOpticalDisc"].asBoolean();
   if (m_isPartition)
   {
-    CVariant isRemovable = CDBusUtil::GetVariant("org.freedesktop.UDisks", properties["PartitionSlave"].asString(), "org.freedesktop.UDisks.Device", "DeviceIsRemovable");
+    CVariant isRemovable = CDBusUtil::GetProperty("org.freedesktop.UDisks", properties["PartitionSlave"].asString(), "org.freedesktop.UDisks.Device", "DeviceIsRemovable");
 
     if ( !isRemovable.isNull() )
       m_isRemovable = isRemovable.asBoolean();
@@ -93,16 +95,13 @@
     const char *array[] = {};
     message.AppendArgument(array, 0);
 
-    DBusMessage *reply = message.SendSystem();
-    if (reply)
+    CDBusReplyPtr reply = message.SendSystem();
+    CVariant arg = reply->GetNextArgument();
+    if (arg.isString())
     {
-      char *mountPoint;
-      if (dbus_message_get_args (reply, NULL, DBUS_TYPE_STRING, &mountPoint, DBUS_TYPE_INVALID))
-      {
-        m_MountPath = mountPoint;
-        CLog::Log(LOGDEBUG, "UDisks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
-        m_isMountedByUs = m_isMounted = true;
-      }
+      m_MountPath = arg.asString();
+      CLog::Log(LOGDEBUG, "UDisks.Disks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), m_MountPath.c_str());
+      m_isMountedByUs = m_isMounted = true;
     }
 
     return m_isMounted;
@@ -122,8 +121,8 @@
     const char *array[1];
     message.AppendArgument(array, 0);
 
-    DBusMessage *reply = message.SendSystem();
-    if (reply)
+    CDBusReplyPtr reply = message.SendSystem();
+    if (!reply->IsErrorSet())
       m_isMountedByUs = m_isMounted = false;
 
     return !m_isMounted;
@@ -218,7 +217,7 @@
 void CUDisksProvider::Initialize()
 {
   CLog::Log(LOGDEBUG, "Selected UDisks as storage provider");
-  m_DaemonVersion = atoi(CDBusUtil::GetVariant("org.freedesktop.UDisks", "/org/freedesktop/UDisks", "org.freedesktop.UDisks", "DaemonVersion").asString());
+  m_DaemonVersion = atoi(CDBusUtil::GetProperty("org.freedesktop.UDisks", "/org/freedesktop/UDisks", "org.freedesktop.UDisks", "DaemonVersion").asString());
   CLog::Log(LOGDEBUG, "UDisks: DaemonVersion %i", m_DaemonVersion);
 
   CLog::Log(LOGDEBUG, "UDisks: Querying available devices");
@@ -381,20 +380,11 @@
 {
   std::vector<CStdString> devices;
   CDBusMessage message("org.freedesktop.UDisks", "/org/freedesktop/UDisks", "org.freedesktop.UDisks", "EnumerateDevices");
-  DBusMessage *reply = message.SendSystem();
-  if (reply)
-  {
-    char** disks  = NULL;
-    int    length = 0;
+  CDBusReplyPtr reply = message.SendSystem();
+  CVariant objectPaths = reply->GetNextArgument();
 
-    if (dbus_message_get_args (reply, NULL, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &disks, &length, DBUS_TYPE_INVALID))
-    {
-      for (int i = 0; i < length; i++)
-        devices.push_back(disks[i]);
-
-      dbus_free_string_array(disks);
-    }
-  }
+  for (int i = 0; i < objectPaths.size(); i++)
+    devices.push_back(objectPaths[i].asString());
 
   return devices;
 }
diff -Naur xbmc-dharma-35100/xbmc/linux/UDisksProvider.h xbmc-dharma-35100.patch/xbmc/linux/UDisksProvider.h
--- xbmc-dharma-35100/xbmc/linux/UDisksProvider.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/UDisksProvider.h	2010-11-01 21:15:30.877798110 +0100
@@ -21,7 +21,7 @@
  */
 #include "IStorageProvider.h"
 #ifdef HAS_DBUS
-#include "DBusUtil.h"
+#include <dbus/dbus.h>
 
 class CUDiskDevice
 {
