diff -Naur xbmc-dharma-35100/addons/skin.confluence/720p/DialogAccessPoints.xml xbmc-dharma-35100.patch/addons/skin.confluence/720p/DialogAccessPoints.xml
diff -Naur xbmc-dharma-35100/guilib/system.h xbmc-dharma-35100.patch/guilib/system.h
--- xbmc-dharma-35100/guilib/system.h	2010-10-30 05:36:40.000000000 +0200
+++ xbmc-dharma-35100.patch/guilib/system.h	2010-11-01 21:17:04.300892931 +0100
@@ -109,7 +109,6 @@
 #ifdef __APPLE__
 #define HAS_ZEROCONF
 #define HAS_GL
-#define HAS_LINUX_NETWORK
 #define HAS_SDL_AUDIO
 #define HAS_SDL_OPENGL
 #define HAS_SDL_WIN_EVENTS
@@ -132,7 +131,6 @@
 #define HAS_DBUS_SERVER
 #define HAS_GL
 #define HAS_GLX
-#define HAS_LINUX_NETWORK
 #define HAS_SDL_AUDIO
 #define HAS_LIRC
 #define HAS_SDL_WIN_EVENTS
diff -Naur xbmc-dharma-35100/language/English/strings.xml xbmc-dharma-35100.patch/language/English/strings.xml
--- xbmc-dharma-35100/language/English/strings.xml	2010-10-30 05:36:15.000000000 +0200
+++ xbmc-dharma-35100.patch/language/English/strings.xml	2010-11-01 21:17:04.344893446 +0100
@@ -2338,6 +2338,10 @@
   <string id="33082">Path to script</string>
   <string id="33083">Enable custom script button</string>
 
+  <string id="33200">Available connections</string>
+  <string id="33201">Disconnected</string>
+ 	<string id="33202">Connecting</string>
+
   <!-- translators: no need to add these to your language files -->
   <string id="34000">Lame</string>
   <string id="34001">Vorbis</string>
diff -Naur xbmc-dharma-35100/xbmc/Application.cpp xbmc-dharma-35100.patch/xbmc/Application.cpp
--- xbmc-dharma-35100/xbmc/Application.cpp	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/Application.cpp	2010-11-01 21:17:04.356893586 +0100
@@ -22,7 +22,7 @@
 #if (defined HAVE_CONFIG_H) && (!defined WIN32)
   #include "config.h"
 #endif
-#include "Application.h"
+#include "Application.h" 
 #include "utils/Builtins.h"
 #include "SystemGlobals.h"
 #include "Splash.h"
@@ -115,7 +115,6 @@
 #endif
 #include "AudioContext.h"
 #include "GUIFontTTF.h"
-#include "utils/Network.h"
 #include "utils/IoSupport.h"
 #include "Zeroconf.h"
 #include "ZeroconfBrowser.h"
@@ -213,9 +212,7 @@
 #include "GUIDialogPictureInfo.h"
 #include "GUIDialogAddonSettings.h"
 #include "GUIDialogAddonInfo.h"
-#ifdef HAS_LINUX_NETWORK
 #include "GUIDialogAccessPoints.h"
-#endif
 #include "GUIDialogFullScreenInfo.h"
 #include "GUIDialogTeletext.h"
 #include "GUIDialogSlider.h"
@@ -721,6 +718,7 @@
   CUtil::InitRandomSeed();
 
   g_mediaManager.Initialize();
+  m_network.Initialize();
 
   return Initialize();
 }
@@ -1057,9 +1055,7 @@
   g_windowManager.Add(new CGUIDialogPictureInfo);      // window id = 139
   g_windowManager.Add(new CGUIDialogAddonInfo);
   g_windowManager.Add(new CGUIDialogAddonSettings);      // window id = 140
-#ifdef HAS_LINUX_NETWORK
   g_windowManager.Add(new CGUIDialogAccessPoints);      // window id = 141
-#endif
 
   g_windowManager.Add(new CGUIDialogLockSettings); // window id = 131
 
@@ -1167,7 +1163,7 @@
 void CApplication::StartWebServer()
 {
 #ifdef HAS_WEB_SERVER
-  if (g_guiSettings.GetBool("services.webserver") && m_network.IsAvailable())
+  if (g_guiSettings.GetBool("services.webserver"))
   {
     int webPort = atoi(g_guiSettings.GetString("services.webserverport"));
     CLog::Log(LOGNOTICE, "Webserver: Starting...");
@@ -1178,13 +1174,13 @@
         return;
     }
 #endif
-
     if (m_WebServer.Start(webPort, g_guiSettings.GetString("services.webserverusername"), g_guiSettings.GetString("services.webserverpassword")))
     {
       // publish web frontend and API services
 #ifdef HAS_WEB_INTERFACE
       CZeroconf::GetInstance()->PublishService("servers.webserver", "_http._tcp", "XBMC Web Server", webPort);
 #endif
+
 #ifdef HAS_HTTPAPI
       CZeroconf::GetInstance()->PublishService("servers.webapi", "_xbmc-web._tcp", "XBMC HTTP API", webPort);
 #endif
@@ -1457,7 +1453,7 @@
 
 void CApplication::StopServices()
 {
-  m_network.NetworkMessage(CNetwork::SERVICES_DOWN, 0);
+  m_network.StopServices();
 
 #if !defined(_WIN32) && defined(HAS_DVD_DRIVE)
   CLog::Log(LOGNOTICE, "stop dvd detect media");
@@ -4685,6 +4681,8 @@
 {
   g_powerManager.ProcessEvents();
 
+  m_network.PumpNetworkEvents();
+
   // Store our file state for use on close()
   UpdateFileState();
 
@@ -5335,23 +5333,11 @@
 #endif
 }
 
-#if defined(HAS_LINUX_NETWORK)
-CNetworkLinux& CApplication::getNetwork()
-{
-  return m_network;
-}
-#elif defined(HAS_WIN32_NETWORK)
-CNetworkWin32& CApplication::getNetwork()
-{
-  return m_network;
-}
-#else
-CNetwork& CApplication::getNetwork()
+CNetworkManager& CApplication::getNetworkManager()
 {
   return m_network;
 }
 
-#endif
 #ifdef HAS_PERFORMANCE_SAMPLE
 CPerformanceStats &CApplication::GetPerformanceStats()
 {
diff -Naur xbmc-dharma-35100/xbmc/Application.h xbmc-dharma-35100.patch/xbmc/Application.h
--- xbmc-dharma-35100/xbmc/Application.h	2010-10-30 05:37:41.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/Application.h	2010-11-01 21:17:04.359893622 +0100
@@ -54,7 +54,7 @@
 #include "Bookmark.h"
 #include "utils/Stopwatch.h"
 #include "ApplicationMessenger.h"
-#include "utils/Network.h"
+#include "NetworkManager.h"
 #include "utils/CharsetConverter.h"
 #ifdef HAS_PERFORMANCE_SAMPLE
 #include "utils/PerformanceStats.h"
@@ -206,13 +206,8 @@
 
 
   CApplicationMessenger& getApplicationMessenger();
-#if defined(HAS_LINUX_NETWORK)
-  CNetworkLinux& getNetwork();
-#elif defined(HAS_WIN32_NETWORK)
-  CNetworkWin32& getNetwork();
-#else
-  CNetwork& getNetwork();
-#endif
+  CNetworkManager& getNetworkManager();
+
 #ifdef HAS_PERFORMANCE_SAMPLE
   CPerformanceStats &GetPerformanceStats();
 #endif
@@ -379,13 +374,9 @@
   void CreateUserDirs();
 
   CApplicationMessenger m_applicationMessenger;
-#if defined(HAS_LINUX_NETWORK)
-  CNetworkLinux m_network;
-#elif defined(HAS_WIN32_NETWORK)
-  CNetworkWin32 m_network;
-#else
-  CNetwork    m_network;
-#endif
+
+  CNetworkManager m_network;
+
 #ifdef HAS_PERFORMANCE_SAMPLE
   CPerformanceStats m_perfStats;
 #endif
diff -Naur xbmc-dharma-35100/xbmc/ApplicationMessenger.cpp xbmc-dharma-35100.patch/xbmc/ApplicationMessenger.cpp
--- xbmc-dharma-35100/xbmc/ApplicationMessenger.cpp	2010-10-30 05:36:50.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/ApplicationMessenger.cpp	2010-11-01 21:17:04.360893634 +0100
@@ -32,7 +32,6 @@
 #endif
 #include "GUIWindowSlideShow.h"
 #include "utils/Builtins.h"
-#include "utils/Network.h"
 #include "utils/log.h"
 #include "GUIWindowManager.h"
 #include "Settings.h"
@@ -550,12 +549,6 @@
       }
       break;
 
-    case TMSG_NETWORKMESSAGE:
-      {
-        g_application.getNetwork().NetworkMessage((CNetwork::EMESSAGE)pMsg->dwParam1, (int)pMsg->dwParam2);
-      }
-      break;
-
     case TMSG_GUI_DO_MODAL:
       {
         CGUIDialog *pDialog = (CGUIDialog *)pMsg->lpVoid;
@@ -924,12 +917,6 @@
   SendMessage(tMsg);
 }
 
-void CApplicationMessenger::NetworkMessage(DWORD dwMessage, DWORD dwParam)
-{
-  ThreadMessage tMsg = {TMSG_NETWORKMESSAGE, dwMessage, dwParam};
-  SendMessage(tMsg);
-}
-
 void CApplicationMessenger::SwitchToFullscreen()
 {
   /* FIXME: ideally this call should return upon a successfull switch but currently
diff -Naur xbmc-dharma-35100/xbmc/ApplicationMessenger.h xbmc-dharma-35100.patch/xbmc/ApplicationMessenger.h
--- xbmc-dharma-35100/xbmc/ApplicationMessenger.h	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/ApplicationMessenger.h	2010-11-01 21:17:04.362893656 +0100
@@ -70,8 +70,6 @@
 
 #define TMSG_HTTPAPI              400
 
-#define TMSG_NETWORKMESSAGE         500
-
 #define TMSG_GUI_DO_MODAL             600
 #define TMSG_GUI_SHOW                 601
 #define TMSG_GUI_ACTIVATE_WINDOW      604
@@ -149,8 +147,6 @@
   void HttpApi(std::string cmd, bool wait = false);
   void ExecBuiltIn(const CStdString &command);
 
-  void NetworkMessage(DWORD dwMessage, DWORD dwParam = 0);
-
   void DoModal(CGUIDialog *pDialog, int iWindowID, const CStdString &param = "");
   void Show(CGUIDialog *pDialog);
   void Close(CGUIDialog *pDialog, bool forceClose, bool waitResult=true);
diff -Naur xbmc-dharma-35100/xbmc/cores/VideoRenderers/RenderManager.h xbmc-dharma-35100.patch/xbmc/cores/VideoRenderers/RenderManager.h
--- xbmc-dharma-35100/xbmc/cores/VideoRenderers/RenderManager.h	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/cores/VideoRenderers/RenderManager.h	2010-11-01 21:17:04.487895121 +0100
@@ -21,6 +21,7 @@
  *
  */
 
+#include "system.h"
 #if defined (HAS_GL)
   #include "LinuxRendererGL.h"
 #elif HAS_GLES == 2
diff -Naur xbmc-dharma-35100/xbmc/FileSystem/FactoryDirectory.cpp xbmc-dharma-35100.patch/xbmc/FileSystem/FactoryDirectory.cpp
--- xbmc-dharma-35100/xbmc/FileSystem/FactoryDirectory.cpp	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/FileSystem/FactoryDirectory.cpp	2010-11-01 21:17:04.362893656 +0100
@@ -79,7 +79,6 @@
 #ifdef HAS_FILESYSTEM_HTSP
 #include "HTSPDirectory.h"
 #endif
-#include "../utils/Network.h"
 #include "ZipDirectory.h"
 #ifdef HAS_FILESYSTEM_RAR
 #include "RarDirectory.h"
@@ -141,7 +140,7 @@
   if (strProtocol == "filereader")
     return CFactoryDirectory::Create(url.GetFileName());
 
-  if( g_application.getNetwork().IsAvailable(true) )  // true to wait for the network (if possible)
+  if( g_application.getNetworkManager().IsAvailable() )  // true to wait for the network (if possible)
   {
     if (strProtocol == "lastfm") return new CLastFMDirectory();
     if (strProtocol == "tuxbox") return new CDirectoryTuxBox();
diff -Naur xbmc-dharma-35100/xbmc/FileSystem/FileFactory.cpp xbmc-dharma-35100.patch/xbmc/FileSystem/FileFactory.cpp
--- xbmc-dharma-35100/xbmc/FileSystem/FileFactory.cpp	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/FileSystem/FileFactory.cpp	2010-11-01 21:17:04.377893832 +0100
@@ -68,7 +68,6 @@
 #include "FileMusicDatabase.h"
 #include "FileSpecialProtocol.h"
 #include "MultiPathFile.h"
-#include "../utils/Network.h"
 #include "FileTuxBox.h"
 #include "HDHomeRun.h"
 #include "MythFile.h"
@@ -113,7 +112,7 @@
 #ifdef HAS_FILESYSTEM
   else if (strProtocol == "iso9660") return new CFileISO();
 #endif
-  if( g_application.getNetwork().IsAvailable() )
+  if( g_application.getNetworkManager().IsAvailable() )
   {
     if (strProtocol == "http"
     ||  strProtocol == "https"
diff -Naur xbmc-dharma-35100/xbmc/FileSystem/FileSmb.cpp xbmc-dharma-35100.patch/xbmc/FileSystem/FileSmb.cpp
--- xbmc-dharma-35100/xbmc/FileSystem/FileSmb.cpp	2010-10-30 05:37:41.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/FileSystem/FileSmb.cpp	2010-11-01 21:17:04.378893844 +0100
@@ -31,7 +31,6 @@
 #include "SMBDirectory.h"
 #include "Util.h"
 #include <libsmbclient.h>
-#include "../utils/Network.h"
 #include "AdvancedSettings.h"
 #include "GUISettings.h"
 #include "utils/SingleLock.h"
diff -Naur xbmc-dharma-35100/xbmc/GUIDialogAccessPoints.cpp xbmc-dharma-35100.patch/xbmc/GUIDialogAccessPoints.cpp
--- xbmc-dharma-35100/xbmc/GUIDialogAccessPoints.cpp	2010-10-30 05:36:47.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIDialogAccessPoints.cpp	2010-11-01 21:17:04.408894194 +0100
@@ -21,24 +21,81 @@
 
 #include "GUIDialogAccessPoints.h"
 #include "GUIDialogKeyboard.h"
-#ifdef _LINUX
-#include "NetworkLinux.h"
-#endif
 #include "Application.h"
 #include "FileItem.h"
 #include "LocalizeStrings.h"
+#include "JobManager.h"
+#include "ConnectionJob.h"
 
 #define CONTROL_ACCESS_POINTS 3
 
+const char *ConnectionStateToString(ConnectionState state)
+{
+  switch (state)
+  {
+    case NETWORK_CONNECTION_STATE_DISCONNECTED:
+      return "disconnected";
+    case NETWORK_CONNECTION_STATE_CONNECTING:
+      return "connecting";
+    case NETWORK_CONNECTION_STATE_CONNECTED:
+      return "connected";
+    case NETWORK_CONNECTION_STATE_FAILURE:
+      return "failure";
+    case NETWORK_CONNECTION_STATE_UNKNOWN:
+    default:
+      return "unknown";
+  }
+
+  return "";
+}
+
+const char *ConnectionTypeToString(ConnectionType type)
+{
+  switch (type)
+  {
+    case NETWORK_CONNECTION_TYPE_WIRED:
+      return "wired";
+    case NETWORK_CONNECTION_TYPE_WIFI:
+      return "wifi";
+    case NETWORK_CONNECTION_TYPE_UNKNOWN:
+    default:
+      return "unknown";
+  }
+
+  return "";
+}
+
+const char *EncryptionToString(EncryptionType type)
+{
+  switch (type)
+  {
+    case NETWORK_CONNECTION_ENCRYPTION_NONE:
+      return "";
+    case NETWORK_CONNECTION_ENCRYPTION_WEP:
+      return "wep";
+    case NETWORK_CONNECTION_ENCRYPTION_WPA:
+      return "wpa";
+    case NETWORK_CONNECTION_ENCRYPTION_WPA2:
+      return "wpa2";
+    case NETWORK_CONNECTION_ENCRYPTION_IEEE8021x:
+      return "wpa-rsn";
+    case NETWORK_CONNECTION_ENCRYPTION_UNKNOWN:
+    default:
+      return "unknown";
+  }
+
+  return "";
+}
+
 CGUIDialogAccessPoints::CGUIDialogAccessPoints(void)
     : CGUIDialog(WINDOW_DIALOG_ACCESS_POINTS, "DialogAccessPoints.xml")
 {
-  m_accessPoints = new CFileItemList;
+  m_connectionsFileList = new CFileItemList;
 }
 
 CGUIDialogAccessPoints::~CGUIDialogAccessPoints(void)
 {
-  delete m_accessPoints;
+  delete m_connectionsFileList;
 }
 
 bool CGUIDialogAccessPoints::OnAction(const CAction &action)
@@ -49,25 +106,15 @@
     OnMessage(msg);
     int iItem = msg.GetParam1();
 
-    if (iItem == (int) m_aps.size())
-    {
-       m_selectedAPEssId = "";
-       if (CGUIDialogKeyboard::ShowAndGetInput(m_selectedAPEssId, g_localizeStrings.Get(789), false))
-       {
-         m_selectedAPEncMode = m_aps[iItem].getEncryptionMode();
-         m_wasItemSelected = true;
-         Close();
-         return true;
-       }
-    }
-    else
-    {
-       m_selectedAPEssId = m_aps[iItem].getEssId();
-       m_selectedAPEncMode = m_aps[iItem].getEncryptionMode();
-       m_wasItemSelected = true;
-       Close();
-       return true;
-    }
+    ConnectionList connections = g_application.getNetworkManager().GetConnections();
+    CJobManager::GetInstance().AddJob(new CConnectionJob(connections[iItem]), this);
+
+    return true;
+  }
+  else if (action.GetID() == 300)
+  {
+    UpdateConnectionList();
+    return true;
   }
 
   return CGUIDialog::OnAction(action);
@@ -75,59 +122,42 @@
 
 void CGUIDialogAccessPoints::OnInitWindow()
 {
-  m_wasItemSelected = false;
-
   CGUIDialog::OnInitWindow();
 
+  UpdateConnectionList();
+}
+
+void CGUIDialogAccessPoints::UpdateConnectionList()
+{
+  m_connectionsFileList->Clear();
+
   CGUIMessage msgReset(GUI_MSG_LABEL_RESET, GetID(), CONTROL_ACCESS_POINTS);
   OnMessage(msgReset);
 
-  m_accessPoints->Clear();
-
-  CStdString ifaceName(m_interfaceName);
-  CNetworkInterface* iface = g_application.getNetwork().GetInterfaceByName(ifaceName);
-  m_aps = iface->GetAccessPoints();
+  ConnectionList connections = g_application.getNetworkManager().GetConnections();
 
-  for (int i = 0; i < (int) m_aps.size(); i++)
+  for (int i = 0; i < (int) connections.size(); i++)
   {
-      CFileItemPtr item(new CFileItem(m_aps[i].getEssId()));
+    CFileItemPtr item(new CFileItem(connections[i]->GetName()));
 
-      int q = m_aps[i].getQuality();
-      if (q <= 20) item->SetThumbnailImage("ap-signal1.png");
-      else if (q <= 40) item->SetThumbnailImage("ap-signal2.png");
-      else if (q <= 60) item->SetThumbnailImage("ap-signal3.png");
-      else if (q <= 80) item->SetThumbnailImage("ap-signal4.png");
-      else if (q <= 100) item->SetThumbnailImage("ap-signal5.png");
+    if (connections[i]->GetConnectionType() == NETWORK_CONNECTION_TYPE_WIFI)
+    {
+      item->SetProperty("signal", (int)(connections[i]->GetStrength() / 20));
+      item->SetProperty("encryption", EncryptionToString(connections[i]->GetEncryption()));
+    }
 
-      if (m_aps[i].getEncryptionMode() != ENC_NONE)
-         item->SetIconImage("ap-lock.png");
+    item->SetProperty("type", ConnectionTypeToString(connections[i]->GetConnectionType()));
+    item->SetProperty("state", ConnectionStateToString(connections[i]->GetConnectionState()));
 
-      m_accessPoints->Add(item);
+    m_connectionsFileList->Add(item);
   }
 
-  CFileItemPtr item(new CFileItem(g_localizeStrings.Get(1047)));
-  m_accessPoints->Add(item);
-
-  CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_ACCESS_POINTS, 0, 0, m_accessPoints);
+  CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_ACCESS_POINTS, 0, 0, m_connectionsFileList);
   OnMessage(msg);
 }
 
-void CGUIDialogAccessPoints::SetInterfaceName(CStdString interfaceName)
-{
-  m_interfaceName = interfaceName;
-}
-
-CStdString CGUIDialogAccessPoints::GetSelectedAccessPointEssId()
-{
-  return m_selectedAPEssId;
-}
-
-EncMode CGUIDialogAccessPoints::GetSelectedAccessPointEncMode()
-{
-  return m_selectedAPEncMode;
-}
-
-bool CGUIDialogAccessPoints::WasItemSelected()
+void CGUIDialogAccessPoints::OnJobComplete(unsigned int jobID, bool success, CJob *job)
 {
-  return m_wasItemSelected;
+  if (success)
+    Close();
 }
diff -Naur xbmc-dharma-35100/xbmc/GUIDialogAccessPoints.h xbmc-dharma-35100.patch/xbmc/GUIDialogAccessPoints.h
--- xbmc-dharma-35100/xbmc/GUIDialogAccessPoints.h	2010-10-30 05:36:42.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIDialogAccessPoints.h	2010-11-01 21:17:04.408894194 +0100
@@ -26,29 +26,23 @@
 
 #include <vector>
 #include "GUIDialog.h"
-#include "utils/Network.h"
+#include "IConnection.h"
+#include "Job.h"
 
 class CFileItemList;
 
-class CGUIDialogAccessPoints : public CGUIDialog
+class CGUIDialogAccessPoints : public CGUIDialog, public IJobCallback
 {
 public:
   CGUIDialogAccessPoints(void);
   virtual ~CGUIDialogAccessPoints(void);
   virtual void OnInitWindow();
   virtual bool OnAction(const CAction &action);
-  void SetInterfaceName(CStdString interfaceName);
-  CStdString GetSelectedAccessPointEssId();
-  EncMode GetSelectedAccessPointEncMode();
-  bool WasItemSelected();
 
+  virtual void OnJobComplete(unsigned int jobID, bool success, CJob *job);
 private:
-  std::vector<NetworkAccessPoint> m_aps;
-  CStdString m_interfaceName;
-  CStdString m_selectedAPEssId;
-  EncMode m_selectedAPEncMode;
-  bool m_wasItemSelected;
-  CFileItemList *m_accessPoints;
-};
+  void UpdateConnectionList();
 
+  CFileItemList *m_connectionsFileList;
+};
 #endif
diff -Naur xbmc-dharma-35100/xbmc/GUIDialogFileBrowser.cpp xbmc-dharma-35100.patch/xbmc/GUIDialogFileBrowser.cpp
--- xbmc-dharma-35100/xbmc/GUIDialogFileBrowser.cpp	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIDialogFileBrowser.cpp	2010-11-01 21:17:04.415894274 +0100
@@ -26,7 +26,6 @@
 #include "GUIDialogContextMenu.h"
 #include "MediaManager.h"
 #include "AutoSwitch.h"
-#include "utils/Network.h"
 #include "GUIPassword.h"
 #include "GUIWindowManager.h"
 #include "Application.h"
@@ -543,7 +542,7 @@
   else if ( iDriveType == CMediaSource::SOURCE_TYPE_REMOTE )
   {
     // TODO: Handle not connected to a remote share
-    if ( !g_application.getNetwork().IsConnected() )
+    if ( !g_application.getNetworkManager().IsConnected() )
     {
       CGUIDialogOK::ShowAndGetInput(220, 221, 0, 0);
       return false;
diff -Naur xbmc-dharma-35100/xbmc/GUIMediaWindow.cpp xbmc-dharma-35100.patch/xbmc/GUIMediaWindow.cpp
--- xbmc-dharma-35100/xbmc/GUIMediaWindow.cpp	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIMediaWindow.cpp	2010-11-01 21:17:04.417894300 +0100
@@ -29,7 +29,6 @@
 #include "FileSystem/MultiPathDirectory.h"
 #include "GUIPassword.h"
 #include "Application.h"
-#include "utils/Network.h"
 #include "utils/RegExp.h"
 #include "PartyModeManager.h"
 #include "GUIDialogMediaSource.h"
@@ -1020,7 +1019,7 @@
   else if (iDriveType==CMediaSource::SOURCE_TYPE_REMOTE)
   {
     // TODO: Handle not connected to a remote share
-    if ( !g_application.getNetwork().IsConnected() )
+    if ( !g_application.getNetworkManager().IsConnected() )
     {
       CGUIDialogOK::ShowAndGetInput(220, 221, 0, 0);
       return false;
@@ -1433,7 +1432,7 @@
 
 bool CGUIMediaWindow::WaitForNetwork() const
 {
-  if (g_application.getNetwork().IsAvailable())
+  if (g_application.getNetworkManager().IsAvailable())
     return true;
 
   CGUIDialogProgress *progress = (CGUIDialogProgress *)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
@@ -1445,7 +1444,7 @@
   progress->SetLine(1, url.GetWithoutUserDetails());
   progress->ShowProgressBar(false);
   progress->StartModal();
-  while (!g_application.getNetwork().IsAvailable())
+  while (!g_application.getNetworkManager().IsAvailable())
   {
     progress->Progress();
     if (progress->IsCanceled())
diff -Naur xbmc-dharma-35100/xbmc/GUISettings.cpp xbmc-dharma-35100.patch/xbmc/GUISettings.cpp
--- xbmc-dharma-35100/xbmc/GUISettings.cpp	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUISettings.cpp	2010-11-01 21:17:04.418894313 +0100
@@ -28,7 +28,6 @@
 #ifdef _LINUX
 #include "LinuxTimezone.h"
 #endif
-#include "utils/Network.h"
 #include "Application.h"
 #include "FileSystem/SpecialProtocol.h"
 #include "AdvancedSettings.h"
@@ -682,30 +681,14 @@
 #endif
 
   CSettingsCategory* net = AddCategory(6, "network", 798);
-  if (g_application.IsStandAlone())
-  {
-#ifndef __APPLE__
-    AddString(NULL, "network.interface",775,"", SPIN_CONTROL_TEXT);
-    AddInt(NULL, "network.assignment", 715, NETWORK_DHCP, NETWORK_DHCP, 1, NETWORK_DISABLED, SPIN_CONTROL_TEXT);
-    AddString(NULL, "network.ipaddress", 719, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
-    AddString(NULL, "network.subnet", 720, "255.255.255.0", EDIT_CONTROL_IP_INPUT);
-    AddString(NULL, "network.gateway", 721, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
-    AddString(NULL, "network.dns", 722, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
-    AddString(NULL, "network.dnssuffix", 22002, "", EDIT_CONTROL_INPUT, true);
-    AddString(NULL, "network.essid", 776, "0.0.0.0", BUTTON_CONTROL_STANDARD);
-    AddInt(NULL, "network.enc", 778, ENC_NONE, ENC_NONE, 1, ENC_WPA2, SPIN_CONTROL_TEXT);
-    AddString(NULL, "network.key", 777, "0.0.0.0", EDIT_CONTROL_INPUT);
-#ifndef _WIN32
-    AddString(NULL, "network.save", 779, "", BUTTON_CONTROL_STANDARD);
-#endif
-    AddSeparator(NULL, "network.sep1");
-#endif
-  }
+
   AddBool(net, "network.usehttpproxy", 708, false);
   AddString(net, "network.httpproxyserver", 706, "", EDIT_CONTROL_INPUT);
   AddString(net, "network.httpproxyport", 730, "8080", EDIT_CONTROL_NUMBER_INPUT, false, 707);
   AddString(net, "network.httpproxyusername", 1048, "", EDIT_CONTROL_INPUT);
   AddString(net, "network.httpproxypassword", 733, "", EDIT_CONTROL_HIDDEN_INPUT,true,733);
+  AddSeparator(net, "network.sep1");
+  AddString(net, "network.connected", 705, "", BUTTON_CONTROL_STANDARD);
 
   // appearance settings
   AddGroup(7, 480);
diff -Naur xbmc-dharma-35100/xbmc/GUIWindowFileManager.cpp xbmc-dharma-35100.patch/xbmc/GUIWindowFileManager.cpp
--- xbmc-dharma-35100/xbmc/GUIWindowFileManager.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIWindowFileManager.cpp	2010-11-01 21:17:04.421894349 +0100
@@ -42,7 +42,6 @@
 #endif
 #include "GUIWindowSlideShow.h"
 #include "PlayListFactory.h"
-#include "utils/Network.h"
 #include "GUIWindowManager.h"
 #include "GUIDialogOK.h"
 #include "GUIDialogYesNo.h"
@@ -656,7 +655,7 @@
   else if ( iDriveType == CMediaSource::SOURCE_TYPE_REMOTE )
   {
     // TODO: Handle not connected to a remote share
-    if ( !g_application.getNetwork().IsConnected() )
+    if ( !g_application.getNetworkManager().IsConnected() )
     {
       CGUIDialogOK::ShowAndGetInput(220, 221, 0, 0);
       return false;
diff -Naur xbmc-dharma-35100/xbmc/GUIWindowLoginScreen.cpp xbmc-dharma-35100.patch/xbmc/GUIWindowLoginScreen.cpp
--- xbmc-dharma-35100/xbmc/GUIWindowLoginScreen.cpp	2010-10-30 05:37:40.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIWindowLoginScreen.cpp	2010-11-01 21:17:04.422894361 +0100
@@ -32,7 +32,6 @@
 #include "lib/libscrobbler/scrobbler.h"
 #include "utils/Builtins.h"
 #include "utils/Weather.h"
-#include "utils/Network.h"
 #include "addons/Skin.h"
 #include "Profile.h"
 #include "GUIWindowManager.h"
@@ -266,9 +265,9 @@
 {
   if (profile != 0 || !g_settings.IsMasterUser())
   {
-    g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_DOWN,1);
+    g_application.getNetworkManager().StopServices();
     g_settings.LoadProfile(profile);
-    g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_UP,1);
+    g_application.getNetworkManager().StartServices();
   }
   else
   {
diff -Naur xbmc-dharma-35100/xbmc/GUIWindowSettingsCategory.cpp xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsCategory.cpp
--- xbmc-dharma-35100/xbmc/GUIWindowSettingsCategory.cpp	2010-10-30 05:36:50.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsCategory.cpp	2010-11-01 21:17:04.424894383 +0100
@@ -60,7 +60,6 @@
 #include "addons/Visualisation.h"
 #include "addons/AddonManager.h"
 #include "MediaManager.h"
-#include "utils/Network.h"
 #include "GUIControlGroupList.h"
 #include "GUIWindowManager.h"
 #include "GUIFontManager.h"
@@ -213,7 +212,6 @@
           }
         }
         m_iSection = focusedControl - CONTROL_START_BUTTONS;
-        CheckNetworkSettings();
 
         CreateSettings();
       }
@@ -267,7 +265,6 @@
       m_delayedSetting = NULL;
 
       CheckForUpdates();
-      CheckNetworkSettings();
       CGUIWindow::OnMessage(message);
       FreeControls();
       return true;
@@ -389,15 +386,6 @@
       control->SetDelayed();
 #endif
     }
-    else if (strSetting.Equals("network.assignment"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(716), NETWORK_DHCP);
-      pControl->AddLabel(g_localizeStrings.Get(717), NETWORK_STATIC);
-      pControl->AddLabel(g_localizeStrings.Get(787), NETWORK_DISABLED);
-      pControl->SetValue(pSettingInt->GetData());
-    }
     else if (strSetting.Equals("network.httpproxyport"))
     {
       CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
@@ -553,16 +541,6 @@
       pControl->AddLabel(g_localizeStrings.Get(22081), SELECT_ACTION_INFO);
       pControl->SetValue(pSettingInt->GetData());
     }
-    else if (strSetting.Equals("network.enc"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(780), ENC_NONE);
-      pControl->AddLabel(g_localizeStrings.Get(781), ENC_WEP);
-      pControl->AddLabel(g_localizeStrings.Get(782), ENC_WPA);
-      pControl->AddLabel(g_localizeStrings.Get(783), ENC_WPA2);
-      pControl->SetValue(pSettingInt->GetData());
-    }
     else if (strSetting.Equals("lookandfeel.startupwindow"))
     {
       FillInStartupWindow(pSetting);
@@ -571,10 +549,6 @@
     {
       FillInRegions(pSetting);
     }
-    else if (strSetting.Equals("network.interface"))
-    {
-       FillInNetworkInterfaces(pSetting);
-    }
     else if (strSetting.Equals("audiooutput.audiodevice"))
     {
       FillInAudioDevices(pSetting);
@@ -604,11 +578,6 @@
     }
   }
 
-  if (m_vecSections[m_iSection]->m_strCategory == "network")
-  {
-     NetworkInterfaceChanged();
-  }
-
   // update our settings (turns controls on/off as appropriate)
   UpdateSettings();
 }
@@ -821,74 +790,34 @@
         pControl->SetEnabled(g_guiSettings.GetBool("services.webserver"));
     }
 #endif
-    else if (strSetting.Equals("network.ipaddress") || strSetting.Equals("network.subnet") || strSetting.Equals("network.gateway") || strSetting.Equals("network.dns"))
-    {
-#ifdef _LINUX
-      bool enabled = (geteuid() == 0);
-#else
-      bool enabled = false;
-#endif
-      CGUISpinControlEx* pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.assignment")->GetID());
-      if (pControl1)
-         enabled = (pControl1->GetValue() == NETWORK_STATIC);
-
-       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-       if (pControl) pControl->SetEnabled(enabled);
-    }
-    else if (strSetting.Equals("network.assignment"))
-    {
-      CGUISpinControlEx* pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.assignment")->GetID());
-#ifdef HAS_LINUX_NETWORK
-      if (pControl1)
-         pControl1->SetEnabled(geteuid() == 0);
-#endif
-    }
-    else if (strSetting.Equals("network.essid") || strSetting.Equals("network.enc") || strSetting.Equals("network.key"))
-    {
-      // Get network information
-      CGUISpinControlEx *ifaceControl = (CGUISpinControlEx *)GetControl(GetSetting("network.interface")->GetID());
-      CStdString ifaceName = ifaceControl->GetLabel();
-      CNetworkInterface* iface = g_application.getNetwork().GetInterfaceByName(ifaceName);
-      bool bIsWireless = iface->IsWireless();
-
-#ifdef HAS_LINUX_NETWORK
-      bool enabled = bIsWireless && (geteuid() == 0);
-#else
-      bool enabled = bIsWireless;
-#endif
-      CGUISpinControlEx* pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.assignment")->GetID());
-      if (pControl1)
-         enabled &= (pControl1->GetValue() != NETWORK_DISABLED);
-
-      if (strSetting.Equals("network.key"))
-      {
-         pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.enc")->GetID());
-         if (pControl1) enabled &= (pControl1->GetValue() != ENC_NONE);
-      }
-
-       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-       if (pControl) pControl->SetEnabled(enabled);
-    }
     else if (strSetting.Equals("network.httpproxyserver")   || strSetting.Equals("network.httpproxyport") ||
              strSetting.Equals("network.httpproxyusername") || strSetting.Equals("network.httpproxypassword"))
     {
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
       if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("network.usehttpproxy"));
     }
-#ifdef HAS_LINUX_NETWORK
-    else if (strSetting.Equals("network.key"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      CGUISpinControlEx* pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.enc")->GetID());
-      if (pControl && pControl1)
-         pControl->SetEnabled(!pControl1->IsDisabled() && pControl1->GetValue() > 0);
-    }
-    else if (strSetting.Equals("network.save"))
+    else if (strSetting.Equals("network.connected"))
     {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(geteuid() == 0);
+      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
+
+      bool visible = g_application.getNetworkManager().CanManageConnections();
+      pControl->SetVisible(visible);
+      ((CGUIControl *)GetControl(GetSetting("network.sep1")->GetID()))->SetVisible(visible);
+
+      pControl->SetLabel(g_application.getNetworkManager().GetDefaultConnectionName());
+      switch (g_application.getNetworkManager().GetDefaultConnectionState())
+      {
+        case NETWORK_CONNECTION_STATE_CONNECTED:
+          pControl->SetLabel2(g_localizeStrings.Get(13296));
+          break;
+        case NETWORK_CONNECTION_STATE_CONNECTING:
+          pControl->SetLabel2(g_localizeStrings.Get(33202));
+          break;
+        default:
+          pControl->SetLabel2(g_localizeStrings.Get(33201));
+          break;
+      }
     }
-#endif
     else if (strSetting.Equals("scrobbler.lastfmusername") || strSetting.Equals("scrobbler.lastfmpass"))
     {
       CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
@@ -1327,19 +1256,6 @@
       CZeroconf::GetInstance()->Start();
 #endif
   }
-  else if (strSetting.Equals("network.ipaddress"))
-  {
-    if (g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC)
-    {
-      CStdString strDefault = g_guiSettings.GetString("network.ipaddress").Left(g_guiSettings.GetString("network.ipaddress").ReverseFind('.'))+".1";
-      if (g_guiSettings.GetString("network.gateway").Equals("0.0.0.0"))
-        g_guiSettings.SetString("network.gateway",strDefault);
-      if (g_guiSettings.GetString("network.dns").Equals("0.0.0.0"))
-        g_guiSettings.SetString("network.dns",strDefault);
-
-    }
-  }
-
   else if (strSetting.Equals("network.httpproxyport"))
   {
     ValidatePortNumber(pSettingControl, "8080", "8080", false);
@@ -1734,10 +1650,6 @@
       // Nothing todo here
     }
   }
-  else if (strSetting.Equals("network.interface"))
-  {
-     NetworkInterfaceChanged();
-  }
 #ifdef HAS_LINUX_NETWORK
   else if (strSetting.Equals("network.save"))
   {
@@ -1813,6 +1725,11 @@
     }
   }
 #endif
+  else if (strSetting.Equals("network.connected"))
+  {
+    vector<CStdString> params;
+    g_application.getApplicationMessenger().ActivateWindow(WINDOW_DIALOG_CONNECTIONS, params, false);
+  }
 #ifdef _LINUX
   else if (strSetting.Equals("locale.timezonecountry"))
   {
@@ -2006,52 +1923,6 @@
   }
 }
 
-void CGUIWindowSettingsCategory::CheckNetworkSettings()
-{
-  if (!g_application.IsStandAlone())
-    return;
-
-  // check if our network needs restarting (requires a reset, so check well!)
-  if (m_iNetworkAssignment == -1)
-  {
-    // nothing to do here, folks - move along.
-    return ;
-  }
-  // we need a reset if:
-  // 1.  The Network Assignment has changed OR
-  // 2.  The Network Assignment is STATIC and one of the network fields have changed
-  if (m_iNetworkAssignment != g_guiSettings.GetInt("network.assignment") ||
-      (m_iNetworkAssignment == NETWORK_STATIC && (
-         m_strNetworkIPAddress != g_guiSettings.GetString("network.ipaddress") ||
-         m_strNetworkSubnet != g_guiSettings.GetString("network.subnet") ||
-         m_strNetworkGateway != g_guiSettings.GetString("network.gateway") ||
-         m_strNetworkDNS != g_guiSettings.GetString("network.dns"))))
-  {
-/*    // our network settings have changed - we should prompt the user to reset XBMC
-    if (CGUIDialogYesNo::ShowAndGetInput(14038, 14039, 14040, 0))
-    {
-      // reset settings
-      g_application.getApplicationMessenger().RestartApp();
-      // Todo: aquire new network settings without restart app!
-    }
-    else*/
-
-    // update our settings variables
-    m_iNetworkAssignment = g_guiSettings.GetInt("network.assignment");
-    m_strNetworkIPAddress = g_guiSettings.GetString("network.ipaddress");
-    m_strNetworkSubnet = g_guiSettings.GetString("network.subnet");
-    m_strNetworkGateway = g_guiSettings.GetString("network.gateway");
-    m_strNetworkDNS = g_guiSettings.GetString("network.dns");
-
-    // replace settings
-    /*   g_guiSettings.SetInt("network.assignment", m_iNetworkAssignment);
-       g_guiSettings.SetString("network.ipaddress", m_strNetworkIPAddress);
-       g_guiSettings.SetString("network.subnet", m_strNetworkSubnet);
-       g_guiSettings.SetString("network.gateway", m_strNetworkGateway);
-       g_guiSettings.SetString("network.dns", m_strNetworkDNS);*/
-  }
-}
-
 void CGUIWindowSettingsCategory::FillInSubtitleHeights(CSetting *pSetting)
 {
   CSettingInt *pSettingInt = (CSettingInt*)pSetting;
@@ -2752,30 +2623,6 @@
   delete state;
 }
 
-void CGUIWindowSettingsCategory::FillInNetworkInterfaces(CSetting *pSetting)
-{
-  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-  pControl->Clear();
-
-  // query list of interfaces
-  vector<CStdString> vecInterfaces;
-  std::vector<CNetworkInterface*>& ifaces = g_application.getNetwork().GetInterfaceList();
-  std::vector<CNetworkInterface*>::const_iterator iter = ifaces.begin();
-  while (iter != ifaces.end())
-  {
-    CNetworkInterface* iface = *iter;
-    vecInterfaces.push_back(iface->GetName());
-    ++iter;
-  }
-  sort(vecInterfaces.begin(), vecInterfaces.end(), sortstringbyname());
-
-  int iInterface = 0;
-  for (unsigned int i = 0; i < vecInterfaces.size(); ++i)
-  {
-    pControl->AddLabel(vecInterfaces[i], iInterface++);
-  }
-}
-
 void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough)
 {
 #ifdef __APPLE__
@@ -2874,64 +2721,6 @@
 #endif
 }
 
-void CGUIWindowSettingsCategory::NetworkInterfaceChanged(void)
-{
-  return;
-
-   NetworkAssignment iAssignment;
-   CStdString sIPAddress;
-   CStdString sNetworkMask;
-   CStdString sDefaultGateway;
-   CStdString sWirelessNetwork;
-   CStdString sWirelessKey;
-   EncMode iWirelessEnc;
-   bool bIsWireless;
-   CStdString ifaceName;
-
-   // Get network information
-   CGUISpinControlEx *ifaceControl = (CGUISpinControlEx *)GetControl(GetSetting("network.interface")->GetID());
-   ifaceName = ifaceControl->GetLabel();
-   CNetworkInterface* iface = g_application.getNetwork().GetInterfaceByName(ifaceName);
-   iface->GetSettings(iAssignment, sIPAddress, sNetworkMask, sDefaultGateway, sWirelessNetwork, sWirelessKey, iWirelessEnc);
-   bIsWireless = iface->IsWireless();
-
-   CStdString dns;
-   std::vector<CStdString> dnss = g_application.getNetwork().GetNameServers();
-   if (dnss.size() >= 1)
-      dns = dnss[0];
-
-   // Update controls with information
-   CGUISpinControlEx* pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.assignment")->GetID());
-   if (pControl1) pControl1->SetValue(iAssignment);
-   GetSetting("network.dns")->GetSetting()->FromString(dns);
-   if (iAssignment == NETWORK_STATIC || iAssignment == NETWORK_DISABLED)
-   {
-     GetSetting("network.ipaddress")->GetSetting()->FromString(sIPAddress);
-     GetSetting("network.subnet")->GetSetting()->FromString(sNetworkMask);
-     GetSetting("network.gateway")->GetSetting()->FromString(sDefaultGateway);
-   }
-   else
-   {
-     GetSetting("network.ipaddress")->GetSetting()->FromString(iface->GetCurrentIPAddress());
-     GetSetting("network.subnet")->GetSetting()->FromString(iface->GetCurrentNetmask());
-     GetSetting("network.gateway")->GetSetting()->FromString(iface->GetCurrentDefaultGateway());
-   }
-
-   pControl1 = (CGUISpinControlEx *)GetControl(GetSetting("network.enc")->GetID());
-   if (pControl1) pControl1->SetValue(iWirelessEnc);
-
-   if (bIsWireless)
-   {
-      GetSetting("network.essid")->GetSetting()->FromString(sWirelessNetwork);
-      GetSetting("network.key")->GetSetting()->FromString(sWirelessKey);
-   }
-   else
-   {
-      GetSetting("network.essid")->GetSetting()->FromString("");
-      GetSetting("network.key")->GetSetting()->FromString("");
-   }
-}
-
 void CGUIWindowSettingsCategory::ValidatePortNumber(CBaseSettingControl* pSettingControl, const CStdString& userPort, const CStdString& privPort, bool listening/*=true*/)
 {
   CSettingString *pSetting = (CSettingString *)pSettingControl->GetSetting();
diff -Naur xbmc-dharma-35100/xbmc/GUIWindowSettingsCategory.h xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsCategory.h
--- xbmc-dharma-35100/xbmc/GUIWindowSettingsCategory.h	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsCategory.h	2010-11-01 21:17:04.426894405 +0100
@@ -60,9 +60,6 @@
   void FillInSkinThemes(CSetting *pSetting);
   void FillInSkinColors(CSetting *pSetting);
 
-  void FillInNetworkInterfaces(CSetting *pSetting);
-  void NetworkInterfaceChanged(void);
-
   void FillInAudioDevices(CSetting* pSetting, bool Passthrough = false);
 
   virtual void SetupControls();
diff -Naur xbmc-dharma-35100/xbmc/GUIWindowSettingsProfile.cpp xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsProfile.cpp
--- xbmc-dharma-35100/xbmc/GUIWindowSettingsProfile.cpp	2010-10-30 05:36:41.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/GUIWindowSettingsProfile.cpp	2010-11-01 21:19:14.043413198 +0100
@@ -25,7 +25,6 @@
 #include "Application.h"
 #include "GUIDialogContextMenu.h"
 #include "GUIDialogProfileSettings.h"
-#include "utils/Network.h"
 #include "utils/Weather.h"
 #include "GUIPassword.h"
 #include "GUIWindowLoginScreen.h"
@@ -90,7 +89,7 @@
     g_application.StopPlaying();
     CGUIMessage msg2(GUI_MSG_ITEM_SELECTED, g_windowManager.GetActiveWindow(), iCtrlID);
     g_windowManager.SendMessage(msg2);
-    g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_DOWN,1);
+    g_application.getNetworkManager().StopServices();
     g_settings.LoadMasterForLogin();
     CGUIWindowLoginScreen::LoadProfile(iItem);
     return;
diff -Naur xbmc-dharma-35100/xbmc/IConnection.h xbmc-dharma-35100.patch/xbmc/IConnection.h
--- xbmc-dharma-35100/xbmc/IConnection.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/IConnection.h	2010-11-01 21:17:04.428894430 +0100
@@ -0,0 +1,183 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+#include <string>
+#include <vector>
+#include "IPassphraseStorage.h"
+#include <boost/shared_ptr.hpp>
+
+enum ConnectionType
+{
+  NETWORK_CONNECTION_TYPE_UNKNOWN = 0,
+  NETWORK_CONNECTION_TYPE_WIRED,
+  NETWORK_CONNECTION_TYPE_WIFI
+};
+
+enum ConnectionState
+{
+  NETWORK_CONNECTION_STATE_UNKNOWN = 0,
+  NETWORK_CONNECTION_STATE_FAILURE,
+  NETWORK_CONNECTION_STATE_DISCONNECTED,
+  NETWORK_CONNECTION_STATE_CONNECTING,
+  NETWORK_CONNECTION_STATE_CONNECTED
+};
+
+enum EncryptionType
+{
+  NETWORK_CONNECTION_ENCRYPTION_UNKNOWN = 0, // This should be used to flag accesspoints which have some encryption which we cannot connect to.
+  NETWORK_CONNECTION_ENCRYPTION_NONE,
+  NETWORK_CONNECTION_ENCRYPTION_WEP,
+  NETWORK_CONNECTION_ENCRYPTION_WPA,
+  NETWORK_CONNECTION_ENCRYPTION_WPA2,
+  NETWORK_CONNECTION_ENCRYPTION_IEEE8021x
+};
+
+enum IPConfigMethod
+{
+  IP_CONFIG_STATIC,
+  IP_CONFIG_DHCP
+};
+
+class CIPConfig
+{
+public:
+  CIPConfig()
+  {
+    reset();
+  }
+
+  CIPConfig(IPConfigMethod method, const std::string &IP, const std::string &netmask)
+  {
+    m_method = method;
+    m_IP = IP;
+    m_netmask = netmask;
+  }
+
+  void reset()
+  {
+    m_method = IP_CONFIG_DHCP;
+    m_IP = "";
+    m_netmask = "";
+  }
+
+  IPConfigMethod m_method;
+  std::string m_IP;
+  std::string m_netmask;
+};
+
+class IConnection
+{
+public:
+  virtual ~IConnection() { }
+
+  /*!
+   \brief Connect to connection
+
+   \param storage a passphrase provider
+   \param ipconfig a configuration for how to acquire IP
+   \returns true if connected, false if not.
+   \sa IPassphraseStorage CIPConfig
+   */
+  virtual bool Connect(IPassphraseStorage *storage, const CIPConfig &ipconfig) = 0;
+
+  /*!
+   \brief Get the state of the connection
+
+   \return The state the connection is currently in.
+   \sa ConnectionState
+   */
+  virtual ConnectionState GetConnectionState() const = 0;
+
+  /*!
+   \brief Get the name of the connection
+
+   \return The name of the connection
+   \sa IConnection
+   */
+  virtual std::string GetName() const = 0;
+
+  /*!
+   \brief Get the IP of the connection
+
+   \return The IP of the connection
+   \sa IConnection
+   */
+  virtual std::string GetIP() const = 0;
+
+  /*!
+   \brief Get the netmask of the connection
+
+   \return The netmask of the connection
+   \sa IConnection
+   */
+  virtual std::string GetNetmask() const = 0;
+
+  /*!
+   \brief Get the mac address of the connection
+
+   \return The mac address of the connection
+   \sa IConnection
+   */
+  virtual std::string GetMacAddress() const = 0;
+
+  /*!
+   \brief Get the gateway address of the connection
+
+   \return The gateway address of the connection
+   \sa IConnection
+   */
+  virtual std::string GetGateway() const = 0;
+
+  /*!
+   \brief The signal strength of the connection
+
+   \return The signal strength of the connection
+   \sa IConnection
+   */
+  virtual unsigned int GetStrength() const = 0;
+
+  /*!
+   \brief Get the encryption used by the connection
+
+   \return The encryption used by the connection
+   \sa EncryptionType
+   */
+  virtual EncryptionType GetEncryption() const = 0;
+
+  /*!
+   \brief Get the speed of the connection
+
+   \return The speed of the connection
+   \sa IConnection
+   */
+  virtual unsigned int GetConnectionSpeed() const = 0;
+
+  /*!
+   \brief Get the connection type
+
+   \return The connection type
+   \sa ConnectionType
+   */
+  virtual ConnectionType GetConnectionType() const = 0;
+};
+
+typedef boost::shared_ptr<IConnection> CConnectionPtr;
+typedef std::vector<CConnectionPtr> ConnectionList;
diff -Naur xbmc-dharma-35100/xbmc/INetworkManager.h xbmc-dharma-35100.patch/xbmc/INetworkManager.h
--- xbmc-dharma-35100/xbmc/INetworkManager.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/INetworkManager.h	2010-11-01 21:17:04.428894430 +0100
@@ -0,0 +1,66 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "IConnection.h"
+
+/*!
+ \ingroup network
+ \brief Callback interface for network events.
+
+ Used by subsystems of the network manager to receive events about the subsystem.
+ It will be called relatively often from application thread to allow thread safe updates
+ of the network states.
+
+ \sa INetworkManager
+ */
+class INetworkEventsCallback
+{
+public:
+  virtual ~INetworkEventsCallback() { }
+
+  virtual void OnConnectionStateChange(ConnectionState state) = 0;
+  virtual void OnConnectionChange(CConnectionPtr connection) = 0;
+  virtual void OnConnectionListChange(ConnectionList list) = 0;
+};
+
+
+/*!
+ \ingroup network
+ \brief Interface for the network subsystems context
+
+ Used by subsystems of the network manager to receive events about the subsystem.
+ It will be called relatively often from application thread to allow thread safe updates
+ of the network states.
+
+ \sa INetworkManager
+ */
+class INetworkManager
+{
+public:
+  virtual ~INetworkManager() { }
+
+  virtual bool CanManageConnections() = 0;
+
+  virtual ConnectionList GetConnections() = 0;
+
+  virtual bool PumpNetworkEvents(INetworkEventsCallback *callback) = 0;
+};
diff -Naur xbmc-dharma-35100/xbmc/IPassphraseStorage.h xbmc-dharma-35100.patch/xbmc/IPassphraseStorage.h
--- xbmc-dharma-35100/xbmc/IPassphraseStorage.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/IPassphraseStorage.h	2010-11-01 21:17:04.429894443 +0100
@@ -0,0 +1,63 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+class IPassphraseStorage
+{
+public:
+  virtual ~IPassphraseStorage() { }
+
+  /*!
+   \brief Invalidate passphrase
+   
+    While a connection is connecting it may invalidate any stored passphrase. This is used
+    if the subsystem is not able to store passwords but the connection may have changed passphrase
+
+   \param uuid the unique id of the connection associated with the passphrase
+   \sa IConnection
+   */
+  virtual void InvalidatePassphrase(const std::string &uuid) = 0;
+
+  /*!
+   \brief Get passphrase
+   
+    While a connection is connecting it may need to acquire a passphrase. This is used
+    if the subsystem has no stored passphrase.
+
+   \param uuid the unique id of the connection.
+   \param passphrase a string which the passphrase storage will fill in the passphrase.
+   \return true if the passphrase was filled and false if it was some form of failure acquiring it.
+   \sa IConnection
+   */
+  virtual bool GetPassphrase(const std::string &uuid, std::string &passphrase) = 0;
+
+  /*!
+   \brief Store passphrase
+   
+    While a connection is connecting it may need to store a passphrase. This is used
+    if the subsystem is not capable of storing the passphrase itself.
+
+   \param uuid the unique id of the connection.
+   \param passphrase is the passphrase to be stored
+   \sa IConnection
+   */
+  virtual void StorePassphrase(const std::string &uuid, const std::string &passphrase) = 0;
+};
diff -Naur xbmc-dharma-35100/xbmc/lib/libhttpapi/XBMChttp.cpp xbmc-dharma-35100.patch/xbmc/lib/libhttpapi/XBMChttp.cpp
--- xbmc-dharma-35100/xbmc/lib/libhttpapi/XBMChttp.cpp	2010-10-30 05:36:55.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/lib/libhttpapi/XBMChttp.cpp	2010-11-01 21:17:04.490895157 +0100
@@ -2799,11 +2799,10 @@
     if (!pUdpBroadcast)
       pUdpBroadcast = new CUdpBroadcast();
     CStdString LocalAddress="";
-	if (g_application.getNetwork().GetFirstConnectedInterface())
-      LocalAddress = g_application.getNetwork().GetFirstConnectedInterface()->GetCurrentIPAddress();
+    LocalAddress = g_application.getNetworkManager().GetDefaultConnectionIP();
     CStdString msg;
     if ((g_settings.m_HttpApiBroadcastLevel & 128)==128)
-		message += ";"+LocalAddress;
+		  message += ";"+LocalAddress;
 	if ((g_settings.m_HttpApiBroadcastLevel & 256)==256)
 		message += ";"+LocalAddress+" "+g_guiSettings.GetString("services.webserverport");
     msg.Format(openBroadcast+message+";%i"+closeBroadcast, level);
diff -Naur xbmc-dharma-35100/xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp xbmc-dharma-35100.patch/xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp
--- xbmc-dharma-35100/xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp	2010-10-30 05:37:17.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp	2010-11-01 21:17:04.488895133 +0100
@@ -454,13 +454,7 @@
 
   PyObject* XBMC_GetIPAddress(PyObject *self, PyObject *args)
   {
-    char cTitleIP[32];
-    sprintf(cTitleIP, "127.0.0.1");
-    CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
-    if (iface)
-      return PyString_FromString(iface->GetCurrentIPAddress().c_str());
-
-    return PyString_FromString(cTitleIP);
+    return PyString_FromString(g_application.getNetworkManager().GetDefaultConnectionIP().c_str());
   }
 
   // getDVDState() method
diff -Naur xbmc-dharma-35100/xbmc/linux/Makefile.in xbmc-dharma-35100.patch/xbmc/linux/Makefile.in
--- xbmc-dharma-35100/xbmc/linux/Makefile.in	2010-11-01 21:16:42.986643160 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/Makefile.in	2010-11-01 21:17:04.491895170 +0100
@@ -7,7 +7,7 @@
 
 CXXFLAGS+=-fPIC #-DHAS_SDL
 
-SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp NetworkLinux.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp ConsoleUPowerSyscall.cpp DBusUtil.cpp DBusReply.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp
+SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp ConsoleUPowerSyscall.cpp DBusUtil.cpp DBusReply.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp
 
 LIB=linux.a
 
diff -Naur xbmc-dharma-35100/xbmc/linux/NetworkLinux.cpp xbmc-dharma-35100.patch/xbmc/linux/NetworkLinux.cpp
--- xbmc-dharma-35100/xbmc/linux/NetworkLinux.cpp	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/NetworkLinux.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,765 +0,0 @@
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include <sys/ioctl.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#ifndef __APPLE__
-#include <linux/if.h>
-#include <linux/wireless.h>
-#include <linux/sockios.h>
-#endif
-#include <errno.h>
-#include <resolv.h>
-#ifdef __APPLE__
-#include <sys/sockio.h>
-#include <net/if.h>
-#include <ifaddrs.h>
-#endif
-#include <net/if_arp.h>
-#include "PlatformDefs.h"
-#include "NetworkLinux.h"
-#include "Util.h"
-#include "log.h"
-
-using namespace std;
-
-CNetworkInterfaceLinux::CNetworkInterfaceLinux(CNetworkLinux* network, CStdString interfaceName)
-
-{
-   m_network = network;
-   m_interfaceName = interfaceName;
-}
-
-CNetworkInterfaceLinux::~CNetworkInterfaceLinux(void)
-{
-}
-
-CStdString& CNetworkInterfaceLinux::GetName(void)
-{
-   return m_interfaceName;
-}
-
-bool CNetworkInterfaceLinux::IsWireless()
-{
-#ifdef __APPLE__
-  return false;
-#else
-  struct iwreq wrq;
-   strcpy(wrq.ifr_name, m_interfaceName.c_str());
-   if (ioctl(m_network->GetSocket(), SIOCGIWNAME, &wrq) < 0)
-      return false;
-#endif
-
-   return true;
-}
-
-bool CNetworkInterfaceLinux::IsEnabled()
-{
-   struct ifreq ifr;
-   strcpy(ifr.ifr_name, m_interfaceName.c_str());
-   if (ioctl(m_network->GetSocket(), SIOCGIFFLAGS, &ifr) < 0)
-      return false;
-
-   return ((ifr.ifr_flags & IFF_UP) == IFF_UP);
-}
-
-bool CNetworkInterfaceLinux::IsConnected()
-{
-   struct ifreq ifr;
-   int zero = 0;
-   memset(&ifr,0,sizeof(struct ifreq));
-   strcpy(ifr.ifr_name, m_interfaceName.c_str());
-   if (ioctl(m_network->GetSocket(), SIOCGIFFLAGS, &ifr) < 0)
-      return false;
-
-   // ignore loopback
-   int iRunning = ( (ifr.ifr_flags & IFF_RUNNING) && (!(ifr.ifr_flags & IFF_LOOPBACK)));
-
-   if (ioctl(m_network->GetSocket(), SIOCGIFADDR, &ifr) < 0)
-      return false;
-
-   // return only interfaces which has ip address
-   return iRunning && (0 != memcmp(ifr.ifr_addr.sa_data+sizeof(short), &zero, sizeof(int)));
-}
-
-CStdString CNetworkInterfaceLinux::GetMacAddress()
-{
-   CStdString result = "";
-
-#ifdef __APPLE__
-   result.Format("00:00:00:00:00:00");
-#else
-   struct ifreq ifr;
-   strcpy(ifr.ifr_name, m_interfaceName.c_str());
-   if (ioctl(m_network->GetSocket(), SIOCGIFHWADDR, &ifr) >= 0)
-   {
-      result.Format("%hhX:%hhX:%hhX:%hhX:%hhX:%hhX",
-         ifr.ifr_hwaddr.sa_data[0],
-         ifr.ifr_hwaddr.sa_data[1],
-         ifr.ifr_hwaddr.sa_data[2],
-         ifr.ifr_hwaddr.sa_data[3],
-         ifr.ifr_hwaddr.sa_data[4],
-         ifr.ifr_hwaddr.sa_data[5]);
-   }
-#endif
-
-   return result;
-}
-
-CStdString CNetworkInterfaceLinux::GetCurrentIPAddress(void)
-{
-   CStdString result = "";
-
-   struct ifreq ifr;
-   strcpy(ifr.ifr_name, m_interfaceName.c_str());
-   ifr.ifr_addr.sa_family = AF_INET;
-   if (ioctl(m_network->GetSocket(), SIOCGIFADDR, &ifr) >= 0)
-   {
-      result = inet_ntoa((*((struct sockaddr_in *)&ifr.ifr_addr)).sin_addr);
-   }
-
-   return result;
-}
-
-CStdString CNetworkInterfaceLinux::GetCurrentNetmask(void)
-{
-   CStdString result = "";
-
-   struct ifreq ifr;
-   strcpy(ifr.ifr_name, m_interfaceName.c_str());
-   ifr.ifr_addr.sa_family = AF_INET;
-   if (ioctl(m_network->GetSocket(), SIOCGIFNETMASK, &ifr) >= 0)
-   {
-      result = inet_ntoa((*((struct sockaddr_in*)&ifr.ifr_addr)).sin_addr);
-   }
-
-   return result;
-}
-
-CStdString CNetworkInterfaceLinux::GetCurrentWirelessEssId(void)
-{
-   CStdString result = "";
-
-#ifndef __APPLE__
-   char essid[IW_ESSID_MAX_SIZE + 1];
-   memset(&essid, 0, sizeof(essid));
-
-   struct iwreq wrq;
-   strcpy(wrq.ifr_name,  m_interfaceName.c_str());
-   wrq.u.essid.pointer = (caddr_t) essid;
-   wrq.u.essid.length = IW_ESSID_MAX_SIZE;
-   wrq.u.essid.flags = 0;
-   if (ioctl(m_network->GetSocket(), SIOCGIWESSID, &wrq) >= 0)
-   {
-      result = essid;
-   }
-#endif
-
-   return result;
-}
-
-CStdString CNetworkInterfaceLinux::GetCurrentDefaultGateway(void)
-{
-   CStdString result = "";
-
-#ifndef __APPLE__
-   FILE* fp = fopen("/proc/net/route", "r");
-   if (!fp)
-   {
-     // TBD: Error
-     return result;
-   }
-
-   char* line = NULL;
-   char iface[16];
-   char dst[128];
-   char gateway[128];
-   size_t linel = 0;
-   int n;
-   int linenum = 0;
-   while (getdelim(&line, &linel, '\n', fp) > 0)
-   {
-      // skip first two lines
-      if (linenum++ < 1)
-         continue;
-
-      // search where the word begins
-      n = sscanf(line,  "%16s %128s %128s",
-         iface, dst, gateway);
-
-      if (n < 3)
-         continue;
-
-      if (strcmp(iface, m_interfaceName.c_str()) == 0 &&
-          strcmp(dst, "00000000") == 0 &&
-          strcmp(gateway, "00000000") != 0)
-      {
-         unsigned char gatewayAddr[4];
-         int len = CNetwork::ParseHex(gateway, gatewayAddr);
-         if (len == 4)
-         {
-            struct in_addr in;
-            in.s_addr = (gatewayAddr[0] << 24) | (gatewayAddr[1] << 16) |
-                        (gatewayAddr[2] << 8) | (gatewayAddr[3]);
-            result = inet_ntoa(in);
-            break;
-         }
-      }
-   }
-   free(line);
-   fclose(fp);
-#endif
-
-   return result;
-}
-
-CNetworkLinux::CNetworkLinux(void)
-{
-   m_sock = socket(AF_INET, SOCK_DGRAM, 0);
-   queryInterfaceList();
-}
-
-CNetworkLinux::~CNetworkLinux(void)
-{
-  if (m_sock != -1)
-    close(CNetworkLinux::m_sock);
-
-  vector<CNetworkInterface*>::iterator it = m_interfaces.begin();
-  while(it != m_interfaces.end())
-  {
-    CNetworkInterface* nInt = *it;
-    delete nInt;
-    it = m_interfaces.erase(it);
-  }
-}
-
-std::vector<CNetworkInterface*>& CNetworkLinux::GetInterfaceList(void)
-{
-   return m_interfaces;
-}
-
-void CNetworkLinux::queryInterfaceList()
-{
-   m_interfaces.clear();
-
-#ifdef __APPLE__
-
-   // Query the list of interfaces.
-   struct ifaddrs *list;
-   if (getifaddrs(&list) < 0)
-     return;
-
-   struct ifaddrs *cur;
-   for(cur = list; cur != NULL; cur = cur->ifa_next)
-   {
-     if(cur->ifa_addr->sa_family != AF_INET)
-       continue;
-
-     // Add the interface.
-     m_interfaces.push_back(new CNetworkInterfaceLinux(this, cur->ifa_name));
-   }
-
-   freeifaddrs(list);
-
-#else
-   FILE* fp = fopen("/proc/net/dev", "r");
-   if (!fp)
-   {
-     // TBD: Error
-     return;
-   }
-
-   char* line = NULL;
-   size_t linel = 0;
-   int n;
-   char* p;
-   int linenum = 0;
-   while (getdelim(&line, &linel, '\n', fp) > 0)
-   {
-      // skip first two lines
-      if (linenum++ < 2)
-         continue;
-
-    // search where the word begins
-      p = line;
-      while (isspace(*p))
-      ++p;
-
-      // read word until :
-      n = strcspn(p, ": \t");
-      p[n] = 0;
-
-      // make sure the device has ethernet encapsulation
-      struct ifreq ifr;
-      strcpy(ifr.ifr_name, p);
-      if (ioctl(GetSocket(), SIOCGIFHWADDR, &ifr) >= 0 && ifr.ifr_hwaddr.sa_family == ARPHRD_ETHER)
-      {
-         // save the result
-         CStdString interfaceName = p;
-         m_interfaces.push_back(new CNetworkInterfaceLinux(this, interfaceName));
-      }
-   }
-   free(line);
-   fclose(fp);
-#endif
-}
-
-std::vector<CStdString> CNetworkLinux::GetNameServers(void)
-{
-   std::vector<CStdString> result;
-#ifndef __APPLE__
-   res_init();
-
-   for (int i = 0; i < _res.nscount; i ++)
-   {
-      CStdString ns = inet_ntoa(((struct sockaddr_in *)&_res.nsaddr_list[0])->sin_addr);
-      result.push_back(ns);
-   }
-#endif
-   return result;
-}
-
-void CNetworkLinux::SetNameServers(std::vector<CStdString> nameServers)
-{
-   FILE* fp = fopen("/etc/resolv.conf", "w");
-   if (fp != NULL)
-   {
-      for (unsigned int i = 0; i < nameServers.size(); i++)
-      {
-         fprintf(fp, "nameserver %s\n", nameServers[i].c_str());
-      }
-      fclose(fp);
-   }
-   else
-   {
-      // TODO:
-   }
-}
-
-std::vector<NetworkAccessPoint> CNetworkInterfaceLinux::GetAccessPoints(void)
-{
-   std::vector<NetworkAccessPoint> result;
-
-   if (!IsWireless())
-      return result;
-
-#ifndef __APPLE__
-   // Query the wireless extentsions version number. It will help us when we
-   // parse the resulting events
-   struct iwreq iwr;
-   char rangebuffer[sizeof(iw_range) * 2];    /* Large enough */
-   struct iw_range*  range = (struct iw_range*) rangebuffer;
-
-   memset(rangebuffer, 0, sizeof(rangebuffer));
-   iwr.u.data.pointer = (caddr_t) rangebuffer;
-   iwr.u.data.length = sizeof(rangebuffer);
-   iwr.u.data.flags = 0;
-   strncpy(iwr.ifr_name, GetName().c_str(), IFNAMSIZ);
-   if (ioctl(m_network->GetSocket(), SIOCGIWRANGE, &iwr) < 0)
-   {
-      CLog::Log(LOGWARNING, "%-8.16s  Driver has no Wireless Extension version information.",
-         GetName().c_str());
-      return result;
-   }
-
-   // Scan for wireless access points
-   memset(&iwr, 0, sizeof(iwr));
-   strncpy(iwr.ifr_name, GetName().c_str(), IFNAMSIZ);
-   if (ioctl(m_network->GetSocket(), SIOCSIWSCAN, &iwr) < 0)
-   {
-      CLog::Log(LOGWARNING, "Cannot initiate wireless scan: ioctl[SIOCSIWSCAN]: %s", strerror(errno));
-      return result;
-   }
-
-   // Get the results of the scanning. Three scenarios:
-   //    1. There's not enough room in the result buffer (E2BIG)
-   //    2. The scanning is not complete (EAGAIN) and we need to try again. We cap this with 15 seconds.
-   //    3. Were'e good.
-   int duration = 0; // ms
-   unsigned char* res_buf = NULL;
-   int res_buf_len = IW_SCAN_MAX_DATA;
-   while (duration < 15000)
-   {
-      if (!res_buf)
-         res_buf = (unsigned char*) malloc(res_buf_len);
-
-      if (res_buf == NULL)
-      {
-         CLog::Log(LOGWARNING, "Cannot alloc memory for wireless scanning");
-         return result;
-      }
-
-      strncpy(iwr.ifr_name, GetName().c_str(), IFNAMSIZ);
-      iwr.u.data.pointer = res_buf;
-      iwr.u.data.length = res_buf_len;
-      iwr.u.data.flags = 0;
-      int x = ioctl(m_network->GetSocket(), SIOCGIWSCAN, &iwr);
-      if (x == 0)
-         break;
-
-      if (errno == E2BIG && res_buf_len < 100000)
-      {
-         free(res_buf);
-         res_buf = NULL;
-         res_buf_len *= 2;
-         CLog::Log(LOGDEBUG, "Scan results did not fit - trying larger buffer (%lu bytes)",
-                        (unsigned long) res_buf_len);
-      }
-      else if (errno == EAGAIN)
-      {
-         usleep(250000); // sleep for 250ms
-         duration += 250;
-      }
-      else
-      {
-         CLog::Log(LOGWARNING, "Cannot get wireless scan results: ioctl[SIOCGIWSCAN]: %s", strerror(errno));
-         free(res_buf);
-         return result;
-      }
-   }
-
-   size_t len = iwr.u.data.length;
-   char* pos = (char *) res_buf;
-   char* end = (char *) res_buf + len;
-   char* custom;
-   struct iw_event iwe_buf, *iwe = &iwe_buf;
-
-   CStdString essId;
-   int quality = 0;
-   EncMode encryption = ENC_NONE;
-   bool first = true;
-
-   while (pos + IW_EV_LCP_LEN <= end)
-   {
-      /* Event data may be unaligned, so make a local, aligned copy
-       * before processing. */
-      memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
-      if (iwe->len <= IW_EV_LCP_LEN)
-         break;
-
-      custom = pos + IW_EV_POINT_LEN;
-      if (range->we_version_compiled > 18 &&
-          (iwe->cmd == SIOCGIWESSID ||
-           iwe->cmd == SIOCGIWENCODE ||
-           iwe->cmd == IWEVGENIE ||
-           iwe->cmd == IWEVCUSTOM))
-      {
-         /* Wireless extentsions v19 removed the pointer from struct iw_point */
-         char *dpos = (char *) &iwe_buf.u.data.length;
-         int dlen = dpos - (char *) &iwe_buf;
-         memcpy(dpos, pos + IW_EV_LCP_LEN, sizeof(struct iw_event) - dlen);
-      }
-      else
-      {
-         memcpy(&iwe_buf, pos, sizeof(struct iw_event));
-         custom += IW_EV_POINT_OFF;
-      }
-
-      switch (iwe->cmd)
-      {
-         case SIOCGIWAP:
-            if (first)
-               first = false;
-            else
-               result.push_back(NetworkAccessPoint(essId, quality, encryption));
-               encryption = ENC_NONE;
-            break;
-
-         case SIOCGIWESSID:
-         {
-            char essid[IW_ESSID_MAX_SIZE+1];
-            memset(essid, '\0', sizeof(essid));
-            if ((custom) && (iwe->u.essid.length))
-            {
-               memcpy(essid, custom, iwe->u.essid.length);
-               essId = essid;
-            }
-            break;
-         }
-
-         case IWEVQUAL:
-             quality = iwe->u.qual.qual;
-             break;
-
-         case SIOCGIWENCODE:
-             if (!(iwe->u.data.flags & IW_ENCODE_DISABLED) && encryption == ENC_NONE)
-                encryption = ENC_WEP;
-             break;
-
-         case IWEVGENIE:
-         {
-            int offset = 0;
-            while (offset <= iwe_buf.u.data.length)
-            {
-               switch ((unsigned char)custom[offset])
-               {
-                  case 0xdd: /* WPA1 */
-                     if (encryption != ENC_WPA2)
-                        encryption = ENC_WPA;
-                     break;
-                  case 0x30: /* WPA2 */
-                     encryption = ENC_WPA2;
-               }
-
-               offset += custom[offset+1] + 2;
-            }
-         }
-      }
-
-      pos += iwe->len;
-   }
-
-   if (!first)
-      result.push_back(NetworkAccessPoint(essId, quality, encryption));
-
-   free(res_buf);
-   res_buf = NULL;
-#endif
-
-   return result;
-}
-
-void CNetworkInterfaceLinux::GetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode)
-{
-   ipAddress = "0.0.0.0";
-   networkMask = "0.0.0.0";
-   defaultGateway = "0.0.0.0";
-   essId = "";
-   key = "";
-   encryptionMode = ENC_NONE;
-   assignment = NETWORK_DISABLED;
-
-#ifndef __APPLE__
-   FILE* fp = fopen("/etc/network/interfaces", "r");
-   if (!fp)
-   {
-      // TODO
-      return;
-   }
-
-   char* line = NULL;
-   size_t linel = 0;
-   CStdString s;
-   bool foundInterface = false;
-
-   while (getdelim(&line, &linel, '\n', fp) > 0)
-   {
-      vector<CStdString> tokens;
-
-      s = line;
-      s.TrimLeft(" \t").TrimRight(" \n");
-
-      // skip comments
-      if (s.length() == 0 || s.GetAt(0) == '#')
-         continue;
-
-      // look for "iface <interface name> inet"
-      CUtil::Tokenize(s, tokens, " ");
-      if (!foundInterface &&
-          tokens.size() >=3 &&
-          tokens[0].Equals("iface") &&
-          tokens[1].Equals(GetName()) &&
-          tokens[2].Equals("inet"))
-      {
-         if (tokens[3].Equals("dhcp"))
-         {
-            assignment = NETWORK_DHCP;
-            foundInterface = true;
-         }
-         if (tokens[3].Equals("static"))
-         {
-            assignment = NETWORK_STATIC;
-            foundInterface = true;
-         }
-      }
-
-      if (foundInterface && tokens.size() == 2)
-      {
-         if (tokens[0].Equals("address")) ipAddress = tokens[1];
-         else if (tokens[0].Equals("netmask")) networkMask = tokens[1];
-         else if (tokens[0].Equals("gateway")) defaultGateway = tokens[1];
-         else if (tokens[0].Equals("wireless-essid")) essId = tokens[1];
-         else if (tokens[0].Equals("wireless-key"))
-         {
-            key = tokens[1];
-            if (key.length() > 2 && key[0] == 's' && key[1] == ':')
-               key.erase(0, 2);
-            encryptionMode = ENC_WEP;
-         }
-         else if (tokens[0].Equals("wpa-ssid")) essId = tokens[1];
-         else if (tokens[0].Equals("wpa-proto") && tokens[1].Equals("WPA")) encryptionMode = ENC_WPA;
-         else if (tokens[0].Equals("wpa-proto") && tokens[1].Equals("WPA2")) encryptionMode = ENC_WPA2;
-         else if (tokens[0].Equals("wpa-psk")) key = tokens[1];
-         else if (tokens[0].Equals("auto") || tokens[0].Equals("iface") || tokens[0].Equals("mapping")) break;
-      }
-   }
-   free(line);
-
-   // Fallback in case wpa-proto is not set
-   if (key != "" && encryptionMode == ENC_NONE)
-      encryptionMode = ENC_WPA;
-
-   fclose(fp);
-#endif
-}
-
-void CNetworkInterfaceLinux::SetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode)
-{
-#ifndef __APPLE__
-   FILE* fr = fopen("/etc/network/interfaces", "r");
-   if (!fr)
-   {
-      // TODO
-      return;
-   }
-
-   FILE* fw = fopen("/tmp/interfaces.temp", "w");
-   if (!fw)
-   {
-      // TODO
-      fclose(fr);
-      return;
-   }
-
-   char* line = NULL;
-   size_t linel = 0;
-   CStdString s;
-   bool foundInterface = false;
-   bool dataWritten = false;
-
-   while (getdelim(&line, &linel, '\n', fr) > 0)
-   {
-      vector<CStdString> tokens;
-
-      s = line;
-      s.TrimLeft(" \t").TrimRight(" \n");
-
-      // skip comments
-      if (!foundInterface && (s.length() == 0 || s.GetAt(0) == '#'))
-      {
-        fprintf(fw, "%s", line);
-        continue;
-      }
-
-      // look for "iface <interface name> inet"
-      CUtil::Tokenize(s, tokens, " ");
-      if (tokens.size() == 2 &&
-          tokens[0].Equals("auto") &&
-          tokens[1].Equals(GetName()))
-      {
-         continue;
-      }
-      else if (!foundInterface &&
-          tokens.size() == 4 &&
-          tokens[0].Equals("iface") &&
-          tokens[1].Equals(GetName()) &&
-          tokens[2].Equals("inet"))
-      {
-         foundInterface = true;
-         WriteSettings(fw, assignment, ipAddress, networkMask, defaultGateway, essId, key, encryptionMode);
-         dataWritten = true;
-      }
-      else if (foundInterface &&
-               tokens.size() == 4 &&
-               tokens[0].Equals("iface"))
-      {
-        foundInterface = false;
-        fprintf(fw, "%s", line);
-      }
-      else if (!foundInterface)
-      {
-        fprintf(fw, "%s", line);
-      }
-   }
-   free(line);
-
-   if (!dataWritten && assignment != NETWORK_DISABLED)
-   {
-      fprintf(fw, "\n");
-      WriteSettings(fw, assignment, ipAddress, networkMask, defaultGateway, essId, key, encryptionMode);
-   }
-
-   fclose(fr);
-   fclose(fw);
-
-   // Rename the file
-   if (rename("/tmp/interfaces.temp", "/etc/network/interfaces") < 0)
-   {
-      // TODO
-      return;
-   }
-
-   std::string cmd = "/sbin/ifdown " + GetName();
-   if (system(cmd.c_str()) != 0)
-     CLog::Log(LOGERROR, "Unable to stop interface %s", GetName().c_str());
-   else
-     CLog::Log(LOGINFO, "Stopped interface %s", GetName().c_str());
-
-   if (assignment != NETWORK_DISABLED)
-   {
-      cmd = "/sbin/ifup " + GetName();
-      if (system(cmd.c_str()) != 0)
-        CLog::Log(LOGERROR, "Unable to start interface %s", GetName().c_str());
-      else
-        CLog::Log(LOGINFO, "Started interface %s", GetName().c_str());
-   }
-#endif
-}
-
-void CNetworkInterfaceLinux::WriteSettings(FILE* fw, NetworkAssignment assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode)
-{
-   if (assignment == NETWORK_DHCP)
-   {
-      fprintf(fw, "iface %s inet dhcp\n", GetName().c_str());
-   }
-   else if (assignment == NETWORK_STATIC)
-   {
-      fprintf(fw, "iface %s inet static\n", GetName().c_str());
-      fprintf(fw, "  address %s\n", ipAddress.c_str());
-      fprintf(fw, "  netmask %s\n", networkMask.c_str());
-      fprintf(fw, "  gateway %s\n", defaultGateway.c_str());
-   }
-
-   if (assignment != NETWORK_DISABLED && IsWireless())
-   {
-      if (encryptionMode == ENC_NONE)
-      {
-         fprintf(fw, "  wireless-essid %s\n", essId.c_str());
-      }
-      else if (encryptionMode == ENC_WEP)
-      {
-         fprintf(fw, "  wireless-essid %s\n", essId.c_str());
-         fprintf(fw, "  wireless-key s:%s\n", key.c_str());
-      }
-      else if (encryptionMode == ENC_WPA || encryptionMode == ENC_WPA2)
-      {
-         fprintf(fw, "  wpa-ssid %s\n", essId.c_str());
-         fprintf(fw, "  wpa-psk %s\n", key.c_str());
-         fprintf(fw, "  wpa-proto %s\n", encryptionMode == ENC_WPA ? "WPA" : "WPA2");
-      }
-   }
-
-   if (assignment != NETWORK_DISABLED)
-      fprintf(fw, "auto %s\n\n", GetName().c_str());
-}
-
diff -Naur xbmc-dharma-35100/xbmc/linux/NetworkLinux.h xbmc-dharma-35100.patch/xbmc/linux/NetworkLinux.h
--- xbmc-dharma-35100/xbmc/linux/NetworkLinux.h	2010-10-30 05:37:32.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/linux/NetworkLinux.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-#ifndef NETWORK_LINUX_H_
-#define NETWORK_LINUX_H_
-
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include <vector>
-#include "StdString.h"
-#include "utils/Network.h"
-
-class CNetworkLinux;
-
-class CNetworkInterfaceLinux : public CNetworkInterface
-{
-public:
-   CNetworkInterfaceLinux(CNetworkLinux* network, CStdString interfaceName);
-   ~CNetworkInterfaceLinux(void);
-
-   virtual CStdString& GetName(void);
-
-   virtual bool IsEnabled(void);
-   virtual bool IsConnected(void);
-   virtual bool IsWireless(void);
-
-   virtual CStdString GetMacAddress(void);
-
-   virtual CStdString GetCurrentIPAddress();
-   virtual CStdString GetCurrentNetmask();
-   virtual CStdString GetCurrentDefaultGateway(void);
-   virtual CStdString GetCurrentWirelessEssId(void);
-
-   virtual void GetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode);
-   virtual void SetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode);
-
-   // Returns the list of access points in the area
-   virtual std::vector<NetworkAccessPoint> GetAccessPoints(void);
-
-private:
-   void WriteSettings(FILE* fw, NetworkAssignment assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode);
-   CStdString     m_interfaceName;
-   CNetworkLinux* m_network;
-};
-
-class CNetworkLinux : public CNetwork
-{
-public:
-   CNetworkLinux(void);
-   virtual ~CNetworkLinux(void);
-
-   // Return the list of interfaces
-   virtual std::vector<CNetworkInterface*>& GetInterfaceList(void);
-
-   // Get/set the nameserver(s)
-   virtual std::vector<CStdString> GetNameServers(void);
-   virtual void SetNameServers(std::vector<CStdString> nameServers);
-
-   friend class CNetworkInterfaceLinux;
-
-private:
-   int GetSocket() { return m_sock; }
-   void queryInterfaceList();
-   std::vector<CNetworkInterface*> m_interfaces;
-   int m_sock;
-};
-
-#endif
diff -Naur xbmc-dharma-35100/xbmc/Makefile.in xbmc-dharma-35100.patch/xbmc/Makefile.in
--- xbmc-dharma-35100/xbmc/Makefile.in	2010-10-30 05:36:47.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/Makefile.in	2010-11-01 21:19:52.237860705 +0100
@@ -219,6 +219,8 @@
      TextureCache.cpp \
      TextureDatabase.cpp \
      AddonDatabase.cpp \
+     NetworkManager.cpp \
+     NetworkUtils.cpp
 
 LIB=xbmc.a
 
diff -Naur xbmc-dharma-35100/xbmc/MusicDatabase.cpp xbmc-dharma-35100.patch/xbmc/MusicDatabase.cpp
--- xbmc-dharma-35100/xbmc/MusicDatabase.cpp	2010-10-30 05:36:41.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/MusicDatabase.cpp	2010-11-01 21:17:04.469894910 +0100
@@ -2265,7 +2265,7 @@
     return false;
 
   // check network connectivity
-  if (!g_application.getNetwork().IsAvailable())
+  if (!g_application.getNetworkManager().IsAvailable())
     return false;
 
   // Get information for the inserted disc
diff -Naur xbmc-dharma-35100/xbmc/NetworkManager.cpp xbmc-dharma-35100.patch/xbmc/NetworkManager.cpp
--- xbmc-dharma-35100/xbmc/NetworkManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/NetworkManager.cpp	2010-11-01 21:17:04.469894910 +0100
@@ -0,0 +1,217 @@
+#include "NetworkManager.h"
+#include "log.h"
+#include "Application.h"
+#include "lib/libscrobbler/lastfmscrobbler.h"
+#include "lib/libscrobbler/librefmscrobbler.h"
+#include "RssReader.h"
+#include "ApplicationMessenger.h"
+
+using namespace std;
+
+CNetworkManager::CNetworkManager()
+{
+  m_instance = NULL;
+  m_state = NETWORK_CONNECTION_STATE_UNKNOWN;
+}
+
+CNetworkManager::~CNetworkManager()
+{
+  delete m_instance;
+}
+
+void CNetworkManager::Initialize()
+{
+  // Here should platform specific go
+
+  if (m_instance == NULL)
+    m_instance = new CNullNetworkManager();
+
+  m_defaultConnection = CConnectionPtr(new CNullConnection());
+  OnConnectionListChange(m_instance->GetConnections());
+}
+
+void CNetworkManager::PumpNetworkEvents()
+{
+  m_instance->PumpNetworkEvents(this);
+}
+
+string CNetworkManager::GetDefaultConnectionName()
+{
+  return m_defaultConnection->GetName();
+}
+
+string CNetworkManager::GetDefaultConnectionIP()
+{
+  return m_defaultConnection->GetIP();
+}
+
+std::string CNetworkManager::GetDefaultConnectionNetmask()
+{
+  return m_defaultConnection->GetNetmask();
+}
+
+std::string CNetworkManager::GetDefaultConnectionMacAddress()
+{
+  return m_defaultConnection->GetMacAddress();
+}
+
+std::string CNetworkManager::GetDefaultConnectionGateway()
+{
+  return m_defaultConnection->GetGateway();
+}
+
+ConnectionState CNetworkManager::GetDefaultConnectionState()
+{
+  return m_state;
+}
+
+bool CNetworkManager::IsConnected()
+{
+  return GetDefaultConnectionState() == NETWORK_CONNECTION_STATE_CONNECTED;
+}
+
+bool CNetworkManager::IsAvailable(bool wait)
+{
+  return true;
+}
+
+bool CNetworkManager::CanManageConnections()
+{
+  return m_instance->CanManageConnections();
+}
+
+ConnectionList CNetworkManager::GetConnections()
+{
+  return m_connections;
+}
+
+void CNetworkManager::OnConnectionStateChange(ConnectionState state)
+{
+  ConnectionState oldState = m_state;
+  m_state = state;
+
+  if (m_state != oldState)
+    CLog::Log(LOGDEBUG, "NetworkManager: State changed %s", ConnectionStateToString(m_state));
+
+  if (oldState != NETWORK_CONNECTION_STATE_CONNECTED && m_state == NETWORK_CONNECTION_STATE_CONNECTED)
+    StartServices();
+  else if (oldState == NETWORK_CONNECTION_STATE_CONNECTED && oldState != m_state)
+    StopServices();
+}
+
+void CNetworkManager::OnConnectionChange(CConnectionPtr connection)
+{
+  if (connection->GetConnectionState() == NETWORK_CONNECTION_STATE_CONNECTED)
+    m_defaultConnection = connection;
+
+  CAction action(300);
+  g_application.getApplicationMessenger().SendAction(action, WINDOW_DIALOG_ACCESS_POINTS);
+}
+
+void CNetworkManager::OnConnectionListChange(ConnectionList list)
+{
+  m_connections = list;
+
+  for (unsigned int i = 0; i < m_connections.size(); i++)
+  {
+    if (m_connections[i]->GetConnectionState() == NETWORK_CONNECTION_STATE_CONNECTED)
+    {
+      m_defaultConnection = m_connections[i];
+      OnConnectionStateChange(NETWORK_CONNECTION_STATE_CONNECTED);
+      break;
+    }
+  }
+
+  CAction action(300);
+  g_application.getApplicationMessenger().SendAction(action, WINDOW_DIALOG_ACCESS_POINTS);
+}
+
+void CNetworkManager::StartServices()
+{
+  CLog::Log(LOGDEBUG, "NetworkManager: Signaling network services to start");
+
+#ifdef HAS_TIME_SERVER
+  g_application.StartTimeServer();
+#endif
+#ifdef HAS_WEB_SERVER
+  g_application.StartWebServer();
+#endif
+#ifdef HAS_UPNP
+  g_application.StartUPnP();
+#endif
+#ifdef HAS_EVENT_SERVER
+  g_application.StartEventServer();
+#endif
+#ifdef HAS_DBUS_SERVER
+  g_application.StartDbusServer();
+#endif
+#ifdef HAS_JSONRPC
+  g_application.StartJSONRPCServer();
+#endif
+#ifdef HAS_ZEROCONF
+  g_application.StartZeroconf();
+#endif
+  CLastfmScrobbler::GetInstance()->Init();
+  CLibrefmScrobbler::GetInstance()->Init();
+  g_rssManager.Start();
+}
+
+void CNetworkManager::StopServices()
+{
+  CLog::Log(LOGDEBUG, "NetworkManager: Signaling network services to stop");
+  StopServices(false);
+  CLog::Log(LOGDEBUG, "NetworkManager: Waiting for network services to stop");
+  StopServices(true);
+}
+
+void CNetworkManager::StopServices(bool wait)
+{
+  if (wait)
+  {
+#ifdef HAS_TIME_SERVER
+    g_application.StopTimeServer();
+#endif
+#ifdef HAS_UPNP
+    g_application.StopUPnP(wait);
+#endif
+#ifdef HAS_ZEROCONF
+    g_application.StopZeroconf();
+#endif
+#ifdef HAS_WEB_SERVER
+    g_application.StopWebServer();
+#endif    
+    CLastfmScrobbler::GetInstance()->Term();
+    CLibrefmScrobbler::GetInstance()->Term();
+    // smb.Deinit(); if any file is open over samba this will break.
+
+    g_rssManager.Stop();
+  }
+
+#ifdef HAS_EVENT_SERVER
+  g_application.StopEventServer(wait, false);
+#endif
+#ifdef HAS_DBUS_SERVER
+  g_application.StopDbusServer(wait);
+#endif
+#ifdef HAS_JSONRPC
+    g_application.StopJSONRPCServer(wait);
+#endif
+}
+
+const char *CNetworkManager::ConnectionStateToString(ConnectionState state)
+{
+  switch (state)
+  {
+    case NETWORK_CONNECTION_STATE_FAILURE:
+      return "failure";
+    case NETWORK_CONNECTION_STATE_DISCONNECTED:
+      return "disconnect";
+    case NETWORK_CONNECTION_STATE_CONNECTING:
+      return "connecting";
+    case NETWORK_CONNECTION_STATE_CONNECTED:
+      return "connected";
+    case NETWORK_CONNECTION_STATE_UNKNOWN:
+    default:
+      return "unknown";
+  }
+}
diff -Naur xbmc-dharma-35100/xbmc/NetworkManager.h xbmc-dharma-35100.patch/xbmc/NetworkManager.h
--- xbmc-dharma-35100/xbmc/NetworkManager.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/NetworkManager.h	2010-11-01 21:17:04.475894979 +0100
@@ -0,0 +1,97 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "INetworkManager.h"
+
+class CNullConnection : public IConnection
+{
+public:
+  virtual ~CNullConnection() { }
+
+  virtual bool Connect(IPassphraseStorage *storage, const CIPConfig &ipconfig) { return false; }
+  virtual ConnectionState GetConnectionState() const  { return NETWORK_CONNECTION_STATE_CONNECTED; }
+
+  virtual std::string GetName() const                 { return "Unkown connection"; }
+
+  virtual std::string GetIP() const                   { return "127.0.0.1"; }
+  virtual std::string GetNetmask() const              { return "255.255.255.0"; }
+  virtual std::string GetMacAddress() const           { return "00:00:00:00:00:00"; }
+  virtual std::string GetGateway() const              { return ""; }
+
+  virtual unsigned int GetStrength() const            { return 100; }
+
+  virtual EncryptionType GetEncryption() const        { return NETWORK_CONNECTION_ENCRYPTION_NONE; }
+  virtual unsigned int GetConnectionSpeed() const     { return 100; }
+  virtual ConnectionType GetConnectionType() const    { return NETWORK_CONNECTION_TYPE_WIRED; }
+};
+
+class CNullNetworkManager : public INetworkManager
+{
+  virtual ~CNullNetworkManager() { }
+
+  virtual bool CanManageConnections() { return false; }
+
+  virtual ConnectionList GetConnections() { ConnectionList list; list.push_back(CConnectionPtr(new CNullConnection())); return list; }
+
+  virtual bool PumpNetworkEvents(INetworkEventsCallback *callback) { return true; }
+};
+
+class CNetworkManager : public INetworkEventsCallback
+{
+public:
+  CNetworkManager();
+  virtual ~CNetworkManager();
+
+  void Initialize();
+
+  void PumpNetworkEvents();
+
+  std::string GetDefaultConnectionName();
+  std::string GetDefaultConnectionIP();
+  std::string GetDefaultConnectionNetmask();
+  std::string GetDefaultConnectionMacAddress();
+  std::string GetDefaultConnectionGateway();
+
+  ConnectionState GetDefaultConnectionState();
+  bool IsConnected();
+
+  bool IsAvailable(bool wait = false);
+
+  bool CanManageConnections();
+
+  ConnectionList GetConnections();
+
+  virtual void OnConnectionStateChange(ConnectionState state);
+  virtual void OnConnectionChange(CConnectionPtr connection);
+  virtual void OnConnectionListChange(ConnectionList list);
+
+  void StartServices();
+  void StopServices();
+private:
+  void StopServices(bool wait);
+  const char *ConnectionStateToString(ConnectionState state);
+
+  INetworkManager *m_instance;
+  CConnectionPtr m_defaultConnection;
+  ConnectionList m_connections;
+  ConnectionState m_state;
+};
diff -Naur xbmc-dharma-35100/xbmc/NetworkUtils.cpp xbmc-dharma-35100.patch/xbmc/NetworkUtils.cpp
--- xbmc-dharma-35100/xbmc/NetworkUtils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/NetworkUtils.cpp	2010-11-01 21:17:04.476894991 +0100
@@ -0,0 +1,10 @@
+#include "NetworkUtils.h"
+#include <stdio.h>
+
+std::string CNetworkUtils::IPTotring(unsigned int ip)
+{
+  char buffer[16];
+  sprintf(buffer, "%i:%i:%i:%i", ip & 0xff, (ip & (0xff << 8)) >> 8, (ip & (0xff << 16)) >> 16, (ip & (0xff << 24)) >> 24);
+  std::string returnString = buffer;
+  return returnString;
+}
diff -Naur xbmc-dharma-35100/xbmc/NetworkUtils.h xbmc-dharma-35100.patch/xbmc/NetworkUtils.h
--- xbmc-dharma-35100/xbmc/NetworkUtils.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/NetworkUtils.h	2010-11-01 21:17:04.476894991 +0100
@@ -0,0 +1,9 @@
+#pragma once
+
+#include <string>
+
+class CNetworkUtils
+{
+public:
+  static std::string IPTotring(unsigned int ip);
+};
diff -Naur xbmc-dharma-35100/xbmc/Settings.cpp xbmc-dharma-35100.patch/xbmc/Settings.cpp
--- xbmc-dharma-35100/xbmc/Settings.cpp	2010-10-30 05:36:47.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/Settings.cpp	2010-11-01 21:17:04.478895015 +0100
@@ -38,7 +38,6 @@
 #include "GUIAudioManager.h"
 #include "AudioContext.h"
 #include "utils/GUIInfoManager.h"
-#include "utils/Network.h"
 #include "FileSystem/MultiPathDirectory.h"
 #include "FileSystem/SpecialProtocol.h"
 #include "GUIBaseContainer.h" // for VIEW_TYPE enum
diff -Naur xbmc-dharma-35100/xbmc/SystemGlobals.h xbmc-dharma-35100.patch/xbmc/SystemGlobals.h
--- xbmc-dharma-35100/xbmc/SystemGlobals.h	2010-10-30 05:36:41.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/SystemGlobals.h	2010-11-01 21:17:04.479895027 +0100
@@ -21,6 +21,7 @@
  *
  */
 
+#include "system.h"
 #include "WindowingFactory.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "GraphicContext.h"
diff -Naur xbmc-dharma-35100/xbmc/UPnP.cpp xbmc-dharma-35100.patch/xbmc/UPnP.cpp
--- xbmc-dharma-35100/xbmc/UPnP.cpp	2010-10-30 05:36:47.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/UPnP.cpp	2010-11-01 21:21:58.208336519 +0100
@@ -24,7 +24,6 @@
 #include "Util.h"
 #include "Application.h"
 
-#include "utils/Network.h"
 #include "utils/log.h"
 #include "UPnP.h"
 #include "FileSystem/MusicDatabaseDirectory.h"
@@ -1649,9 +1648,7 @@
         CStdString thumb = g_infoManager.GetImage(MUSICPLAYER_COVER, -1); //TODO: Only audio for now
 
         NPT_String ip;
-        if (g_application.getNetwork().GetFirstConnectedInterface()) {
-            ip = g_application.getNetwork().GetFirstConnectedInterface()->GetCurrentIPAddress().c_str();
-        }
+        ip = g_application.getNetworkManager().GetDefaultConnectionIP().c_str();
         // build url, use the internal device http server to serv the image
         NPT_HttpUrlQuery query;
         query.AddField("path", thumb.c_str());
@@ -1963,9 +1960,7 @@
     m_UPnP = new PLT_UPnP(1900, !broadcast);
 
     // keep main IP around
-    if (g_application.getNetwork().GetFirstConnectedInterface()) {
-        m_IP = g_application.getNetwork().GetFirstConnectedInterface()->GetCurrentIPAddress().c_str();
-    }
+    m_IP = g_application.getNetworkManager().GetDefaultConnectionIP().c_str();
     NPT_List<NPT_IpAddress> list;
     if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIPAddresses(list))) {
         m_IP = (*(list.GetFirstItem())).ToString();
diff -Naur xbmc-dharma-35100/xbmc/Util.cpp xbmc-dharma-35100.patch/xbmc/Util.cpp
--- xbmc-dharma-35100/xbmc/Util.cpp	2010-10-30 05:36:42.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/Util.cpp	2010-11-01 21:17:04.486895110 +0100
@@ -908,6 +908,7 @@
       address = ntohl(inet_addr(ip.c_str()));
   }
 
+#if 0
   if(address != INADDR_NONE)
   {
     // check if we are on the local subnet
@@ -917,6 +918,7 @@
     if (g_application.getNetwork().HasInterfaceForIP(address))
       return true;
   }
+#endif
 
   return false;
 }
@@ -1474,7 +1476,7 @@
 
   if (!g_settings.iAdditionalSubtitleDirectoryChecked && !g_guiSettings.GetString("subtitles.custompath").IsEmpty()) // to avoid checking non-existent directories (network) every time..
   {
-    if (!g_application.getNetwork().IsAvailable() && !IsHD(g_guiSettings.GetString("subtitles.custompath")))
+    if (!g_application.getNetworkManager().IsAvailable() && !IsHD(g_guiSettings.GetString("subtitles.custompath")))
     {
       CLog::Log(LOGINFO,"CUtil::CacheSubtitles: disabling alternate subtitle directory for this session, it's nonaccessible");
       g_settings.iAdditionalSubtitleDirectoryChecked = -1; // disabled
diff -Naur xbmc-dharma-35100/xbmc/utils/Builtins.cpp xbmc-dharma-35100.patch/xbmc/utils/Builtins.cpp
--- xbmc-dharma-35100/xbmc/utils/Builtins.cpp	2010-10-30 05:38:22.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/Builtins.cpp	2010-11-01 21:17:04.502895297 +0100
@@ -1045,7 +1045,7 @@
       videoScan->Close(true);
     }
 
-    g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_DOWN,1);
+    g_application.getNetworkManager().StopServices();
     g_settings.LoadMasterForLogin();
     g_passwordManager.bMasterUser = false;
     g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
@@ -1300,7 +1300,8 @@
   }
   else if (execute.Equals("wakeonlan"))
   {
-    g_application.getNetwork().WakeOnLan((char*)params[0].c_str());
+    // TODO Add
+    //g_application.getNetwork().WakeOnLan((char*)params[0].c_str());
   }
   else if (execute.Equals("addon.default.opensettings") && params.size() == 1)
   {
diff -Naur xbmc-dharma-35100/xbmc/utils/ConnectionJob.cpp xbmc-dharma-35100.patch/xbmc/utils/ConnectionJob.cpp
--- xbmc-dharma-35100/xbmc/utils/ConnectionJob.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/utils/ConnectionJob.cpp	2010-11-01 21:17:04.504895319 +0100
@@ -0,0 +1,51 @@
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "ConnectionJob.h"
+#include "GUIDialogKeyboard.h"
+#include "log.h"
+
+CConnectionJob::CConnectionJob(CConnectionPtr connection)
+{
+  m_connection = connection;
+}
+
+bool CConnectionJob::DoWork()
+{
+  return m_connection->Connect((IPassphraseStorage *)this, CIPConfig());
+}
+
+void CConnectionJob::InvalidatePassphrase(const std::string &uuid)
+{
+}
+
+bool CConnectionJob::GetPassphrase(const std::string &uuid, std::string &passphrase)
+{
+  CStdString utf8;
+  bool result = CGUIDialogKeyboard::ShowAndGetNewPassword(utf8);
+  passphrase = utf8;
+  return result;
+}
+
+void CConnectionJob::StorePassphrase(const std::string &uuid, const std::string &passphrase)
+{
+}
+
diff -Naur xbmc-dharma-35100/xbmc/utils/ConnectionJob.h xbmc-dharma-35100.patch/xbmc/utils/ConnectionJob.h
--- xbmc-dharma-35100/xbmc/utils/ConnectionJob.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/utils/ConnectionJob.h	2010-11-01 21:17:04.504895319 +0100
@@ -0,0 +1,39 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#include "IConnection.h"
+#include "Job.h"
+
+class CConnectionJob : public CJob, public IPassphraseStorage
+{
+public:
+  CConnectionJob(CConnectionPtr connection);
+
+  virtual bool DoWork();
+
+  virtual void InvalidatePassphrase(const std::string &uuid);
+  virtual bool GetPassphrase(const std::string &uuid, std::string &passphrase);
+  virtual void StorePassphrase(const std::string &uuid, const std::string &passphrase);
+private:
+  CConnectionPtr m_connection;
+};
diff -Naur xbmc-dharma-35100/xbmc/utils/GUIInfoManager.cpp xbmc-dharma-35100.patch/xbmc/utils/GUIInfoManager.cpp
--- xbmc-dharma-35100/xbmc/utils/GUIInfoManager.cpp	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/GUIInfoManager.cpp	2010-11-01 21:17:04.508895367 +0100
@@ -1227,7 +1227,6 @@
     break;
 
   case SYSTEM_VIDEO_ENCODER_INFO:
-  case NETWORK_MAC_ADDRESS:
   case SYSTEM_KERNEL_VERSION:
   case SYSTEM_CPUFREQUENCY:
   case SYSTEM_INTERNET_STATE:
@@ -1464,37 +1463,40 @@
 #endif
   case NETWORK_IP_ADDRESS:
     {
-      CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
-      if (iface)
-        return iface->GetCurrentIPAddress();
+      return g_application.getNetworkManager().GetDefaultConnectionIP();
     }
     break;
   case NETWORK_SUBNET_ADDRESS:
     {
-      CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
-      if (iface)
-        return iface->GetCurrentNetmask();
+      return g_application.getNetworkManager().GetDefaultConnectionNetmask();
+    }
+    break;
+  case NETWORK_MAC_ADDRESS:
+    {
+      return g_application.getNetworkManager().GetDefaultConnectionMacAddress();
     }
     break;
   case NETWORK_GATEWAY_ADDRESS:
     {
-      CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
-      if (iface)
-        return iface->GetCurrentDefaultGateway();
+      return g_application.getNetworkManager().GetDefaultConnectionGateway();
     }
     break;
   case NETWORK_DNS1_ADDRESS:
     {
+/*
       vector<CStdString> nss = g_application.getNetwork().GetNameServers();
       if (nss.size() >= 1)
         return nss[0];
+*/
     }
     break;
   case NETWORK_DNS2_ADDRESS:
     {
+/*
       vector<CStdString> nss = g_application.getNetwork().GetNameServers();
       if (nss.size() >= 2)
         return nss[1];
+*/
     }
     break;
   case NETWORK_DHCP_ADDRESS:
@@ -1505,6 +1507,7 @@
     break;
   case NETWORK_LINK_STATE:
     {
+/*
       CStdString linkStatus = g_localizeStrings.Get(151);
       linkStatus += " ";
       CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
@@ -1513,6 +1516,7 @@
       else
         linkStatus += g_localizeStrings.Get(15208);
       return linkStatus;
+*/
     }
     break;
 
diff -Naur xbmc-dharma-35100/xbmc/utils/Makefile xbmc-dharma-35100.patch/xbmc/utils/Makefile
--- xbmc-dharma-35100/xbmc/utils/Makefile	2010-10-30 05:38:22.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/Makefile	2010-11-01 21:17:04.510895391 +0100
@@ -37,7 +37,6 @@
      PCMAmplifier.cpp \
      PCMRemap.cpp \
      LabelFormatter.cpp \
-     Network.cpp \
      BitstreamStats.cpp \
      PerformanceStats.cpp \
      PerformanceSample.cpp \
@@ -70,7 +69,8 @@
      RingBuffer.cpp \
      FileOperationJob.cpp \
      FileUtils.cpp \
-     Variant.cpp
+     Variant.cpp \
+     ConnectionJob.cpp
 
 LIB=utils.a
 
diff -Naur xbmc-dharma-35100/xbmc/utils/Network.cpp xbmc-dharma-35100.patch/xbmc/utils/Network.cpp
--- xbmc-dharma-35100/xbmc/utils/Network.cpp	2010-10-30 05:38:22.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/Network.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,326 +0,0 @@
-/*
- *      Copyright (C) 2005-2010 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "system.h"
-#include "Network.h"
-#include "../Application.h"
-#include "../lib/libscrobbler/lastfmscrobbler.h"
-#include "../lib/libscrobbler/librefmscrobbler.h"
-#include "RssReader.h"
-#include "log.h"
-
-using namespace std;
-
-/* slightly modified in_ether taken from the etherboot project (http://sourceforge.net/projects/etherboot) */
-bool in_ether (const char *bufp, unsigned char *addr)
-{
-  if (strlen(bufp) != 17)
-    return false;
-
-  char c;
-  const char *orig;
-  unsigned char *ptr = addr;
-  unsigned val;
-
-  int i = 0;
-  orig = bufp;
-
-  while ((*bufp != '\0') && (i < 6))
-  {
-    val = 0;
-    c = *bufp++;
-
-    if (isdigit(c))
-      val = c - '0';
-    else if (c >= 'a' && c <= 'f')
-      val = c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F')
-      val = c - 'A' + 10;
-    else
-      return false;
-
-    val <<= 4;
-    c = *bufp;
-    if (isdigit(c))
-      val |= c - '0';
-    else if (c >= 'a' && c <= 'f')
-      val |= c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F')
-      val |= c - 'A' + 10;
-    else if (c == ':' || c == '-' || c == 0)
-      val >>= 4;
-    else
-      return false;
-
-    if (c != 0)
-      bufp++;
-
-    *ptr++ = (unsigned char) (val & 0377);
-    i++;
-
-    if (*bufp == ':' || *bufp == '-')
-      bufp++;
-  }
-
-  if (bufp - orig != 17)
-    return false;
-
-  return true;
-}
-
-CNetwork::CNetwork()
-{
-   g_application.getApplicationMessenger().NetworkMessage(SERVICES_UP, 0);
-}
-
-CNetwork::~CNetwork()
-{
-   g_application.getApplicationMessenger().NetworkMessage(SERVICES_DOWN, 0);
-}
-
-int CNetwork::ParseHex(char *str, unsigned char *addr)
-{
-   int len = 0;
-
-   while (*str)
-   {
-      int tmp;
-      if (str[1] == 0)
-         return -1;
-      if (sscanf(str, "%02x", (unsigned int *)&tmp) != 1)
-         return -1;
-      addr[len] = tmp;
-      len++;
-      str += 2;
-   }
-
-   return len;
-}
-
-CNetworkInterface* CNetwork::GetFirstConnectedInterface()
-{
-   vector<CNetworkInterface*>& ifaces = GetInterfaceList();
-   vector<CNetworkInterface*>::const_iterator iter = ifaces.begin();
-   while (iter != ifaces.end())
-   {
-      CNetworkInterface* iface = *iter;
-      if (iface && iface->IsConnected())
-         return iface;
-      ++iter;
-   }
-
-   return NULL;
-}
-
-bool CNetwork::HasInterfaceForIP(unsigned long address)
-{
-   unsigned long subnet;
-   unsigned long local;
-   vector<CNetworkInterface*>& ifaces = GetInterfaceList();
-   vector<CNetworkInterface*>::const_iterator iter = ifaces.begin();
-   while (iter != ifaces.end())
-   {
-      CNetworkInterface* iface = *iter;
-      if (iface && iface->IsConnected())
-      {
-         subnet = ntohl(inet_addr(iface->GetCurrentNetmask()));
-         local = ntohl(inet_addr(iface->GetCurrentIPAddress()));
-         if( (address & subnet) == (local & subnet) )
-            return true;
-      }
-      ++iter;
-   }
-
-   return false;
-}
-
-bool CNetwork::IsAvailable(bool wait /*= false*/)
-{
-  if (wait)
-  {
-    // NOTE: Not implemented in linuxport branch as 99.9% of the time
-    //       we have the network setup already.  Trunk code has a busy
-    //       wait for 5 seconds here.
-  }
-
-  vector<CNetworkInterface*>& ifaces = GetInterfaceList();
-  return (ifaces.size() != 0);
-}
-
-bool CNetwork::IsConnected()
-{
-   return GetFirstConnectedInterface() != NULL;
-}
-
-CNetworkInterface* CNetwork::GetInterfaceByName(CStdString& name)
-{
-   vector<CNetworkInterface*>& ifaces = GetInterfaceList();
-   vector<CNetworkInterface*>::const_iterator iter = ifaces.begin();
-   while (iter != ifaces.end())
-   {
-      CNetworkInterface* iface = *iter;
-      if (iface && iface->GetName().Equals(name))
-         return iface;
-      ++iter;
-   }
-
-   return NULL;
-}
-
-void CNetwork::NetworkMessage(EMESSAGE message, int param)
-{
-  switch( message )
-  {
-    case SERVICES_UP:
-    {
-      CLog::Log(LOGDEBUG, "%s - Starting network services",__FUNCTION__);
-      StartServices();
-    }
-    break;
-    case SERVICES_DOWN:
-    {
-      CLog::Log(LOGDEBUG, "%s - Signaling network services to stop",__FUNCTION__);
-      StopServices(false); //tell network services to stop, but don't wait for them yet
-      CLog::Log(LOGDEBUG, "%s - Waiting for network services to stop",__FUNCTION__);
-      StopServices(true); //wait for network services to stop
-    }
-    break;
-  }
-}
-
-bool CNetwork::WakeOnLan(const char* mac)
-{
-  int i, j, packet;
-  unsigned char ethaddr[8];
-  unsigned char buf [128];
-  unsigned char *ptr;
-
-  // Fetch the hardware address
-  if (!in_ether(mac, ethaddr))
-  {
-    CLog::Log(LOGERROR, "%s - Invalid hardware address specified (%s)", __FUNCTION__, mac);
-    return false;
-  }
-
-  // Setup the socket
-  if ((packet = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to create socket (%s)", __FUNCTION__, strerror (errno));
-    return false;
-  }
- 
-  // Set socket options
-  struct sockaddr_in saddr;
-  saddr.sin_family = AF_INET;
-  saddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
-  saddr.sin_port = htons(9);
-
-  unsigned int value = 1;
-  if (setsockopt (packet, SOL_SOCKET, SO_BROADCAST, (char*) &value, sizeof( unsigned int ) ) == SOCKET_ERROR)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to set socket options (%s)", __FUNCTION__, strerror (errno));
-    closesocket(packet);
-    return false;
-  }
- 
-  // Build the magic packet (6 x 0xff + 16 x MAC address)
-  ptr = buf;
-  for (i = 0; i < 6; i++)
-    *ptr++ = 0xff;
-
-  for (j = 0; j < 16; j++)
-    for (i = 0; i < 6; i++)
-      *ptr++ = ethaddr[i];
- 
-  // Send the magic packet
-  if (sendto (packet, (char *)buf, 102, 0, (struct sockaddr *)&saddr, sizeof (saddr)) < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to send magic packet (%s)", __FUNCTION__, strerror (errno));
-    closesocket(packet);
-    return false;
-  }
-
-  closesocket(packet);
-  CLog::Log(LOGINFO, "%s - Magic packet send to '%s'", __FUNCTION__, mac);
-  return true;
-}
-
-void CNetwork::StartServices()
-{
-#ifdef HAS_TIME_SERVER
-  g_application.StartTimeServer();
-#endif
-#ifdef HAS_WEB_SERVER
-  g_application.StartWebServer();
-#endif
-#ifdef HAS_UPNP
-  g_application.StartUPnP();
-#endif
-#ifdef HAS_EVENT_SERVER
-  g_application.StartEventServer();
-#endif
-#ifdef HAS_DBUS_SERVER
-  g_application.StartDbusServer();
-#endif
-#ifdef HAS_JSONRPC
-  g_application.StartJSONRPCServer();
-#endif
-#ifdef HAS_ZEROCONF
-  g_application.StartZeroconf();
-#endif
-  CLastfmScrobbler::GetInstance()->Init();
-  CLibrefmScrobbler::GetInstance()->Init();
-  g_rssManager.Start();
-}
-
-void CNetwork::StopServices(bool bWait)
-{
-  if (bWait)
-  {
-#ifdef HAS_TIME_SERVER
-    g_application.StopTimeServer();
-#endif
-#ifdef HAS_UPNP
-    g_application.StopUPnP(bWait);
-#endif
-#ifdef HAS_ZEROCONF
-    g_application.StopZeroconf();
-#endif
-#ifdef HAS_WEB_SERVER
-    g_application.StopWebServer();
-#endif    
-    CLastfmScrobbler::GetInstance()->Term();
-    CLibrefmScrobbler::GetInstance()->Term();
-    // smb.Deinit(); if any file is open over samba this will break.
-
-    g_rssManager.Stop();
-  }
-
-#ifdef HAS_EVENT_SERVER
-  g_application.StopEventServer(bWait, false);
-#endif
-#ifdef HAS_DBUS_SERVER
-  g_application.StopDbusServer(bWait);
-#endif
-#ifdef HAS_JSONRPC
-    g_application.StopJSONRPCServer(bWait);
-#endif
-}
diff -Naur xbmc-dharma-35100/xbmc/utils/Network.h xbmc-dharma-35100.patch/xbmc/utils/Network.h
--- xbmc-dharma-35100/xbmc/utils/Network.h	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/Network.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-#ifndef NETWORK_H_
-#define NETWORK_H_
-
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include <vector>
-#include "StdString.h"
-
-enum EncMode { ENC_NONE = 0, ENC_WEP = 1, ENC_WPA = 2, ENC_WPA2 = 3 };
-enum NetworkAssignment { NETWORK_DASH = 0, NETWORK_DHCP = 1, NETWORK_STATIC = 2, NETWORK_DISABLED = 3 };
-
-class NetworkAccessPoint
-{
-public:
-   NetworkAccessPoint(CStdString& essId, int quality, EncMode encryption)
-   {
-      m_essId = essId;
-      m_quality = quality;
-      m_encryptionMode = encryption;
-   }
-
-   CStdString getEssId() { return m_essId; }
-   int getQuality() { return m_quality; }
-   EncMode getEncryptionMode() { return m_encryptionMode; }
-
-private:
-   CStdString   m_essId;
-   int          m_quality;
-   EncMode      m_encryptionMode;
-};
-
-class CNetworkInterface
-{
-public:
-   virtual ~CNetworkInterface() {};
-
-   virtual CStdString& GetName(void) = 0;
-
-   virtual bool IsEnabled(void) = 0;
-   virtual bool IsConnected(void) = 0;
-   virtual bool IsWireless(void) = 0;
-
-   virtual CStdString GetMacAddress(void) = 0;
-
-   virtual CStdString GetCurrentIPAddress() = 0;
-   virtual CStdString GetCurrentNetmask() = 0;
-   virtual CStdString GetCurrentDefaultGateway(void) = 0;
-   virtual CStdString GetCurrentWirelessEssId(void) = 0;
-
-   // Returns the list of access points in the area
-   virtual std::vector<NetworkAccessPoint> GetAccessPoints(void) = 0;
-
-   virtual void GetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode) = 0;
-   virtual void SetSettings(NetworkAssignment& assignment, CStdString& ipAddress, CStdString& networkMask, CStdString& defaultGateway, CStdString& essId, CStdString& key, EncMode& encryptionMode) = 0;
-};
-
-
-
-class CNetwork
-{
-public:
-  enum EMESSAGE
-  {
-    SERVICES_UP,
-    SERVICES_DOWN
-  };
-
-   CNetwork();
-   virtual ~CNetwork();
-
-   // Return the list of interfaces
-   virtual std::vector<CNetworkInterface*>& GetInterfaceList(void) = 0;
-   CNetworkInterface* GetInterfaceByName(CStdString& name);
-
-   // Return the first interface which is active
-   CNetworkInterface* GetFirstConnectedInterface(void);
-
-   // Return true if there is a interface for the same network as address
-   bool HasInterfaceForIP(unsigned long address);
-
-   // Return true if there's at least one defined network interface
-   bool IsAvailable(bool wait = false);
-
-   // Return true if there's at least one interface which is connected
-   bool IsConnected(void);
-
-   // Return true if the magic packet was send
-   bool WakeOnLan(const char *mac);
-
-   // Get/set the nameserver(s)
-   virtual std::vector<CStdString> GetNameServers(void) = 0;
-   virtual void SetNameServers(std::vector<CStdString> nameServers) = 0;
-
-   // callback from application controlled thread to handle any setup
-   void NetworkMessage(EMESSAGE message, int param);
-
-   void StartServices();
-   void StopServices(bool bWait);
-
-   static int ParseHex(char *str, unsigned char *addr);
-};
-#ifdef HAS_LINUX_NETWORK
-#include "linux/NetworkLinux.h"
-#else
-#include "win32/NetworkWin32.h"
-#endif
-#endif
diff -Naur xbmc-dharma-35100/xbmc/utils/RssReader.cpp xbmc-dharma-35100.patch/xbmc/utils/RssReader.cpp
--- xbmc-dharma-35100/xbmc/utils/RssReader.cpp	2010-10-30 05:38:22.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/RssReader.cpp	2010-11-01 21:17:04.511895404 +0100
@@ -21,7 +21,6 @@
 
 #include "RssReader.h"
 #include "utils/HTMLUtil.h"
-#include "../utils/Network.h"
 #include "Application.h"
 #include "CharsetConverter.h"
 #include "URL.h"
@@ -138,7 +137,7 @@
     CURL url(strUrl);
 
     // we wait for the network to come up
-    if ((url.GetProtocol() == "http" || url.GetProtocol() == "https") && !g_application.getNetwork().IsAvailable(true))
+    if ((url.GetProtocol() == "http" || url.GetProtocol() == "https") && !g_application.getNetworkManager().IsAvailable(true))
       strXML = "<rss><item><title>"+g_localizeStrings.Get(15301)+"</title></item></rss>";
     else
     {
diff -Naur xbmc-dharma-35100/xbmc/utils/SystemInfo.cpp xbmc-dharma-35100.patch/xbmc/utils/SystemInfo.cpp
--- xbmc-dharma-35100/xbmc/utils/SystemInfo.cpp	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/SystemInfo.cpp	2010-11-01 21:17:04.511895404 +0100
@@ -28,7 +28,6 @@
 #endif
 #include "utils/GUIInfoManager.h"
 #include "FileSystem/FileCurl.h"
-#include "Network.h"
 #include "Application.h"
 #include "GraphicContext.h"
 #include "WindowingFactory.h"
@@ -58,7 +57,6 @@
   m_info.videoEncoder      = GetVideoEncoder();
   m_info.cpuFrequency      = GetCPUFreqInfo();
   m_info.kernelVersion     = CSysInfo::GetKernelVersion();
-  m_info.macAddress        = GetMACAddress();
   return true;
 }
 
@@ -86,16 +84,6 @@
   return CSysData::DISCONNECTED;
 }
 
-CStdString CSysInfoJob::GetMACAddress()
-{
-#if defined(HAS_LINUX_NETWORK)
-  CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
-  if (iface)
-    return iface->GetMacAddress();
-#endif
-  return "";
-}
-
 CStdString CSysInfoJob::GetVideoEncoder()
 {
   return "GPU: " + g_Windowing.GetRenderRenderer();
@@ -171,8 +159,6 @@
   {
   case SYSTEM_VIDEO_ENCODER_INFO:
     return m_info.videoEncoder;
-  case NETWORK_MAC_ADDRESS:
-    return m_info.macAddress;
   case SYSTEM_KERNEL_VERSION:
     return m_info.kernelVersion;
   case SYSTEM_CPUFREQUENCY:
diff -Naur xbmc-dharma-35100/xbmc/utils/SystemInfo.h xbmc-dharma-35100.patch/xbmc/utils/SystemInfo.h
--- xbmc-dharma-35100/xbmc/utils/SystemInfo.h	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/SystemInfo.h	2010-11-01 21:17:04.512895415 +0100
@@ -52,7 +52,6 @@
   CStdString videoEncoder;
   CStdString cpuFrequency;
   CStdString kernelVersion;
-  CStdString macAddress;
 };
 
 class CSysInfoJob : public CJob
@@ -69,7 +68,6 @@
   double GetCPUFrequency();
   CStdString GetSystemUpTime(bool bTotalUptime);
   CStdString GetCPUFreqInfo();
-  CStdString GetMACAddress();
   CStdString GetVideoEncoder();
 
   CSysData m_info;
diff -Naur xbmc-dharma-35100/xbmc/utils/UdpClient.cpp xbmc-dharma-35100.patch/xbmc/utils/UdpClient.cpp
--- xbmc-dharma-35100/xbmc/utils/UdpClient.cpp	2010-10-30 05:38:21.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/UdpClient.cpp	2010-11-01 21:17:04.512895415 +0100
@@ -23,7 +23,6 @@
 #ifdef _LINUX
 #include <sys/ioctl.h>
 #endif
-#include "../utils/Network.h"
 #include "GraphicContext.h"
 #include "log.h"
 #include "utils/TimeUtils.h"
diff -Naur xbmc-dharma-35100/xbmc/utils/Weather.cpp xbmc-dharma-35100.patch/xbmc/utils/Weather.cpp
--- xbmc-dharma-35100/xbmc/utils/Weather.cpp	2010-10-30 05:38:22.000000000 +0200
+++ xbmc-dharma-35100.patch/xbmc/utils/Weather.cpp	2010-11-01 21:17:04.513895426 +0100
@@ -31,7 +31,6 @@
 #include "FileSystem/FileCurl.h"
 #include "XMLUtils.h"
 #include "Temperature.h"
-#include "Network.h"
 #include "Util.h"
 #include "Application.h"
 #include "GUISettings.h"
@@ -121,7 +120,7 @@
 bool CWeatherJob::DoWork()
 {
   // wait for the network
-  if (!g_application.getNetwork().IsAvailable(true))
+  if (!g_application.getNetworkManager().IsAvailable(true))
     return false;
 
   // Download our weather
