diff -Naur xbmc-dharma-35100/xbmc/Application.cpp.orig xbmc-dharma-35100.patch/xbmc/Application.cpp.orig
diff -Naur xbmc-dharma-35100/xbmc/linux/ConnmanConnection.cpp xbmc-dharma-35100.patch/xbmc/linux/ConnmanConnection.cpp
--- xbmc-dharma-35100/xbmc/linux/ConnmanConnection.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/ConnmanConnection.cpp	2010-11-01 21:26:01.472185976 +0100
@@ -0,0 +1,224 @@
+#include "ConnmanConnection.h"
+
+#ifdef HAS_DBUS
+#include "DBusUtil.h"
+#include "DBusMessage.h"
+#include "log.h"
+#include <string.h>
+#include <stdio.h>
+
+CConnmanConnection::CConnmanConnection(const char *serviceObject)
+{
+  m_serviceObject = serviceObject;
+
+  CDBusMessage message("org.moblin.connman", serviceObject, "org.moblin.connman.Service", "GetProperties");
+  CDBusReplyPtr reply = message.SendSystem();
+  m_properties = reply->GetNextArgument();
+
+  UpdateConnection();
+
+  dbus_error_init (&m_error);
+
+  // TODO: do not use dbus_connection_pop_message() that requires the use of a
+  // private connection
+  m_connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &m_error);
+  if (m_connection)
+  {
+    dbus_connection_set_exit_on_disconnect(m_connection, false);
+
+    dbus_bus_add_match(m_connection, "type='signal',interface='org.moblin.connman.Service'", &m_error);
+    dbus_connection_flush(m_connection);
+    if (dbus_error_is_set(&m_error))
+    {
+      CLog::Log(LOGERROR, "ConnmanConnection: %s Failed to attach to signal %s", serviceObject, m_error.message);
+      dbus_connection_close(m_connection);
+      dbus_connection_unref(m_connection);
+      m_connection = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGERROR, "ConnmanConnection: %s Failed to get a DBus connection %s", serviceObject, m_error.message);
+}
+
+CConnmanConnection::~CConnmanConnection()
+{
+  if (m_connection)
+  {
+    dbus_connection_close(m_connection);
+    dbus_connection_unref(m_connection);
+    m_connection = NULL;
+  }
+
+  dbus_error_free (&m_error);
+}
+
+bool CConnmanConnection::Connect(IPassphraseStorage *storage, const CIPConfig &ipconfig)
+{
+  if (m_encryption != NETWORK_CONNECTION_ENCRYPTION_NONE)
+  {
+    std::string passphrase;
+    if (!storage->GetPassphrase(m_serviceObject, passphrase))
+      return false;
+
+    CDBusMessage message("org.moblin.connman", m_serviceObject.c_str(), "org.moblin.connman.Service", "SetProperties");
+    message.AppendArgument("Passphrase");
+    message.AppendArgument(passphrase.c_str());
+
+    CDBusReplyPtr reply = message.SendSystem();
+    if (reply->IsErrorSet())
+    {
+      CLog::Log(LOGERROR, "ConnmanConnection: Failed to set passphrase");
+      return false;
+    }
+  }
+
+  CDBusMessage message("org.moblin.connman", m_serviceObject.c_str(), "org.moblin.connman.Service", "Connect");
+  return message.SendAsyncSystem();
+}
+
+ConnectionState CConnmanConnection::GetConnectionState() const
+{
+  return m_state;
+}
+
+std::string CConnmanConnection::GetName() const
+{
+  return m_name;
+}
+
+std::string CConnmanConnection::GetIP() const
+{
+  return m_IP;
+}
+
+std::string CConnmanConnection::GetNetmask() const
+{
+  return m_netmask;
+}
+
+std::string CConnmanConnection::GetMacAddress() const
+{
+  return m_macaddress;
+}
+
+std::string CConnmanConnection::GetGateway() const
+{
+  return m_gateway;
+}
+
+unsigned int CConnmanConnection::GetStrength() const
+{
+  return m_strength;;
+}
+
+EncryptionType CConnmanConnection::GetEncryption() const
+{
+  return m_encryption;
+}
+
+unsigned int CConnmanConnection::GetConnectionSpeed() const
+{
+  return m_speed;
+}
+
+ConnectionType CConnmanConnection::GetConnectionType() const
+{
+  return m_type;
+}
+
+bool CConnmanConnection::PumpNetworkEvents()
+{
+  bool result = false;
+
+  if (m_connection)
+  {
+    dbus_connection_read_write(m_connection, 0);
+    DBusMessage *msg = dbus_connection_pop_message(m_connection);
+
+    if (msg)
+    {
+      CDBusReplyPtr reply = CDBusReplyPtr(new CDBusReply(msg));
+
+      if (dbus_message_is_signal(msg, "org.moblin.connman.Service", "PropertyChanged"))
+      {
+        CVariant key = reply->GetNextArgument();
+        m_properties[key.asString()] = reply->GetNextArgument();
+
+        UpdateConnection();
+        result = true;
+      }
+
+      dbus_message_unref(msg);
+    }
+  }
+
+  return result;
+}
+
+ConnectionState CConnmanConnection::ParseConnectionState(const char *stateString)
+{
+  if (strcmp(stateString, "online") == 0)
+    return NETWORK_CONNECTION_STATE_CONNECTED;
+  else if (strcmp(stateString, "association") == 0)
+    return NETWORK_CONNECTION_STATE_CONNECTING;
+  else if (strcmp(stateString, "configuration") == 0)
+    return NETWORK_CONNECTION_STATE_CONNECTING;
+  else if (strcmp(stateString, "failure") == 0)
+    return NETWORK_CONNECTION_STATE_FAILURE;
+  else
+  {
+    // The state can be ready which means that the connection have been setup and is ready to be used.
+    // Perhaps we want to differentiate this in GUI? Its not used but might be in case the active connection is lost.
+    return NETWORK_CONNECTION_STATE_DISCONNECTED;
+  }
+}
+
+void CConnmanConnection::UpdateConnection()
+{
+  m_name = m_properties["Name"].asString();
+
+  m_state = ParseConnectionState(m_properties["State"].asString());
+
+  if (strcmp(m_properties["Type"].asString(), "ethernet") == 0)
+    m_type = NETWORK_CONNECTION_TYPE_WIRED;
+  else if (strcmp(m_properties["Type"].asString(), "wifi") == 0)
+    m_type = NETWORK_CONNECTION_TYPE_WIFI;
+  else
+    m_type = NETWORK_CONNECTION_TYPE_UNKNOWN;
+
+  m_IP = m_properties["IPv4"]["Address"].asString();
+  m_netmask = m_properties["IPv4"]["Netmask"].asString();
+  m_macaddress = m_properties["Ethernet"]["Address"].asString();
+  m_gateway = m_properties["IPv4"]["Gateway"].asString();
+
+  if (m_type == NETWORK_CONNECTION_TYPE_WIFI)
+  {
+    m_strength = m_properties["Strength"].asInteger();
+    m_speed = m_properties["Ethernet"]["Speed"].asInteger();
+
+    if (strcmp(m_properties["Security"].asString(), "none") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_NONE;
+    else if (strcmp(m_properties["Security"].asString(), "wep") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_WEP;
+    else if (strcmp(m_properties["Security"].asString(), "wpa") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_WPA;
+    else if (strcmp(m_properties["Security"].asString(), "psk") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_WPA;
+    else if (strcmp(m_properties["Security"].asString(), "rsn") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_WPA;
+    else if (strcmp(m_properties["Security"].asString(), "ieee8021x") == 0)
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_IEEE8021x;
+    else
+    {
+      CLog::Log(LOGWARNING, "Connman: unkown connection encryption %s", m_properties["Security"].asString());
+      m_encryption = NETWORK_CONNECTION_ENCRYPTION_UNKNOWN;
+    }
+  }
+  else
+  {
+    m_strength = 100;
+    m_speed = m_properties["Ethernet"]["Speed"].asInteger();
+    m_encryption = NETWORK_CONNECTION_ENCRYPTION_NONE;
+  }
+}
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/ConnmanConnection.h xbmc-dharma-35100.patch/xbmc/linux/ConnmanConnection.h
--- xbmc-dharma-35100/xbmc/linux/ConnmanConnection.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/ConnmanConnection.h	2010-11-01 21:26:01.480186069 +0100
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "system.h"
+#ifdef HAS_DBUS
+#include "IConnection.h"
+#include "DBusUtil.h"
+#include <dbus/dbus.h>
+
+class CConnmanConnection : public IConnection
+{
+public:
+  CConnmanConnection(const char *serviceObject);
+  virtual ~CConnmanConnection();
+
+  virtual bool Connect(IPassphraseStorage *storage, const CIPConfig &ipconfig);
+  virtual ConnectionState GetConnectionState() const;
+
+  virtual std::string GetName() const;
+
+  virtual std::string GetIP() const;
+  virtual std::string GetNetmask() const;
+  virtual std::string GetMacAddress() const;
+  virtual std::string GetGateway() const;
+
+  virtual unsigned int GetStrength() const;
+  virtual EncryptionType GetEncryption() const;
+  virtual unsigned int GetConnectionSpeed() const;
+
+  virtual ConnectionType GetConnectionType() const;
+
+  bool PumpNetworkEvents();
+
+  static ConnectionState ParseConnectionState(const char *stateString);
+private:
+  void UpdateConnection();
+
+  CVariant m_properties;
+
+  std::string m_name;
+  std::string m_IP;
+  std::string m_netmask;
+  std::string m_macaddress;
+  std::string m_gateway;
+
+  std::string m_serviceObject;
+
+  unsigned int m_strength;
+  unsigned int m_speed;
+
+  ConnectionState m_state;
+  EncryptionType m_encryption;
+  ConnectionType m_type;
+
+  DBusConnection *m_connection;
+  DBusError m_error;
+};
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/ConnmanNetworkManager.cpp xbmc-dharma-35100.patch/xbmc/linux/ConnmanNetworkManager.cpp
--- xbmc-dharma-35100/xbmc/linux/ConnmanNetworkManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/ConnmanNetworkManager.cpp	2010-11-01 21:26:01.481186080 +0100
@@ -0,0 +1,150 @@
+#include "ConnmanNetworkManager.h"
+
+#ifdef HAS_DBUS
+#include "ConnmanConnection.h"
+#include "DBusUtil.h"
+#include "DBusMessage.h"
+#include "log.h"
+
+#include <string.h>
+
+using namespace std;
+
+CConnmanNetworkManager::CConnmanNetworkManager()
+{
+  CDBusMessage message("org.moblin.connman", "/", "org.moblin.connman.Manager", "GetProperties");
+  CDBusReplyPtr reply = message.SendSystem();
+  m_properties = reply->GetNextArgument();
+
+  UpdateNetworkManager();
+
+  dbus_error_init (&m_error);
+  // TODO: do not use dbus_connection_pop_message() that requires the use of a
+  // private connection
+  m_connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &m_error);
+  if (m_connection)
+  {
+    dbus_connection_set_exit_on_disconnect(m_connection, false);
+
+    dbus_bus_add_match(m_connection, "type='signal',interface='org.moblin.connman.Manager'", &m_error);
+    dbus_connection_flush(m_connection);
+    if (dbus_error_is_set(&m_error))
+    {
+      CLog::Log(LOGERROR, "ConnmanNetworkManager: Failed to attach to signal %s", m_error.message);
+      dbus_connection_close(m_connection);
+      dbus_connection_unref(m_connection);
+      m_connection = NULL;
+    }
+  }
+  else
+    CLog::Log(LOGERROR, "ConnmanNetworkManager: Failed to get a DBus connection %s", m_error.message);
+}
+
+CConnmanNetworkManager::~CConnmanNetworkManager()
+{
+  if (m_connection)
+  {
+    dbus_connection_close(m_connection);
+    dbus_connection_unref(m_connection);
+    m_connection = NULL;
+  }
+
+  dbus_error_free (&m_error);
+}
+
+bool CConnmanNetworkManager::CanManageConnections()
+{
+  // TODO Only return true if we are registered as agent
+  return true;
+}
+
+ConnectionList CConnmanNetworkManager::GetConnections()
+{
+  return m_connections;
+}
+
+bool CConnmanNetworkManager::PumpNetworkEvents(INetworkEventsCallback *callback)
+{
+  bool result = false;
+
+  if (m_connection)
+  {
+    dbus_connection_read_write(m_connection, 0);
+    DBusMessage *msg = dbus_connection_pop_message(m_connection);
+
+    if (msg)
+    {
+      CDBusReplyPtr reply = CDBusReplyPtr(new CDBusReply(msg));
+
+      if (dbus_message_is_signal(msg, "org.moblin.connman.Manager", "PropertyChanged"))
+      {
+        CVariant key = reply->GetNextArgument();
+        m_properties[key.asString()] = reply->GetNextArgument();
+
+        UpdateNetworkManager();
+
+        if (strcmp(key.asString(), "Services") == 0)
+          callback->OnConnectionListChange(m_connections);
+
+        result = true;
+      }
+      else if (dbus_message_is_signal(msg, "org.moblin.connman.Manager", "StateChanged"))
+      {
+        CVariant stateString = reply->GetNextArgument();
+        result = true;
+        callback->OnConnectionStateChange(CConnmanConnection::ParseConnectionState(stateString.asString()));
+      }
+      else
+        CLog::Log(LOGINFO, "ConnmanNetworkManager: Recieved an unknown signal %s", dbus_message_get_member(msg));
+
+      dbus_message_unref(msg);
+    }
+  }
+
+  for (unsigned int i = 0; i < m_connections.size(); i++)
+  {
+    if (((CConnmanConnection *)m_connections[i].get())->PumpNetworkEvents())
+    {
+      callback->OnConnectionChange(m_connections[i]);
+      result = true;
+    }
+  }
+
+  return result;
+}
+
+bool CConnmanNetworkManager::HasConnman()
+{
+  CDBusMessage message("org.moblin.connman", "/", "org.moblin.connman.Manager", "GetProperties");
+
+  DBusError error;
+  dbus_error_init (&error);
+  DBusConnection *connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+
+  message.Send(connection, &error);
+
+  if (!dbus_error_is_set(&error))
+    return true;
+  else
+  {
+    CLog::Log(LOGDEBUG, "ConnmanNetworkManager: %s - %s", error.name, error.message);
+    return false;
+  }
+}
+
+void CConnmanNetworkManager::UpdateNetworkManager()
+{
+  m_connections.clear();
+
+  CVariant services = m_properties["Services"];
+
+  for (unsigned int i = 0; i < services.size(); i++)
+  {
+    if (strcmp(services[i].asString(), "") == 0)
+      continue;
+
+    IConnection *connection = new CConnmanConnection(services[i].asString());
+    m_connections.push_back(CConnectionPtr(connection));
+  }
+}
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/ConnmanNetworkManager.h xbmc-dharma-35100.patch/xbmc/linux/ConnmanNetworkManager.h
--- xbmc-dharma-35100/xbmc/linux/ConnmanNetworkManager.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/ConnmanNetworkManager.h	2010-11-01 21:26:01.481186080 +0100
@@ -0,0 +1,30 @@
+#pragma once
+
+#include "system.h"
+#ifdef HAS_DBUS
+#include "INetworkManager.h"
+#include "Variant.h"
+#include <dbus/dbus.h>
+
+class CConnmanNetworkManager : public INetworkManager
+{
+public:
+  CConnmanNetworkManager();
+  virtual ~CConnmanNetworkManager();
+
+  virtual bool CanManageConnections();
+
+  virtual ConnectionList GetConnections();
+
+  virtual bool PumpNetworkEvents(INetworkEventsCallback *callback);
+
+  static bool HasConnman();
+private:
+  void UpdateNetworkManager();
+
+  ConnectionList m_connections;
+  CVariant m_properties;
+  DBusConnection *m_connection;
+  DBusError m_error;
+};
+#endif
diff -Naur xbmc-dharma-35100/xbmc/linux/Makefile.in xbmc-dharma-35100.patch/xbmc/linux/Makefile.in
--- xbmc-dharma-35100/xbmc/linux/Makefile.in	2010-11-01 21:23:32.008435321 +0100
+++ xbmc-dharma-35100.patch/xbmc/linux/Makefile.in	2010-11-01 21:26:01.482186092 +0100
@@ -7,7 +7,7 @@
 
 CXXFLAGS+=-fPIC #-DHAS_SDL
 
-SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp ConsoleUPowerSyscall.cpp DBusUtil.cpp DBusReply.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp
+SRCS=ConvUtils.cpp XEventUtils.cpp XFileUtils.cpp XHandle.cpp XSyncUtils.cpp XTimeUtils.cpp XMemUtils.cpp XThreadUtils.cpp LinuxResourceCounter.cpp LinuxTimezone.cpp XRandR.cpp XCriticalSection.cpp XLCDproc.cpp HALManager.cpp HALPowerSyscall.cpp ConsoleDeviceKitPowerSyscall.cpp ConsoleUPowerSyscall.cpp DBusUtil.cpp DBusReply.cpp DBusMessage.cpp ZeroconfAvahi.cpp ZeroconfBrowserAvahi.cpp HALProvider.cpp PosixMountProvider.cpp DeviceKitDisksProvider.cpp UDisksProvider.cpp ConnmanNetworkManager.cpp ConnmanConnection.cpp
 
 LIB=linux.a
 
diff -Naur xbmc-dharma-35100/xbmc/NetworkManager.cpp xbmc-dharma-35100.patch/xbmc/NetworkManager.cpp
--- xbmc-dharma-35100/xbmc/NetworkManager.cpp	2010-11-01 21:26:39.296628972 +0100
+++ xbmc-dharma-35100.patch/xbmc/NetworkManager.cpp	2010-11-01 21:26:01.453185752 +0100
@@ -5,6 +5,7 @@
 #include "lib/libscrobbler/librefmscrobbler.h"
 #include "RssReader.h"
 #include "ApplicationMessenger.h"
+#include "linux/ConnmanNetworkManager.h"
 
 using namespace std;
 
@@ -21,7 +22,10 @@
 
 void CNetworkManager::Initialize()
 {
-  // Here should platform specific go
+#ifdef HAS_DBUS
+  if (CConnmanNetworkManager::HasConnman())
+    m_instance = new CConnmanNetworkManager();
+#endif
 
   if (m_instance == NULL)
     m_instance = new CNullNetworkManager();
