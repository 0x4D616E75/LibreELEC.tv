diff -Naur mythtv-21776/libs/libmyth/libmyth.pro mythtv-21776.patch/libs/libmyth/libmyth.pro
--- mythtv-21776/libs/libmyth/libmyth.pro	2009-09-11 14:54:24.000000000 +0200
+++ mythtv-21776.patch/libs/libmyth/libmyth.pro	2009-09-11 18:20:40.669706073 +0200
@@ -113,7 +113,7 @@
     LIBS += $$PULSE_LIBS
 }
 
-unix:!cygwin {
+unix:!cygwin:!uclibc {
     SOURCES += mediamonitor-unix.cpp
     HEADERS += mediamonitor-unix.h
 }
@@ -125,6 +125,11 @@
     #SOURCES += mediamonitor-windows.cpp
 }
 
+uclibc {
+    SOURCES += mediamonitor-uclibc.cpp
+    HEADERS += mediamonitor-uclibc.h
+}
+
 mingw {
     DEFINES += USING_MINGW
     SOURCES += mediamonitor-windows.cpp audiooutputwin.cpp audiooutputdx.cpp
diff -Naur mythtv-21776/libs/libmyth/mediamonitor-uclibc.cpp mythtv-21776.patch/libs/libmyth/mediamonitor-uclibc.cpp
--- mythtv-21776/libs/libmyth/mediamonitor-uclibc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-21776.patch/libs/libmyth/mediamonitor-uclibc.cpp	2009-09-11 19:26:23.286706713 +0200
@@ -0,0 +1,639 @@
+// -*- Mode: c++ -*-
+
+// Standard C headers
+#include <cstdio>
+
+// POSIX headers
+#include <dirent.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <mntent.h>
+
+// UNIX System headers
+#include <sys/file.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/param.h>
+
+// C++ headers
+#include <iostream>
+
+using namespace std;
+
+// Qt headers
+#include <QList>
+#include <QTextStream>
+#include <QApplication>
+#include <QProcess>
+#include <QDir>
+#include <QFile>
+
+// MythTV headers
+#include "mythmediamonitor.h"
+#include "mediamonitor-uclibc.h"
+#include "mythcontext.h"
+#include "mythdialogs.h"
+#include "mythconfig.h"
+#include "mythcdrom.h"
+#include "mythhdd.h"
+#include "mythverbose.h"
+
+#ifndef MNTTYPE_ISO9660
+#ifdef linux
+#define MNTTYPE_ISO9660 "iso9660"
+#elif defined(__FreeBSD__) || CONFIG_DARWIN || defined(__OpenBSD__)
+#define MNTTYPE_ISO9660 "cd9660"
+#endif
+#endif
+
+#ifndef MNTTYPE_UDF
+#define MNTTYPE_UDF "udf"
+#endif
+
+#ifndef MNTTYPE_AUTO
+#define MNTTYPE_AUTO "auto"
+#endif
+
+#ifndef MNTTYPE_SUPERMOUNT
+#define MNTTYPE_SUPERMOUNT "supermount"
+#endif
+#define SUPER_OPT_DEV "dev="
+
+#ifndef _PATH_FSTAB
+#define _PATH_FSTAB "/etc/fstab"
+#endif /* _PATH_FSTAB */
+
+const char * MediaMonitoruClibc::kUDEV_FIFO = "/tmp/mythtv_media";
+
+
+// Some helpers for debugging:
+
+static const QString LOC = QString("MMUnix:");
+
+static void fstabError(const QString &methodName)
+{
+    VERBOSE(VB_IMPORTANT, LOC + methodName + " Error: failed to open "
+                          + _PATH_FSTAB + " for reading, " + ENO);
+}
+
+static void statError(const QString &methodName, const QString devPath)
+{
+    VERBOSE(VB_MEDIA, LOC + methodName + " Error: failed to stat "
+                          + devPath + ", " + ENO);
+}
+
+////////////////////////////////////////////////////////////////////////
+// MediaMonitor
+
+
+MediaMonitoruClibc::MediaMonitoruClibc(QObject* par,
+                                   unsigned long interval, bool allowEject)
+                : MediaMonitor(par, interval, allowEject)
+{
+    CheckFileSystemTable();
+    CheckMountable();
+
+    VERBOSE(VB_MEDIA, "Initial device list...\n" + listDevices());
+}
+
+
+void MediaMonitoruClibc::deleteLater(void)
+{
+    if (m_fifo >= 0)
+    {
+        close(m_fifo);
+        m_fifo = -1;
+        unlink(kUDEV_FIFO);
+    }
+    MediaMonitor::deleteLater();
+}
+
+
+// Loop through the file system table and add any supported devices.
+bool MediaMonitoruClibc::CheckFileSystemTable(void)
+{
+    FILE * fstab;
+    struct mntent * mep = NULL;
+
+    // Attempt to open the file system descriptor entry.
+    if ((fstab = setmntent (_PATH_FSTAB, "r")) < 0)
+    {
+        fstabError(":CheckFileSystemTable()");
+        return false;
+    }
+
+    // Add all the entries
+    while ((mep = getmntent(fstab)) != NULL)
+        AddDevice(mep);
+
+    endmntent(fstab);
+
+    if (m_Devices.isEmpty())
+        return false;
+
+    return true;
+}
+
+/**
+ *  \brief Search /sys/block for valid removable media devices.
+ *
+ *   This function creates MediaDevice instances for valid removable media
+ *   devices found under the /sys/block filesystem in Linux.  CD and DVD
+ *   devices are created as MythCDROM instances.  MythHDD instances will be
+ *   created for each partition on removable hard disk devices, if they exist.
+ *   Otherwise a single MythHDD instance will be created for the entire disc.
+ *
+ *   NOTE: Floppy disks are ignored.
+ */
+bool MediaMonitoruClibc::CheckMountable(void)
+{
+#ifdef linux
+    mkfifo(kUDEV_FIFO, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
+    m_fifo = open(kUDEV_FIFO, O_RDONLY | O_NONBLOCK);
+
+    QDir sysfs("/sys/block");
+    sysfs.setFilter(QDir::Dirs);
+
+    QStringList devices = sysfs.entryList();
+
+    for (QStringList::iterator it = devices.begin(); it != devices.end(); ++it)
+    {
+        if (*it == "." || *it == "..")
+            continue;
+
+        // ignore floppies, too slow
+        if ((*it).startsWith("fd"))
+            continue;
+
+        sysfs.cd(*it);
+        QString path = sysfs.absolutePath();
+        if (CheckRemovable(path))
+            FindPartitions(path, true);
+        sysfs.cdUp();
+    }
+    return true;
+#else // if !linux
+    return false;
+#endif // !linux
+}
+
+/**
+ * \brief  Is /sys/block/dev a removable device?
+ */
+bool MediaMonitoruClibc::CheckRemovable(const QString &dev)
+{
+#ifdef linux
+        QString removablePath = dev + "/removable";
+        QFile   removable(removablePath);
+        if (removable.exists() && removable.open(QIODevice::ReadOnly))
+        {
+            char    c   = 0;
+            QString msg = LOC + ":CheckRemovable(" + dev + ")/removable ";
+            bool    ok  = removable.getChar(&c);
+            removable.close();
+
+            if (ok)
+            {
+                VERBOSE(VB_MEDIA+VB_EXTRA, msg + c);
+                if (c == '1')
+                    return true;
+            }
+            else
+            {
+                VERBOSE(VB_IMPORTANT, msg + "failed");
+            }
+        }
+        return false;
+#else // if !linux
+    return false;
+#endif // !linux
+}
+
+/**
+ *  \brief Returns the device special file associated with the /sys/block node.
+ *  \param sysfs system filesystem path of removable block device.
+ *  \return path to the device special file
+ */
+QString MediaMonitoruClibc::GetDeviceFile(const QString &sysfs)
+{
+    QString msg = LOC + ":GetDeviceFile(" + sysfs + ")";
+    QString ret = sysfs;
+
+    // In case of error, a working default?  (device names usually match)
+    ret.replace(QRegExp(".*/"), "/dev/");
+
+#ifdef linux
+    QProcess    *udevinfo = new QProcess();
+    QTextStream  stream(udevinfo);
+    QStringList  args;
+
+    args << "-q";
+    args << "name";
+    args << "-rp";
+    args << sysfs;
+    udevinfo->start("udevinfo", args);
+
+    if (!udevinfo->waitForStarted(2000 /*ms*/))
+    {
+        VERBOSE(VB_MEDIA, msg + ", Error - udevinfo failed to start!");
+        udevinfo->deleteLater();
+        return ret;
+    }
+
+    if (!udevinfo->waitForFinished(2000 /*ms*/))
+    {
+        VERBOSE(VB_MEDIA,
+                msg + ", Error - udevinfo failed to end! Terminating");
+        udevinfo->kill();
+        udevinfo->deleteLater();
+        return ret;
+    }
+
+    if ((print_verbose_messages & (VB_MEDIA|VB_EXTRA)) == (VB_MEDIA|VB_EXTRA))
+    {
+        udevinfo->setReadChannel(QProcess::StandardError);
+
+        while (!stream.atEnd())
+        {
+            VERBOSE(VB_MEDIA+VB_EXTRA,
+                    msg + " - udevinfo error...\n" + stream.readLine());
+        }
+    }
+
+    udevinfo->setReadChannel(QProcess::StandardOutput);
+
+    ret = stream.readLine();
+    if (ret.startsWith("device not found in database"))
+        return ret;
+
+    udevinfo->deleteLater();
+#endif // linux
+
+    VERBOSE(VB_MEDIA, msg + "->'" + ret + "'");
+    return ret;
+}
+
+/*
+ *  \brief Reads the list devices known to be CD or DVD devices.
+ *  \return list of CD and DVD device names.
+ */
+QStringList MediaMonitoruClibc::GetCDROMBlockDevices(void)
+{
+    QStringList l;
+
+#ifdef linux
+    QFile file("/proc/sys/dev/cdrom/info");
+    if (file.open(QIODevice::ReadOnly))
+    {
+        QString     line;
+        QTextStream stream(&file);
+        do
+        {
+            line = stream.readLine();
+            if (line.startsWith("drive name:"))
+            {
+                l = line.split('\t', QString::SkipEmptyParts);
+                l.pop_front();   // Remove 'drive name:' field
+                break;           // file should only contain one drive table?
+            }
+        }
+        while (!stream.atEnd());
+        file.close();
+    }
+#endif // linux
+
+    VERBOSE(VB_MEDIA, LOC + ":GetCDROMBlockDevices()->'" + l.join(", ") + "'");
+    return l;
+}
+
+static void LookupModel(MythMediaDevice* device)
+{
+    QString   desc;
+    QString   devname = device->getRealDevice();
+
+
+    // Given something like /dev/hda1, extract hda1
+    devname = devname.mid(5,5);
+
+
+#ifdef linux
+    if (devname.startsWith("hd"))  // IDE drive
+    {
+        QFile  file("/proc/ide/" + devname.left(3) + "/model");
+        if (file.open(QIODevice::ReadOnly))
+        {
+            QTextStream stream(&file);
+
+            desc.append(stream.readLine());
+            file.close();
+        }
+    }
+
+    if (devname.startsWith("scd"))     // scd0 doesn't appear in /sys/block,
+        devname.replace("scd", "sr");  // use sr0 instead
+
+    if (devname.startsWith("sd")       // SATA/USB/FireWire
+        || devname.startsWith("sr"))   // SCSI CD-ROM?
+    {
+        QString path = devname.prepend("/sys/block/");
+        path.append("/device/");
+
+        QFile  file(path + "vendor");
+        if (file.open(QIODevice::ReadOnly))
+        {
+            QTextStream stream(&file);
+
+            desc.append(stream.readLine());
+            desc.append(' ');
+            file.close();
+        }
+
+        file.setFileName(path + "model");
+        if (file.open(QIODevice::ReadOnly))
+        {
+            QTextStream stream(&file);
+
+            desc.append(stream.readLine());
+            desc.append(' ');
+            file.close();
+        }
+    }
+#endif
+
+    device->setDeviceModel(desc.toAscii().constData());
+}
+
+/**
+ * Given a media device, add it to our collection
+ */
+bool MediaMonitoruClibc::AddDevice(MythMediaDevice* pDevice)
+{
+    if ( ! pDevice )
+    {
+        VERBOSE(VB_IMPORTANT, "Error - MediaMonitoruClibc::AddDevice(null)");
+        return false;
+    }
+
+    // If the user doesn't want this device to be monitored, stop now:
+    if (shouldIgnore(pDevice))
+        return false;
+
+    QString path = pDevice->getDevicePath();
+    if (!path.length())
+    {
+        VERBOSE(VB_IMPORTANT,
+                "MediaMonitoruClibc::AddDevice() - empty device path.");
+        return false;
+    }
+
+    dev_t new_rdev;
+    struct stat sb;
+
+    if (stat(path.toLocal8Bit().constData(), &sb) < 0)
+    {
+        statError(":AddDevice()", path);
+        return false;
+    }
+    new_rdev = sb.st_rdev;
+
+    //
+    // Check if this is a duplicate of a device we have already added
+    //
+    QList<MythMediaDevice*>::const_iterator itr = m_Devices.begin();
+    for (; itr != m_Devices.end(); ++itr)
+    {
+        if (stat((*itr)->getDevicePath().toLocal8Bit().constData(), &sb) < 0)
+        {
+            statError(":AddDevice()", (*itr)->getDevicePath());
+            return false;
+        }
+
+        if (sb.st_rdev == new_rdev)
+        {
+            VERBOSE(VB_MEDIA, LOC + ":AddDevice() - not adding " + path
+                              + "\n                        "
+                                "because it appears to be a duplicate of "
+                              + (*itr)->getDevicePath());
+            return false;
+        }
+    }
+
+    LookupModel(pDevice);
+
+    QMutexLocker locker(&m_DevicesLock);
+
+    connect(pDevice, SIGNAL(statusChanged(MediaStatus, MythMediaDevice*)),
+            this, SLOT(mediaStatusChanged(MediaStatus, MythMediaDevice*)));
+    m_Devices.push_back( pDevice );
+    m_UseCount[pDevice] = 0;
+    VERBOSE(VB_MEDIA, LOC + ":AddDevice() - Added " + path);
+
+    return true;
+}
+
+// Given a mntent entry to a media device determine what type of device it is
+bool MediaMonitoruClibc::AddDevice(struct mntent * mep)
+{
+    QString devicePath( mep->mnt_fsname );
+    //cout << "AddDevice - " << devicePath << endl;
+
+    MythMediaDevice* pDevice = NULL;
+    struct stat sbuf;
+
+    bool is_supermount = false;
+    bool is_cdrom = false;
+
+    if (mep == NULL)
+       return false;
+
+      if (stat(mep->mnt_fsname, &sbuf) < 0)
+       return false;
+
+    //  Can it be mounted?
+    if ( ! ( ((strstr(mep->mnt_opts, "owner") &&
+        (sbuf.st_mode & S_IRUSR)) || strstr(mep->mnt_opts, "user")) &&
+        (strstr(mep->mnt_type, MNTTYPE_ISO9660) ||
+         strstr(mep->mnt_type, MNTTYPE_UDF) ||
+         strstr(mep->mnt_type, MNTTYPE_AUTO)) ) )
+    {
+        if (strstr(mep->mnt_opts, MNTTYPE_ISO9660) &&
+            strstr(mep->mnt_type, MNTTYPE_SUPERMOUNT))
+        {
+            is_supermount = true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+    if (strstr(mep->mnt_opts, MNTTYPE_ISO9660)  ||
+        strstr(mep->mnt_type, MNTTYPE_ISO9660) ||
+        strstr(mep->mnt_type, MNTTYPE_UDF)     ||
+        strstr(mep->mnt_type, MNTTYPE_AUTO))
+    {
+        is_cdrom = true;
+        //cout << "Device is a CDROM" << endl;
+    }
+
+    if (!is_supermount)
+    {
+        if (is_cdrom)
+            pDevice = MythCDROM::get(this, mep->mnt_fsname,
+                                     is_supermount, m_AllowEject);
+    }
+    else
+    {
+        char *dev;
+        int len = 0;
+        dev = strstr(mep->mnt_opts, SUPER_OPT_DEV);
+        dev += sizeof(SUPER_OPT_DEV)-1;
+        while (dev[len] != ',' && dev[len] != ' ' && dev[len] != 0)
+            len++;
+
+        if (dev[len] != 0)
+        {
+            char devstr[256];
+            strncpy(devstr, dev, len);
+            devstr[len] = 0;
+            if (is_cdrom)
+                pDevice = MythCDROM::get(this, devstr,
+                                         is_supermount, m_AllowEject);
+        }
+        else
+            return false;
+    }
+
+    if (pDevice)
+    {
+        pDevice->setMountPath(mep->mnt_dir);
+        if (pDevice->testMedia() == MEDIAERR_OK)
+        {
+            if (AddDevice(pDevice))
+                return true;
+        }
+        pDevice->deleteLater();
+    }
+
+    return false;
+}
+
+/**
+ *  \brief Creates MythMedia instances for sysfs removable media devices.
+ *
+ *   Block devices are represented as directories in sysfs with directories
+ *   for each partition underneath the parent device directory.
+ *
+ *   This function recursively calls itself to find all partitions on a block
+ *   device and creates a MythHDD instance for each partition found.  If no
+ *   partitions are found and the device is a CD or DVD device a MythCDROM
+ *   instance is created.  Otherwise a MythHDD instance is created for the
+ *   entire block device.
+ *
+ *  \param dev path to sysfs block device.
+ *  \param checkPartitions check for partitions on block device.
+ *  \return true if MythMedia instances are created.
+ */
+bool MediaMonitoruClibc::FindPartitions(const QString &dev, bool checkPartitions)
+{
+    MythMediaDevice* pDevice = NULL;
+
+    if (checkPartitions)
+    {
+        // check for partitions
+        QDir sysfs(dev);
+        sysfs.setFilter(QDir::Dirs);
+
+        bool found_partitions = false;
+        QStringList parts = sysfs.entryList();
+        for (QStringList::iterator pit = parts.begin();
+             pit != parts.end(); pit++)
+        {
+            if (*pit == "." || *pit == "..")
+                continue;
+
+            // skip some sysfs dirs that are _not_ sub-partitions
+            if (*pit == "device" || *pit == "holders" || *pit == "queue"
+                                 || *pit == "slaves"  || *pit == "subsystem")
+                continue;
+
+            found_partitions |= FindPartitions(
+                sysfs.absoluteFilePath(*pit), false);
+        }
+
+        // no partitions on block device, use main device
+        if (!found_partitions)
+            found_partitions |= FindPartitions(sysfs.absolutePath(), false);
+
+        return found_partitions;
+    }
+
+    QString device_file = GetDeviceFile(dev);
+
+    if (device_file.isNull())
+        return false;
+
+    QStringList cdroms = GetCDROMBlockDevices();
+
+    if (cdroms.contains(dev.section('/', -1)))
+    {
+        // found cdrom device
+            pDevice = MythCDROM::get(
+                this, device_file.toAscii().constData(), false, m_AllowEject);
+    }
+    else
+    {
+        // found block or partition device
+            pDevice = MythHDD::Get(
+                this, device_file.toAscii().constData(), false, false);
+    }
+
+    if (AddDevice(pDevice))
+        return true;
+
+    if (pDevice)
+        pDevice->deleteLater();
+
+    return false;
+}
+
+/**
+ *  \brief Checks the named pipe, kUDEV_FIFO, for
+ *         hotplug events from the udev system.
+ *   NOTE: Currently only Linux w/udev 0.71+ provides these events.
+ */
+void MediaMonitoruClibc::CheckDeviceNotifications(void)
+{
+    char buffer[256];
+    QString qBuffer = "";
+
+    if (!m_fifo)
+        return;
+
+    int size = read(m_fifo, buffer, 255);
+    while (size > 0)
+    {
+        // append buffer to QString
+        buffer[size] = '\0';
+        qBuffer.append(buffer);
+        size = read(m_fifo, buffer, 255);
+    }
+    const QStringList list = qBuffer.split('\n', QString::SkipEmptyParts);
+
+    QStringList::const_iterator it = list.begin();
+    for (; it != list.end(); it++)
+    {
+        if ((*it).startsWith("add"))
+        {
+            QString dev = (*it).section(' ', 1, 1);
+
+            if (CheckRemovable(dev))
+                FindPartitions(dev, true);
+        }
+        else if ((*it).startsWith("remove"))
+        {
+            RemoveDevice((*it).section(' ', 2, 2));
+        }
+    }
+}
diff -Naur mythtv-21776/libs/libmyth/mediamonitor-uclibc.h mythtv-21776.patch/libs/libmyth/mediamonitor-uclibc.h
--- mythtv-21776/libs/libmyth/mediamonitor-uclibc.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-21776.patch/libs/libmyth/mediamonitor-uclibc.h	2009-09-11 18:40:56.995580727 +0200
@@ -0,0 +1,32 @@
+#ifndef MYTH_MEDIA_MONITOR_UCLIBC_H
+#define MYTH_MEDIA_MONITOR_UCLIBC_H
+
+class MediaMonitoruClibc : public MediaMonitor
+{
+  public:
+    MediaMonitoruClibc(QObject *par, unsigned long interval, bool allowEject);
+    virtual void deleteLater(void);
+
+  protected:
+    ~MediaMonitoruClibc() {}
+
+    void CheckDevices(void);
+    void CheckDeviceNotifications(void);
+    bool CheckFileSystemTable(void);
+    bool CheckMountable(void);
+    bool CheckRemovable(const QString &dev);
+    bool FindPartitions(const QString &dev, bool checkPartitions);
+
+    virtual bool AddDevice(MythMediaDevice* pDevice);
+    bool AddDevice(struct mntent* mep);
+
+    QString GetDeviceFile(const QString &sysfs);
+
+    QStringList GetCDROMBlockDevices(void);
+
+  protected:
+    int                          m_fifo;
+    static const char           *kUDEV_FIFO;
+};
+
+#endif // MYTH_MEDIA_MONITOR_H
diff -Naur mythtv-21776/libs/libmyth/mythmediamonitor.cpp mythtv-21776.patch/libs/libmyth/mythmediamonitor.cpp
--- mythtv-21776/libs/libmyth/mythmediamonitor.cpp	2009-09-11 14:54:23.000000000 +0200
+++ mythtv-21776.patch/libs/libmyth/mythmediamonitor.cpp	2009-09-11 18:25:57.246579347 +0200
@@ -28,6 +28,9 @@
 #endif
 #if CONFIG_CYGWIN || defined(_WIN32)
 #include "mediamonitor-windows.h" 
+#endif
+#if defined(__UCLIBC__)
+#include "mediamonitor-uclibc.h" 
 #else
 #include "mediamonitor-unix.h" 
 #endif
@@ -68,7 +71,11 @@
   #if CONFIG_CYGWIN || defined(_WIN32)
     c_monitor = new MediaMonitorWindows(NULL, 500, true); 
   #else
+    #if defined(__UCLIBC__)
+        c_monitor = new MediaMonitoruClibc(NULL, 500, true);
+    #else
     c_monitor = new MediaMonitorUnix(NULL, 500, true);
+    #endif
   #endif
 #endif
 
diff -Naur mythtv-21776/settings.pro mythtv-21776.patch/settings.pro
--- mythtv-21776/settings.pro	2009-09-11 14:53:50.000000000 +0200
+++ mythtv-21776.patch/settings.pro	2009-09-11 19:08:00.642581672 +0200
@@ -7,6 +7,9 @@
         error("Must build against Qt4")
 }
 
+# uClibc support
+CONFIG += uclibc
+
 # Where binaries, includes and runtime assets are installed by 'make install'
 isEmpty( PREFIX ) {
     PREFIX = /usr/local
