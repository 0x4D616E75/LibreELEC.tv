From 71e5e9d6ff27305f9b4d7b0d2edacacdcd1a29dc Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 12:59:07 +0200
Subject: [PATCH 01/94] [AE] refactor audio settings page

---
 language/English/strings.po            |  72 +++++++---
 system/settings/settings.xml           | 231 +++++++++++++++++++--------------
 system/settings/win32.xml              |  20 +--
 xbmc/cores/AudioEngine/AEFactory.cpp   |  44 +++++--
 xbmc/cores/AudioEngine/AEFactory.h     |   4 +-
 xbmc/cores/AudioEngine/Interfaces/AE.h |  13 +-
 xbmc/cores/AudioEngine/Utils/AEUtil.h  |   9 --
 xbmc/settings/Settings.cpp             |   8 +-
 8 files changed, 251 insertions(+), 150 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 4d3e6ff..a403c5d 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -1393,17 +1393,17 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#337"
-msgid "Audio output"
+msgid "Output configuration"
 msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#338"
-msgid "Analogue"
+msgid "Fixed"
 msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#339"
-msgid "Optical/Coax"
+msgid "Optimized"
 msgstr ""
 
 msgctxt "#340"
@@ -1447,7 +1447,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#348"
-msgid "Multichannel LPCM capable receiver"
+msgid "Enable passthrough"
 msgstr ""
 
 #: system/settings/settings.xml
@@ -1780,12 +1780,12 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#420"
-msgid "HDMI"
+msgid "Best Match"
 msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#421"
-msgid "Stream silence when idle"
+msgid "Keep audio device alive"
 msgstr ""
 
 msgctxt "#422"
@@ -1937,7 +1937,10 @@ msgctxt "#457"
 msgid "Switch view"
 msgstr ""
 
-#empty string with id 458
+#: system/settings/settings.xml
+msgctxt "#458"
+msgid "Limit sampling rate (kHz)"
+msgstr ""
 
 msgctxt "#459"
 msgid "Subs"
@@ -12442,7 +12445,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#34111"
-msgid "When activated silence is output in order to keep alive receiver, otherwise sink is drained in idle state"
+msgid "When enabled very quiet noise is sent (for a given period of time) to the audio output device when XBMC is idle, this keeps the receiving device alive ensuring any new sounds are not missed. This might block concurrent applications from outputting sound."
 msgstr ""
 
 #empty strings from id 34112 to 34119
@@ -12471,8 +12474,38 @@ msgctxt "#34123"
 msgid "Never"
 msgstr ""
 
-#empty strings from id 34124 to 34200
-#34124-34200 reserved for future use
+#. SPDIF max sampling rate
+#: system/settings/settings.xml
+msgctxt "#34124"
+msgid "44.1"
+msgstr ""
+
+#. SPDIF max sampling rate
+#: system/settings/settings.xml
+msgctxt "#34125"
+msgid "48.0"
+msgstr ""
+
+#. SPDIF max sampling rate
+#: system/settings/settings.xml
+msgctxt "#34126"
+msgid "88.2"
+msgstr ""
+
+#. SPDIF max sampling rate
+#: system/settings/settings.xml
+msgctxt "#34127"
+msgid "96.0"
+msgstr ""
+
+#. SPDIF max sampling rate
+#: system/settings/settings.xml
+msgctxt "#34128"
+msgid "192.0"
+msgstr ""
+
+#empty strings from id 34129 to 34200
+#34129-34200 reserved for future use
 
 #: xbmc\PlayListPlayer.cpp
 msgctxt "#34201"
@@ -13215,7 +13248,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36169"
-msgid "Resampling and other sound processing quality. Low quality is fast, higher quality will consume more CPU."
+msgid "Select the quality of resampling when audio output needs to be at a different sampling rate from that used by the source. Low quality is fast and will have minimal impact on system resources such as the use of the CPU, Medium & High will use progressively more system resources."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -14175,12 +14208,12 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36361"
-msgid "Type of connection to the audio equipment."
+msgid "Select how audio is output. Fixed - the properties of the audio output are fixed to the specified sampling rate & speaker configuration; Best Match - the properties of the audio output are set to match the properties of the audio source where possible if not the closest match is chosen; Optimized - the properties of the audio output are not changed during playback."
 msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36362"
-msgid "Select your physical speaker layout."
+msgid "Select the maximum number of audio channels/speakers available for audio decoded. On OS-X systems where optical/coax digital outputs are used this must be set to 2.0"
 msgstr ""
 
 #: system/settings/settings.xml
@@ -14190,7 +14223,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36364"
-msgid "Upmix 2 channel stereo sources so the number of audio channels matches the number of speakers."
+msgid "When enabled upmix 2 channel stereo sources to the number of audio channels specified by the Speaker Configuration."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -14210,7 +14243,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36368"
-msgid "Select this option if your receiver is capable of decoding LPCM streams."
+msgid "Select to enable the passthrough audio options for playback of encoded audio such as Dolby Digital."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -14225,12 +14258,12 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36371"
-msgid "Select the device you use to play audio decoded by XBMC such as mp3's and FLAC."
+msgid "Select the device to be used for playback of audio that has been decoded such as mp3"
 msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36372"
-msgid "Select the device you use to play encoded formats, these are any of the formats checked above in the 'capable receiver' options."
+msgid "Select the device to be used for playback of encoded formats, these are any of the formats below in the 'capable receiver' options."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -14556,7 +14589,10 @@ msgctxt "#36522"
 msgid "Use preferred mode"
 msgstr ""
 
-#empty string with id 36523
+#: system/settings/settings.xml
+msgctxt "#36523"
+msgid "Maximum sampling rate for spdif or sampling rate for fixed output configuration"
+msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#36524"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 528c090..f310b96 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1972,17 +1972,20 @@
     </category>
     <category id="audiooutput" label="772" help="36360">
       <group id="1">
-        <setting id="audiooutput.mode" type="integer" label="337" help="36361">
-          <level>1</level>
-          <default>0</default> <!-- AUDIO_ANALOG -->
+        <setting id="audiooutput.audiodevice" type="string" label="545" help="36371">
+          <level>0</level>
+          <default>Default</default> <!-- will be properly set on startup -->
           <constraints>
-            <options>audiooutputmodes</options>
+            <options>audiodevices</options>
           </constraints>
-          <control type="spinner" format="string" />
+          <control type="list" format="string" />
         </setting>
         <setting id="audiooutput.channels" type="integer" label="34100" help="36362">
           <level>0</level>
           <default>1</default> <!-- AE_CH_LAYOUT_2_0 -->
+          <dependencies>
+            <dependency type="visible" on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.channels</dependency>
+          </dependencies>
           <constraints>
             <options>
               <option label="34101">1</option> <!-- AE_CH_LAYOUT_2_0 -->
@@ -1997,14 +2000,48 @@
               <option label="34110">10</option> <!-- AE_CH_LAYOUT_7_1 -->
             </options>
           </constraints>
-          <updates>
-            <update type="rename">audiooutput.channellayout</update>
-          </updates>
           <control type="spinner" format="string" />
         </setting>
-        <setting id="audiooutput.normalizelevels" type="boolean" label="346" help="36363">
+        <setting id="audiooutput.config" type="integer" label="337" help="36361">
           <level>2</level>
-          <default>true</default>
+          <default>2</default>
+          <constraints>
+            <options>
+              <option label="338">1</option>
+              <option label="339">2</option>
+              <option label="420">3</option>
+            </options>
+          </constraints>
+          <control type="spinner" format="integer" />
+        </setting>
+        <setting id="audiooutput.samplerate" type="integer" label="458" help="36523">
+          <level>2</level>
+          <default>48000</default>
+          <dependencies>
+            <dependency type="visible">
+              <and>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.samplerate</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.samplerate</condition>
+              </and>
+            </dependency>  
+          </dependencies>
+          <constraints>
+            <options>
+              <option label="34124">44100</option>
+              <option label="34125">48000</option>
+              <option label="34126">88200</option>
+              <option label="34127">96000</option>
+              <option label="34128">192000</option>
+            </options>
+          </constraints>
+          <control type="spinner" format="integer" />
+        </setting>
+        <setting id="audiooutput.stereoupmix" type="boolean" label="252" help="36364">
+          <level>2</level>
+          <default>false</default>
+          <dependencies>
+            <dependency type="visible" setting="audiooutput.channels" operator="!is">1</dependency>
+          </dependencies>
         </setting>
         <setting id="audiooutput.processquality" type="integer" label="13505" help="36169">
           <requirement>HAS_AE_QUALITY_LEVELS</requirement>
@@ -2015,128 +2052,130 @@
           </constraints>
           <control type="spinner" format="string" />
         </setting>
-        <setting id="audiooutput.stereoupmix" type="boolean" label="252" help="36364">
-          <level>2</level>
-          <default>false</default>
+        <setting id="audiooutput.streamsilence" type="boolean" label="421" help="34111">
+          <level>1</level>
+          <requirement>audiosupportsdrain</requirement>
+          <default>true</default>
+        </setting>
+      </group>
+      <group id="2">
+        <setting id="audiooutput.guisoundmode" type="integer" label="34120" help="36373">
+          <level>0</level>
+          <default>1</default> <!-- AE_SOUND_IDLE -->
+          <constraints>
+            <options>
+              <option label="34121">1</option> <!-- AE_SOUND_IDLE -->
+              <option label="34122">2</option> <!-- AE_SOUND_ALWAYS -->
+              <option label="34123">0</option> <!-- AE_SOUND_OFF -->
+            </options>
+          </constraints>
+          <control type="spinner" format="string" />
         </setting>
-        <setting id="audiooutput.ac3passthrough" type="boolean" parent="audiooutput.mode" label="364" help="36365">
+      </group>
+      <group id="3">
+        <setting id="audiooutput.passthrough" type="boolean" label="348" help="36368">
           <level>2</level>
-          <default>true</default>
+          <default>false</default>
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.passthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
             </dependency>
           </dependencies>
         </setting>
-        <setting id="audiooutput.eac3passthrough" type="boolean" parent="audiooutput.mode" label="448" help="37016">
+        <setting id="audiooutput.passthroughdevice" type="string" label="546" help="36372">
           <level>2</level>
-          <default>true</default>
+          <default>Default</default> <!-- will be properly set on startup -->
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.passthrough">audiooutput.passthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
             </dependency>
           </dependencies>
-        </setting>
-        <setting id="audiooutput.dtspassthrough" type="boolean" parent="audiooutput.mode" label="254" help="36366">
+          <constraints>
+            <options>audiodevicespassthrough</options>
+          </constraints>
+          <control type="list" format="string" />
+        </setting>        
+        <setting id="audiooutput.ac3passthrough" type="boolean" label="364" help="36365">
           <level>2</level>
           <default>true</default>
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
             </dependency>
           </dependencies>
         </setting>
-        <setting id="audiooutput.passthroughaac" type="boolean" parent="audiooutput.mode" label="299" help="36367">
+        <setting id="audiooutput.eac3passthrough" type="boolean" label="448" help="37016">
           <level>2</level>
           <default>false</default>
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
             </dependency>
-          </dependencies>
+          </dependencies>      
         </setting>
-        <setting id="audiooutput.multichannellpcm" type="boolean" parent="audiooutput.mode" label="348" help="36368">
+        <setting id="audiooutput.dtspassthrough" type="boolean" label="254" help="36366">
           <level>2</level>
-          <default>true</default>
+          <default>false</default>
           <dependencies>
-            <dependency type="enable" setting="audiooutput.mode">2</dependency> <!-- AUDIO_HDMI -->
-          </dependencies>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
+            </dependency>
+          </dependencies>       
         </setting>
-        <setting id="audiooutput.truehdpassthrough" type="boolean" parent="audiooutput.mode" label="349" help="36369">
+        <setting id="audiooutput.passthroughaac" type="boolean" label="299" help="36367">
           <level>2</level>
-          <default>true</default>
+          <default>false</default>
           <dependencies>
-            <dependency type="enable" setting="audiooutput.mode">2</dependency> <!-- AUDIO_HDMI -->
-          </dependencies>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.passthrough">audiooutput.passthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
+            </dependency>
+          </dependencies>     
         </setting>
-        <setting id="audiooutput.dtshdpassthrough" type="boolean" parent="audiooutput.mode" label="347" help="36370">
+        <setting id="audiooutput.truehdpassthrough" type="boolean" label="349" help="36369">
           <level>2</level>
-          <default>true</default>
+          <default>false</default>
           <dependencies>
-            <dependency type="enable">
+            <dependency type="visible">
               <and>
-                <condition setting="audiooutput.dtspassthrough">true</condition>
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.truehdpassthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.passthroughdevice">audiooutput.truehdpassthrough</condition>
               </and>
             </dependency>
-          </dependencies>
+          </dependencies>      
         </setting>
-        <setting id="audiooutput.streamsilence" type="boolean" label="421" help="34111">
+        <setting id="audiooutput.dtshdpassthrough" type="boolean" label="347" help="36370">
           <level>2</level>
-          <requirement>audiosupportsdrain</requirement>
-          <default>true</default>
-        </setting>
-      </group>
-      <group id="2">
-        <setting id="audiooutput.audiodevice" type="string" label="545" help="36371">
-          <level>2</level>
-          <default>Default</default> <!-- will be properly set on startup -->
-          <constraints>
-            <options>audiodevices</options>
-          </constraints>
-          <control type="spinner" format="string" />
-        </setting>
-        <setting id="audiooutput.passthroughdevice" type="string" label="546" help="36372">
-          <level>2</level>
-          <default>Default</default> <!-- will be properly set on startup -->
-          <constraints>
-            <options>audiodevicespassthrough</options>
-          </constraints>
+          <default>false</default>
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition setting="audiooutput.passthrough" operator="is">true</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.dtshdpassthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.passthroughdevice">audiooutput.dtshdpassthrough</condition>
+              </and>
             </dependency>
-          </dependencies>
-          <control type="spinner" format="string" />
-        </setting>
-      </group>
-      <group id="3">
-        <setting id="audiooutput.guisoundmode" type="integer" label="34120" help="36373">
-          <level>0</level>
-          <default>1</default> <!-- AE_SOUND_IDLE -->
-          <constraints>
-            <options>
-              <option label="34121">1</option> <!-- AE_SOUND_IDLE -->
-              <option label="34122">2</option> <!-- AE_SOUND_ALWAYS -->
-              <option label="34123">0</option> <!-- AE_SOUND_OFF -->
-            </options>
-          </constraints>
-          <control type="spinner" format="string" />
+          </dependencies>      
         </setting>
       </group>
     </category>
diff --git a/system/settings/win32.xml b/system/settings/win32.xml
index bb716a2..acf63d1 100644
--- a/system/settings/win32.xml
+++ b/system/settings/win32.xml
@@ -40,15 +40,17 @@
       </group>
     </category>
     <category id="audiooutput" label="772" help="36360">
-      <group id="2">
+      <group id="1">
         <setting id="audiooutput.audiodevice" type="string" label="545" help="36371">
-          <level>2</level>
+          <level>1</level>
           <default>DirectSound:default</default>
           <constraints>
             <options>audiodevices</options>
           </constraints>
-          <control type="spinner" format="string" />
+          <control type="list" format="string" />
         </setting>
+      </group>
+      <group id="3">
         <setting id="audiooutput.passthroughdevice" type="string" label="546" help="36372">
           <level>2</level>
           <default>DirectSound:default</default>
@@ -56,14 +58,14 @@
             <options>audiodevicespassthrough</options>
           </constraints>
           <dependencies>
-            <dependency type="enable">
-              <or>
-                <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-              </or>
+            <dependency type="visible">
+              <and>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.passthrough</condition>
+                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
+              </and>
             </dependency>
           </dependencies>
-          <control type="spinner" format="string" />
+          <control type="list" format="string" />
         </setting>
       </group>
     </category>
diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 16fc708..3092898 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -40,6 +40,7 @@
 
 #include "guilib/LocalizeStrings.h"
 #include "settings/Setting.h"
+#include "settings/Settings.h"
 #include "utils/StringUtils.h"
 
 IAE* CAEFactory::AE = NULL;
@@ -238,10 +239,32 @@ void CAEFactory::VerifyOutputDevice(std::string &device, bool passthrough)
   return "default";
 }
 
-bool CAEFactory::SupportsRaw()
+bool CAEFactory::SupportsRaw(AEDataFormat format)
 {
+  // check if passthrough is enabled
+  if (!CSettings::Get().GetBool("audiooutput.passthrough"))
+    return false;
+
+  // fixed config disabled passthrough
+  if (CSettings::Get().GetInt("audiooutput.config") == AE_CONFIG_FIXED)
+    return false;
+
+  // check if the format is enabled in settings
+  if (format == AE_FMT_AC3 && !CSettings::Get().GetBool("audiooutput.ac3passthrough"))
+    return false;
+  if (format == AE_FMT_DTS && !CSettings::Get().GetBool("audiooutput.dtspassthrough"))
+    return false;
+  if (format == AE_FMT_EAC3 && !CSettings::Get().GetBool("audiooutput.eac3passthrough"))
+    return false;
+  if (format == AE_FMT_AAC && !CSettings::Get().GetBool("audiooutput.passthroughaac"))
+    return false;
+  if (format == AE_FMT_TRUEHD && !CSettings::Get().GetBool("audiooutput.truehdpassthrough"))
+    return false;
+  if (format == AE_FMT_DTSHD && !CSettings::Get().GetBool("audiooutput.dtshdpassthrough"))
+    return false;
+
   if(AE)
-    return AE->SupportsRaw();
+    return AE->SupportsRaw(format);
 
   return false;
 }
@@ -339,15 +362,6 @@ void CAEFactory::SettingOptionsAudioDevicesPassthroughFiller(const CSetting *set
   SettingOptionsAudioDevicesFillerGeneral(setting, list, current, true);
 }
 
-void CAEFactory::SettingOptionsAudioOutputModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
-{
-  list.push_back(std::make_pair(g_localizeStrings.Get(338), AUDIO_ANALOG));
-#if !defined(TARGET_RASPBERRY_PI)
-  list.push_back(std::make_pair(g_localizeStrings.Get(339), AUDIO_IEC958));
-#endif
-  list.push_back(std::make_pair(g_localizeStrings.Get(420), AUDIO_HDMI));
-}
-
 void CAEFactory::SettingOptionsAudioQualityLevelsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
 {
   if (!AE)
@@ -410,3 +424,11 @@ void CAEFactory::UnregisterAudioCallback()
   if (AE)
     AE->UnregisterAudioCallback();
 }
+
+bool CAEFactory::IsSettingVisible(const std::string &condition, const std::string &value, const std::string &settingId)
+{
+  if (settingId.empty() || value.empty() || !AE)
+    return false;
+
+  return AE->IsSettingVisible(value);
+}
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index e3e8a3a..b007627 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -54,7 +54,7 @@ class CAEFactory
   static void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
   static void VerifyOutputDevice(std::string &device, bool passthrough);
   static std::string GetDefaultDevice(bool passthrough);
-  static bool SupportsRaw();
+  static bool SupportsRaw(AEDataFormat format);
   static bool SupportsDrain();
 
   /**
@@ -74,8 +74,8 @@ class CAEFactory
 
   static void SettingOptionsAudioDevicesFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
   static void SettingOptionsAudioDevicesPassthroughFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
-  static void SettingOptionsAudioOutputModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsAudioQualityLevelsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static bool IsSettingVisible(const std::string &condition, const std::string &value, const std::string &settingId);
 
   static void RegisterAudioCallback(IAudioCallback* pCallback);
   static void UnregisterAudioCallback();
diff --git a/xbmc/cores/AudioEngine/Interfaces/AE.h b/xbmc/cores/AudioEngine/Interfaces/AE.h
index b1f3008..e60aa66 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AE.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AE.h
@@ -41,6 +41,11 @@
 #define AE_SOUND_IDLE   1 /* only play sounds while no streams are running */
 #define AE_SOUND_ALWAYS 2 /* always play sounds */
 
+/* config options */
+#define AE_CONFIG_FIXED 1
+#define AE_CONFIG_AUTO  2
+#define AE_CONFIG_MATCH 3
+
 enum AEQuality
 {
   AE_QUALITY_UNKNOWN    = -1, /* Unset, unknown or incorrect quality level */
@@ -198,7 +203,7 @@ class IAE
    * @see CAEPackIEC61937::CAEPackIEC61937()
    * @returns true if the AudioEngine is capable of RAW output
    */
-  virtual bool SupportsRaw() { return false; }
+  virtual bool SupportsRaw(AEDataFormat format) { return false; }
 
    /**
    * Returns true if the AudioEngine supports drain mode which is not streaming silence when idle
@@ -215,5 +220,11 @@ class IAE
    * @return true if specified quality level is supported, otherwise false
    */
   virtual bool SupportsQualityLevel(enum AEQuality level) { return false; }
+
+  /**
+   * AE decides whether this settings should be displayed
+   * @return true if AudioEngine wants to display this setting
+   */
+  virtual bool IsSettingVisible(const std::string &settingId) {return false; }
 };
 
diff --git a/xbmc/cores/AudioEngine/Utils/AEUtil.h b/xbmc/cores/AudioEngine/Utils/AEUtil.h
index ef67b34..c6a3184 100644
--- a/xbmc/cores/AudioEngine/Utils/AEUtil.h
+++ b/xbmc/cores/AudioEngine/Utils/AEUtil.h
@@ -49,15 +49,6 @@
   #define MEMALIGN(b, x) __declspec(align(b)) x
 #endif
 
-#define AUDIO_IS_BITSTREAM(x) ((x) == AUDIO_IEC958 || (x) == AUDIO_HDMI)
-
-enum AudioOutputs
-{
-  AUDIO_ANALOG  = 0,
-  AUDIO_IEC958,
-  AUDIO_HDMI
-};
-
 // AV sync options
 enum AVSync
 {
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index a8d82af..41e5d04 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -372,7 +372,6 @@ void CSettings::Uninitialize()
   m_settingsManager->UnregisterSettingOptionsFiller("aequalitylevels");
   m_settingsManager->UnregisterSettingOptionsFiller("audiodevices");
   m_settingsManager->UnregisterSettingOptionsFiller("audiodevicespassthrough");
-  m_settingsManager->UnregisterSettingOptionsFiller("audiooutputmodes");
   m_settingsManager->UnregisterSettingOptionsFiller("charsets");
   m_settingsManager->UnregisterSettingOptionsFiller("epgguideviews");
   m_settingsManager->UnregisterSettingOptionsFiller("fontheights");
@@ -687,7 +686,6 @@ void CSettings::InitializeOptionFillers()
   m_settingsManager->RegisterSettingOptionsFiller("aequalitylevels", CAEFactory::SettingOptionsAudioQualityLevelsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("audiodevices", CAEFactory::SettingOptionsAudioDevicesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("audiodevicespassthrough", CAEFactory::SettingOptionsAudioDevicesPassthroughFiller);
-  m_settingsManager->RegisterSettingOptionsFiller("audiooutputmodes", CAEFactory::SettingOptionsAudioOutputModesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("charsets", CCharsetConverter::SettingOptionsCharsetsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("epgguideviews", PVR::CGUIWindowPVRGuide::SettingOptionsEpgGuideViewFiller);
   m_settingsManager->RegisterSettingOptionsFiller("fonts", GUIFontManager::SettingOptionsFontsFiller);
@@ -824,6 +822,7 @@ void CSettings::InitializeConditions()
   m_settingsManager->AddCondition("profilehassettingslocked", ProfileHasSettingsLocked);
   m_settingsManager->AddCondition("profilehasvideoslocked", ProfileHasVideosLocked);
   m_settingsManager->AddCondition("profilelockmode", ProfileLockMode);
+  m_settingsManager->AddCondition("aesettingvisible", CAEFactory::IsSettingVisible);
 }
 
 void CSettings::InitializeISettingsHandlers()
@@ -887,7 +886,9 @@ void CSettings::InitializeISettingCallbacks()
   m_settingsManager->RegisterCallback(&CStereoscopicsManager::Get(), settingSet);
 
   settingSet.clear();
-  settingSet.insert("audiooutput.mode");
+  settingSet.insert("audiooutput.config");
+  settingSet.insert("audiooutput.samplerate");
+  settingSet.insert("audiooutput.passthrough");
   settingSet.insert("audiooutput.channels");
   settingSet.insert("audiooutput.processquality");
   settingSet.insert("audiooutput.guisoundmode");
@@ -898,7 +899,6 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert("audiooutput.passthroughaac");
   settingSet.insert("audiooutput.truehdpassthrough");
   settingSet.insert("audiooutput.dtshdpassthrough");
-  settingSet.insert("audiooutput.multichannellpcm");
   settingSet.insert("audiooutput.audiodevice");
   settingSet.insert("audiooutput.passthroughdevice");
   settingSet.insert("audiooutput.streamsilence");
-- 
1.8.4


From c3991e9b717f2e140d26f9d981ce19572c41091b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:01:14 +0200
Subject: [PATCH 02/94] dvdplayer: adapt to changes in audio settings

---
 .../DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp   | 28 ++++----------------
 .../Audio/DVDAudioCodecPassthroughFFmpeg.cpp       | 17 ++++++------
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 30 ++++++++++------------
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h   |  2 +-
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp            | 10 ++------
 5 files changed, 31 insertions(+), 56 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
index ebb8138..5338c71 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
@@ -40,29 +40,11 @@
 
 bool CDVDAudioCodecPassthrough::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  /* dont open if AE doesnt support RAW */
-  if (!CAEFactory::SupportsRaw())
-    return false;
-
-  bool bSupportsAC3Out    = false;
-  bool bSupportsEAC3Out   = false;
-  bool bSupportsDTSOut    = false;
-  bool bSupportsTrueHDOut = false;
-  bool bSupportsDTSHDOut  = false;
-
-  int audioMode = CSettings::Get().GetInt("audiooutput.mode");
-  if (AUDIO_IS_BITSTREAM(audioMode))
-  {
-    bSupportsAC3Out = CSettings::Get().GetBool("audiooutput.ac3passthrough");
-    bSupportsEAC3Out = CSettings::Get().GetBool("audiooutput.eac3passthrough");
-    bSupportsDTSOut = CSettings::Get().GetBool("audiooutput.dtspassthrough");
-  }
-
-  if (audioMode == AUDIO_HDMI)
-  {
-    bSupportsTrueHDOut = CSettings::Get().GetBool("audiooutput.truehdpassthrough");
-    bSupportsDTSHDOut  = CSettings::Get().GetBool("audiooutput.dtshdpassthrough" ) && bSupportsDTSOut;
-  }
+  bool bSupportsAC3Out    = CAEFactory::SupportsRaw(AE_FMT_AC3);
+  bool bSupportsEAC3Out   = CAEFactory::SupportsRaw(AE_FMT_EAC3);
+  bool bSupportsDTSOut    = CAEFactory::SupportsRaw(AE_FMT_DTS);
+  bool bSupportsTrueHDOut = CAEFactory::SupportsRaw(AE_FMT_TRUEHD);
+  bool bSupportsDTSHDOut  = CAEFactory::SupportsRaw(AE_FMT_DTSHD);
 
   /* only get the dts core from the parser if we don't support dtsHD */
   m_info.SetCoreOnly(!bSupportsDTSHDOut);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
index a9f3d40..f49b5b5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
@@ -25,6 +25,7 @@
 #include "settings/MediaSettings.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 //These values are forced to allow spdif out
 #define OUT_SAMPLESIZE 16
@@ -293,17 +294,17 @@ bool CDVDAudioCodecPassthroughFFmpeg::SupportsFormat(CDVDStreamInfo &hints)
 
 bool CDVDAudioCodecPassthroughFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  int audioMode = CSettings::Get().GetInt("audiooutput.mode");
-
   // TODO - move this stuff somewhere else
-  if (AUDIO_IS_BITSTREAM(audioMode))
+  bool m_bSupportsAC3Out    = CAEFactory::SupportsRaw(AE_FMT_AC3);
+  bool m_bSupportsEAC3Out   = CAEFactory::SupportsRaw(AE_FMT_EAC3);
+  bool m_bSupportsDTSOut    = CAEFactory::SupportsRaw(AE_FMT_DTS);
+
+  if ((hints.codec == AV_CODEC_ID_AC3 && !m_bSupportsAC3Out) ||
+      (hints.codec == AV_CODEC_ID_EAC3 && !m_bSupportsEAC3Out) ||
+      (hints.codec == AV_CODEC_ID_DTS && !m_bSupportsDTSOut))
   {
-    m_bSupportsAC3Out = CSettings::Get().GetBool("audiooutput.ac3passthrough");
-    m_bSupportsDTSOut = CSettings::Get().GetBool("audiooutput.dtspassthrough");
-    m_bSupportsAACOut = CSettings::Get().GetBool("audiooutput.passthroughaac");
-  }
-  else
     return false;
+  }
 
   // TODO - this is only valid for video files, and should be moved somewhere else
   if( hints.channels == 2 && CMediaSettings::Get().GetCurrentVideoSettings().m_OutputToAllSpeakers )
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 183e2c5..4864e47 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -325,28 +325,26 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
   return NULL;
 }
 
-CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool passthrough /* = true */)
+CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint)
 {
   CDVDAudioCodec* pCodec = NULL;
   CDVDCodecOptions options;
 
-  if (passthrough)
-  {
+  // try passthrough first
 #if defined(TARGET_DARWIN_OSX) || defined(TARGET_DARWIN_IOS)
-    switch(hint.codec)
-    {
-      case AV_CODEC_ID_AC3:
-      case AV_CODEC_ID_DTS:
-        pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options );
-        if( pCodec ) return pCodec;
-        break;
-      default:
-        break;      
-    }
-#endif
-    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
-    if( pCodec ) return pCodec;
+  switch(hint.codec)
+  {
+    case AV_CODEC_ID_AC3:
+    case AV_CODEC_ID_DTS:
+      pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options );
+      if( pCodec ) return pCodec;
+      break;
+    default:
+      break;
   }
+#endif
+  pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
+  if( pCodec ) return pCodec;
 
   switch (hint.codec)
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
index f7c03da..f7ce44c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
@@ -36,7 +36,7 @@ class CDVDFactoryCodec
 {
 public:
   static CDVDVideoCodec* CreateVideoCodec(CDVDStreamInfo &hint, unsigned int surfaces = 0, const std::vector<ERenderFormat>& formats = std::vector<ERenderFormat>());
-  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint, bool passthrough = true );
+  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint );
   static CDVDOverlayCodec* CreateOverlayCodec(CDVDStreamInfo &hint );
 
   static CDVDAudioCodec* OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index 38a53e7..df3df14 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -145,10 +145,8 @@ class CDVDMsgAudioCodecChange : public CDVDMsg
 
 bool CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints )
 {
-  bool passthrough = AUDIO_IS_BITSTREAM(CSettings::Get().GetInt("audiooutput.mode"));
-
   CLog::Log(LOGNOTICE, "Finding audio codec for: %i", hints.codec);
-  CDVDAudioCodec* codec = CDVDFactoryCodec::CreateAudioCodec(hints, passthrough);
+  CDVDAudioCodec* codec = CDVDFactoryCodec::CreateAudioCodec(hints);
   if( !codec )
   {
     CLog::Log(LOGERROR, "Unsupported audio codec");
@@ -868,12 +866,8 @@ void CDVDPlayerAudio::WaitForBuffers()
 
 bool CDVDPlayerAudio::SwitchCodecIfNeeded()
 {
-  // check if passthrough is disabled
-  if (!AUDIO_IS_BITSTREAM(CSettings::Get().GetInt("audiooutput.mode")))
-    return false;
-
   CLog::Log(LOGDEBUG, "CDVDPlayerAudio: Sample rate changed, checking for passthrough");
-  CDVDAudioCodec *codec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, true);
+  CDVDAudioCodec *codec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo);
   if (!codec || codec->NeedPassthrough() == m_pAudioCodec->NeedPassthrough()) {
     // passthrough state has not changed
     delete codec;
-- 
1.8.4


From d6d239ed48ad69644fc267c3d57b4937498b2fd0 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:02:24 +0200
Subject: [PATCH 03/94] paplayer: adapt to changes in audio settings

---
 xbmc/cores/paplayer/DVDPlayerCodec.cpp             |  3 +--
 xbmc/cores/playercorefactory/PlayerCoreFactory.cpp | 10 +++-------
 2 files changed, 4 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/paplayer/DVDPlayerCodec.cpp b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
index 355589f..5bd7ec1 100644
--- a/xbmc/cores/paplayer/DVDPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
@@ -145,8 +145,7 @@ bool DVDPlayerCodec::Init(const CStdString &strFile, unsigned int filecache)
 
   CDVDStreamInfo hint(*pStream, true);
 
-  bool passthrough = AUDIO_IS_BITSTREAM(CSettings::Get().GetInt("audiooutput.mode"));
-  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, passthrough);
+  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint);
   if (!m_pAudioCodec)
   {
     CLog::Log(LOGERROR, "%s: Could not create audio codec", __FUNCTION__);
diff --git a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
index 8e7a0f5..16319b9 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
+++ b/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
@@ -37,6 +37,7 @@
 #include "PlayerCoreConfig.h"
 #include "PlayerSelectionRule.h"
 #include "guilib/LocalizeStrings.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 #define PLAYERCOREFACTORY_XML "playercorefactory.xml"
 
@@ -189,13 +190,8 @@ void CPlayerCoreFactory::GetPlayers( const CFileItem& item, VECPLAYERCORES &vecC
 
     if (bAdd)
     {
-      if( CSettings::Get().GetInt("audiooutput.mode") == AUDIO_ANALOG )
-      {
-        CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: adding PAPlayer (%d)", EPC_PAPLAYER);
-        vecCores.push_back(EPC_PAPLAYER);
-      }
-      else if (url.GetFileType().Equals("ac3") 
-            || url.GetFileType().Equals("dts"))
+      if ((url.GetFileType().Equals("ac3") && !CAEFactory::SupportsRaw(AE_FMT_AC3))
+            || (url.GetFileType().Equals("dts") && !CAEFactory::SupportsRaw(AE_FMT_DTS)))
       {
         CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: adding DVDPlayer (%d)", EPC_DVDPLAYER);
         vecCores.push_back(EPC_DVDPLAYER);
-- 
1.8.4


From 2c9ebb2d3888527e2bccaee7fa0b1d956b8f8109 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:03:27 +0200
Subject: [PATCH 04/94] GUIDialogAudioSettings: adapt to changes in audio
 settings

---
 .../video/dialogs/GUIDialogAudioSubtitleSettings.cpp | 20 ++++++--------------
 xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.h  |  2 +-
 2 files changed, 7 insertions(+), 15 deletions(-)

diff --git a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
index 0dd0075..5d0f2ef 100644
--- a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
@@ -96,14 +96,13 @@ void CGUIDialogAudioSubtitleSettings::CreateSettings()
   if (SupportsAudioFeature(IPC_AUD_SELECT_STREAM))
     AddAudioStreams(AUDIO_SETTINGS_STREAM);
 
-  // only show stuff available in digital mode if we have digital output
+  // TODO: remove this setting
   if (SupportsAudioFeature(IPC_AUD_OUTPUT_STEREO))
-    AddBool(AUDIO_SETTINGS_OUTPUT_TO_ALL_SPEAKERS, 252, &CMediaSettings::Get().GetCurrentVideoSettings().m_OutputToAllSpeakers, AUDIO_IS_BITSTREAM(CSettings::Get().GetInt("audiooutput.mode")));
+    AddBool(AUDIO_SETTINGS_OUTPUT_TO_ALL_SPEAKERS, 252, &CMediaSettings::Get().GetCurrentVideoSettings().m_OutputToAllSpeakers, true);
 
-  int settings[3] = { 338, 339, 420 }; //ANALOG, IEC958, HDMI
-  m_outputmode = CSettings::Get().GetInt("audiooutput.mode");
+  m_outputmode = CSettings::Get().GetBool("audiooutput.passthrough");
   if (SupportsAudioFeature(IPC_AUD_SELECT_OUTPUT))
-    AddSpin(AUDIO_SETTINGS_DIGITAL_ANALOG, 337, &m_outputmode, 3, settings);
+    AddBool(AUDIO_SETTINGS_DIGITAL_ANALOG, 348, &m_outputmode);
 
   AddSeparator(7);
   m_subtitleVisible = g_application.m_pPlayer->GetSubtitleVisible();
@@ -275,16 +274,9 @@ void CGUIDialogAudioSubtitleSettings::OnSettingChanged(SettingInfo &setting)
   }
   else if (setting.id == AUDIO_SETTINGS_DIGITAL_ANALOG)
   {
-    bool bitstream = false;
+    CSettings::Get().SetBool("audiooutput.passthrough", !m_outputmode);
 
-    switch(m_outputmode)
-    {
-      case 0: CSettings::Get().SetInt("audiooutput.mode", AUDIO_ANALOG ); break;
-      case 1: CSettings::Get().SetInt("audiooutput.mode", AUDIO_IEC958 ); bitstream = true; break;
-      case 2: CSettings::Get().SetInt("audiooutput.mode", AUDIO_HDMI   ); bitstream = true; break;
-    }
-
-    EnableSettings(AUDIO_SETTINGS_OUTPUT_TO_ALL_SPEAKERS, bitstream);
+    EnableSettings(AUDIO_SETTINGS_OUTPUT_TO_ALL_SPEAKERS, true);
     EnableSettings(AUDIO_SETTINGS_VOLUME, !g_application.m_pPlayer->IsPassthrough());
   }
   else if (setting.id == SUBTITLE_SETTINGS_ENABLE)
diff --git a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.h b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.h
index ad5f3f1..f8c578e 100644
--- a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.h
+++ b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.h
@@ -47,7 +47,7 @@ class CGUIDialogAudioSubtitleSettings :
   float m_volume;
   int m_audioStream;
   int m_subtitleStream;
-  int m_outputmode;
+  bool m_outputmode;
   bool m_subtitleVisible;
   Features m_audioCaps;
   Features m_subCaps;
-- 
1.8.4


From 0939d32581423915e83eba8435f82d32011fdef6 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:05:07 +0200
Subject: [PATCH 05/94] ActiveAE: adapt to changes in audio settings

---
 .../AudioEngine/Engines/ActiveAE/ActiveAE.cpp      | 96 ++++++++++++++++------
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h |  8 +-
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.cpp  | 31 +++++++
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.h    |  2 +
 4 files changed, 110 insertions(+), 27 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 71e4687..cc9fd75 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -411,7 +411,7 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
           m_extDeferData = true;
           return;
         case CActiveAEControlProtocol::DISPLAYLOST:
-          if (m_settings.mode == AUDIO_HDMI)
+          if (m_sink.GetDeviceType(m_mode == MODE_PCM ? m_settings.device : m_settings.passthoughdevice) == AE_DEVTYPE_HDMI)
           {
             UnconfigureSink();
             m_stats.SetSuspended(true);
@@ -1242,7 +1242,7 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
     *mode = MODE_PCM;
 
   // raw pass through
-  if (m_settings.mode != AUDIO_ANALOG && AE_IS_RAW(format.m_dataFormat))
+  if (AE_IS_RAW(format.m_dataFormat))
   {
     if ((format.m_dataFormat == AE_FMT_AC3 && !settings.ac3passthrough) ||
         (format.m_dataFormat == AE_FMT_EAC3 && !settings.eac3passthrough) ||
@@ -1256,9 +1256,8 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
       *mode = MODE_RAW;
   }
   // transcode
-  else if (m_settings.mode != AUDIO_ANALOG && 
+  else if (settings.passthrough &&
            settings.ac3passthrough &&
-           (!settings.multichannellpcm || (m_settings.mode != AUDIO_HDMI)) && 
            !m_streams.empty() &&
            (format.m_channelLayout.Count() > 2 || settings.stereoupmix))
   {
@@ -1279,7 +1278,8 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
     //    which would cause a short audio drop-out if we changed the sink
     if ((format.m_channelLayout.Count() > 2) ||
          settings.stereoupmix ||
-         (m_stats.GetWaterLevel() > 0 && m_internalFormat.m_channelLayout.Count() > 2 && !g_advancedSettings.m_audioAudiophile))
+         (settings.config == AE_CONFIG_FIXED) ||
+         (m_stats.GetWaterLevel() > 0 && m_internalFormat.m_channelLayout.Count() > 2 && (settings.config != AE_CONFIG_MATCH)))
     {
       CAEChannelInfo stdLayout;
       switch (settings.channels)
@@ -1298,30 +1298,28 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
         case 10: stdLayout = AE_CH_LAYOUT_7_1; break;
       }
 
-      if (g_advancedSettings.m_audioAudiophile)
+      if (m_settings.config == AE_CONFIG_MATCH)
         format.m_channelLayout.ResolveChannels(stdLayout);
       else
         format.m_channelLayout = stdLayout;
     }
 
-    if (m_settings.mode == AUDIO_IEC958 && format.m_sampleRate > 48000)
+    if (m_sink.GetDeviceType(m_settings.device) == AE_DEVTYPE_IEC958)
     {
-      format.m_sampleRate = 48000;
-      CLog::Log(LOGINFO, "CActiveAE::ApplySettings - limit samplerate for SPDIF to %d", format.m_sampleRate);
+      if (format.m_sampleRate > m_settings.samplerate)
+      {
+        format.m_sampleRate = m_settings.samplerate;
+        CLog::Log(LOGINFO, "CActiveAE::ApplySettings - limit samplerate for SPDIF to %d", format.m_sampleRate);
+      }
+      format.m_channelLayout = AE_CH_LAYOUT_2_0;
     }
 
-    if (g_advancedSettings.m_audioResample)
+    if (m_settings.config == AE_CONFIG_FIXED)
     {
-      format.m_sampleRate = g_advancedSettings.m_audioResample;
+      format.m_sampleRate = m_settings.samplerate;
       CLog::Log(LOGINFO, "CActiveAE::ApplySettings - Forcing samplerate to %d", format.m_sampleRate);
     }
 
-    // for IEC958 limit to 2 channels
-    if (m_settings.mode == AUDIO_IEC958)
-    {
-      format.m_channelLayout = AE_CH_LAYOUT_2_0;
-    }
-
     // sinks may not support mono
     if (format.m_channelLayout.Count() == 1)
     {
@@ -1540,7 +1538,7 @@ bool CActiveAE::RunStages()
 
           // TODO: find better solution for this
           // gapless bites audiophile
-          if (g_advancedSettings.m_audioAudiophile)
+          if (m_settings.config == AE_CONFIG_MATCH)
             Configure(&slave->m_format);
 
           (*it)->m_streamSlave = NULL;
@@ -1968,17 +1966,19 @@ void CActiveAE::LoadSettings()
   m_settings.device = CSettings::Get().GetString("audiooutput.audiodevice");
   m_settings.passthoughdevice = CSettings::Get().GetString("audiooutput.passthroughdevice");
 
-  m_settings.mode = CSettings::Get().GetInt("audiooutput.mode");
+  m_settings.config = CSettings::Get().GetInt("audiooutput.config");
   m_settings.channels = CSettings::Get().GetInt("audiooutput.channels");
+  m_settings.samplerate = CSettings::Get().GetInt("audiooutput.samplerate");
 
   m_settings.stereoupmix = CSettings::Get().GetBool("audiooutput.stereoupmix");
+
+  m_settings.passthrough = m_settings.config == AE_CONFIG_FIXED ? false : CSettings::Get().GetBool("audiooutput.passthrough");
   m_settings.ac3passthrough = CSettings::Get().GetBool("audiooutput.ac3passthrough");
   m_settings.eac3passthrough = CSettings::Get().GetBool("audiooutput.eac3passthrough");
   m_settings.truehdpassthrough = CSettings::Get().GetBool("audiooutput.truehdpassthrough");
   m_settings.dtspassthrough = CSettings::Get().GetBool("audiooutput.dtspassthrough");
   m_settings.dtshdpassthrough = CSettings::Get().GetBool("audiooutput.dtshdpassthrough");
   m_settings.aacpassthrough = CSettings::Get().GetBool("audiooutput.passthroughaac");
-  m_settings.multichannellpcm = CSettings::Get().GetBool("audiooutput.multichannellpcm");
 
   m_settings.resampleQuality = static_cast<AEQuality>(CSettings::Get().GetInt("audiooutput.processquality"));
 }
@@ -2037,7 +2037,7 @@ void CActiveAE::OnSettingsChange(const std::string& setting)
 {
   if (setting == "audiooutput.passthroughdevice" ||
       setting == "audiooutput.audiodevice"       ||
-      setting == "audiooutput.mode"              ||
+      setting == "audiooutput.config"            ||
       setting == "audiooutput.ac3passthrough"    ||
       setting == "audiooutput.eac3passthrough"   ||
       setting == "audiooutput.dtspassthrough"    ||
@@ -2045,17 +2045,29 @@ void CActiveAE::OnSettingsChange(const std::string& setting)
       setting == "audiooutput.truehdpassthrough" ||
       setting == "audiooutput.dtshdpassthrough"  ||
       setting == "audiooutput.channels"          ||
-      setting == "audiooutput.multichannellpcm"  ||
       setting == "audiooutput.stereoupmix"       ||
       setting == "audiooutput.streamsilence"     ||
-      setting == "audiooutput.processquality")
+      setting == "audiooutput.processquality"    ||
+      setting == "audiooutput.passthrough"       ||
+      setting == "audiooutput.samplerate")
   {
     m_controlPort.SendOutMessage(CActiveAEControlProtocol::RECONFIGURE);
   }
 }
 
-bool CActiveAE::SupportsRaw()
+bool CActiveAE::SupportsRaw(AEDataFormat format)
 {
+  if (!m_sink.HasPassthroughDevice())
+    return false;
+
+  // those formats require HDMI
+  if (format == AE_FMT_DTSHD || format == AE_FMT_TRUEHD)
+  {
+    if(m_sink.GetDeviceType(CSettings::Get().GetString("audiooutput.passthroughdevice")) != AE_DEVTYPE_HDMI)
+      return false;
+  }
+
+  // TODO: check ELD?
   return true;
 }
 
@@ -2072,6 +2084,42 @@ bool CActiveAE::SupportsQualityLevel(enum AEQuality level)
   return false;
 }
 
+bool CActiveAE::IsSettingVisible(const std::string &settingId)
+{
+  if (settingId == "audiooutput.samplerate")
+  {
+    if (m_sink.GetDeviceType(CSettings::Get().GetString("audiooutput.audiodevice")) == AE_DEVTYPE_IEC958)
+      return true;
+    if (CSettings::Get().GetInt("audiooutput.config") == AE_CONFIG_FIXED)
+      return true;
+  }
+  else if (settingId == "audiooutput.channels")
+  {
+    if (m_sink.GetDeviceType(CSettings::Get().GetString("audiooutput.audiodevice")) != AE_DEVTYPE_IEC958)
+      return true;
+  }
+  else if (settingId == "audiooutput.passthrough")
+  {
+    if (m_sink.HasPassthroughDevice() && CSettings::Get().GetInt("audiooutput.config") != AE_CONFIG_FIXED)
+      return true;
+  }
+  else if (settingId == "audiooutput.truehdpassthrough")
+  {
+    if (m_sink.HasPassthroughDevice() &&
+        CSettings::Get().GetInt("audiooutput.config") != AE_CONFIG_FIXED &&
+        m_sink.GetDeviceType(CSettings::Get().GetString("audiooutput.passthroughdevice")) == AE_DEVTYPE_HDMI)
+      return true;
+  }
+  else if (settingId == "audiooutput.dtshdpassthrough")
+  {
+    if (m_sink.HasPassthroughDevice() &&
+        CSettings::Get().GetInt("audiooutput.config") != AE_CONFIG_FIXED &&
+        m_sink.GetDeviceType(CSettings::Get().GetString("audiooutput.passthroughdevice")) == AE_DEVTYPE_HDMI)
+      return true;
+  }
+  return false;
+}
+
 void CActiveAE::Shutdown()
 {
   Dispose();
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index d684a44..2ae0476 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -48,7 +48,6 @@ struct AudioSettings
   std::string device;
   std::string driver;
   std::string passthoughdevice;
-  int mode;
   int channels;
   bool ac3passthrough;
   bool eac3passthrough;
@@ -56,8 +55,10 @@ struct AudioSettings
   bool aacpassthrough;
   bool truehdpassthrough;
   bool dtshdpassthrough;
-  bool multichannellpcm;
   bool stereoupmix;
+  bool passthrough;
+  int config;
+  unsigned int samplerate;
   AEQuality resampleQuality;
 };
 
@@ -214,9 +215,10 @@ class CActiveAE : public IAE, private CThread
 
   virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
   virtual std::string GetDefaultDevice(bool passthrough);
-  virtual bool SupportsRaw();
+  virtual bool SupportsRaw(AEDataFormat format);
   virtual bool SupportsDrain();
   virtual bool SupportsQualityLevel(enum AEQuality level);
+  virtual bool IsSettingVisible(const std::string &settingId);
 
   virtual void RegisterAudioCallback(IAudioCallback* pCallback);
   virtual void UnregisterAudioCallback();
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 1dec4f5..966b446 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -90,6 +90,37 @@ bool CActiveAESink::HasVolume()
   return m_sink->HasVolume();
 }
 
+AEDeviceType CActiveAESink::GetDeviceType(const std::string &device)
+{
+  std::string dev = device;
+  std::string dri;
+  CAESinkFactory::ParseDevice(dev, dri);
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    for (AEDeviceInfoList::iterator itt2 = itt->m_deviceInfoList.begin(); itt2 != itt->m_deviceInfoList.end(); ++itt2)
+    {
+      CAEDeviceInfo& info = *itt2;
+      if (info.m_deviceName == dev)
+        return info.m_deviceType;
+    }
+  }
+  return AE_DEVTYPE_PCM;
+}
+
+bool CActiveAESink::HasPassthroughDevice()
+{
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    for (AEDeviceInfoList::iterator itt2 = itt->m_deviceInfoList.begin(); itt2 != itt->m_deviceInfoList.end(); ++itt2)
+    {
+      CAEDeviceInfo& info = *itt2;
+      if (info.m_deviceType != AE_DEVTYPE_PCM)
+        return true;
+    }
+  }
+  return false;
+}
+
 enum SINK_STATES
 {
   S_TOP = 0,                      // 0
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
index 59bad57..2aebbf6 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
@@ -89,6 +89,8 @@ class CActiveAESink : private CThread
   void Start();
   void Dispose();
   bool HasVolume();
+  AEDeviceType GetDeviceType(const std::string &device);
+  bool HasPassthroughDevice();
   CSinkControlProtocol m_controlPort;
   CSinkDataProtocol m_dataPort;
 
-- 
1.8.4


From 1eba1ed4d2997d88ef8d8d29783aa307d8d7cae2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:12:01 +0200
Subject: [PATCH 06/94] SoftAE: farewell!

---
 xbmc/cores/AudioEngine/AEFactory.cpp               |    5 -
 xbmc/cores/AudioEngine/AEFactory.h                 |    1 -
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp   | 1548 --------------------
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h     |  253 ----
 .../AudioEngine/Engines/SoftAE/SoftAESound.cpp     |  114 --
 .../cores/AudioEngine/Engines/SoftAE/SoftAESound.h |   57 -
 .../AudioEngine/Engines/SoftAE/SoftAEStream.cpp    |  687 ---------
 .../AudioEngine/Engines/SoftAE/SoftAEStream.h      |  161 --
 xbmc/cores/AudioEngine/Makefile.in                 |    4 -
 9 files changed, 2830 deletions(-)
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
 delete mode 100644 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 3092898..ba97a6b 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -26,7 +26,6 @@
   #include "Engines/CoreAudio/CoreAudioAE.h"
   #include "settings/SettingsManager.h"
 #else
-  #include "Engines/SoftAE/SoftAE.h"
   #include "Engines/ActiveAE/ActiveAE.h"
 #endif
 
@@ -73,9 +72,6 @@ bool CAEFactory::LoadEngine()
       loaded = CAEFactory::LoadEngine(AE_ENGINE_PULSE);
     #endif
     
-    if (!loaded && engine == "SOFT" )
-      loaded = CAEFactory::LoadEngine(AE_ENGINE_SOFT);
-
     if (!loaded && engine == "ACTIVE")
       loaded = CAEFactory::LoadEngine(AE_ENGINE_ACTIVE);
   }
@@ -103,7 +99,6 @@ bool CAEFactory::LoadEngine(enum AEEngine engine)
 #if defined(TARGET_DARWIN)
     case AE_ENGINE_COREAUDIO: AE = new CCoreAudioAE(); break;
 #else
-    case AE_ENGINE_SOFT     : AE = new CSoftAE(); break;
     case AE_ENGINE_ACTIVE   : AE = new ActiveAE::CActiveAE(); break;
 #endif
 #if defined(HAS_PULSEAUDIO)
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index b007627..20e67a3 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -29,7 +29,6 @@
 enum AEEngine
 {
   AE_ENGINE_NULL,
-  AE_ENGINE_SOFT,
   AE_ENGINE_COREAUDIO,
   AE_ENGINE_PULSE,
   AE_ENGINE_ACTIVE,
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
deleted file mode 100644
index 555ba2d..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
+++ /dev/null
@@ -1,1548 +0,0 @@
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <string.h>
-#include <sstream>
-#include <iterator>
-
-#include "system.h"
-#include "utils/log.h"
-#include "utils/TimeUtils.h"
-#include "utils/MathUtils.h"
-#include "utils/EndianSwap.h"
-#include "threads/SingleLock.h"
-#include "settings/AdvancedSettings.h"
-#include "settings/Settings.h"
-
-#include "SoftAE.h"
-#include "SoftAESound.h"
-#include "SoftAEStream.h"
-#include "AESinkFactory.h"
-#include "Interfaces/AESink.h"
-#include "Utils/AEUtil.h"
-#include "Encoders/AEEncoderFFmpeg.h"
-
-using namespace std;
-
-/* Define idle wait time based on platform in milliseconds */
-/* Higher wait times reduce thread CPU overhead when in    */
-/* idle or Suspend() modes                                 */
-#if defined (TARGET_WINDOWS) || defined (TARGET_LINUX) || \
-  defined (TARGET_DARWIN_OSX) || defined (TARGET_FREEBSD)
-#define SOFTAE_IDLE_WAIT_MSEC 50  // shorter sleep for HTPC's
-#elif defined (TARGET_RASPBERRY_PI) || defined (TARGET_ANDROID)
-#define SOFTAE_IDLE_WAIT_MSEC 100 // longer for R_PI and Android
-#else
-#define SOFTAE_IDLE_WAIT_MSEC 100 // catchall for undefined platforms
-#endif
-
-CSoftAE::CSoftAE():
-  m_thread             (NULL        ),
-  m_audiophile         (true        ),
-  m_running            (false       ),
-  m_reOpen             (false       ),
-  m_sinkIsSuspended    (false       ),
-  m_isSuspended        (false       ),
-  m_softSuspend        (false       ),
-  m_softSuspendTimeout (XbmcThreads::EndTime::InfiniteValue),
-  m_volume             (1.0         ),
-  m_sink               (NULL        ),
-  m_sinkBlockTime      (0           ),
-  m_transcode          (false       ),
-  m_rawPassthrough     (false       ),
-  m_soundMode          (AE_SOUND_OFF),
-  m_streamsPlaying     (false       ),
-  m_encoder            (NULL        ),
-  m_converted          (NULL        ),
-  m_convertedSize      (0           ),
-  m_masterStream       (NULL        ),
-  m_outputStageFn      (NULL        ),
-  m_streamStageFn      (NULL        )
-{
-  unsigned int c_retry = 5;
-  CAESinkFactory::EnumerateEx(m_sinkInfoList);
-  while(m_sinkInfoList.size() == 0 && c_retry > 0)
-  {
-    CLog::Log(LOGNOTICE, "No Devices found - retry: %d", c_retry);
-    Sleep(2000);
-    c_retry--;
-    // retry the enumeration
-    CAESinkFactory::EnumerateEx(m_sinkInfoList, true);
-  }
-  CLog::Log(LOGNOTICE, "Found %lu Lists of Devices", m_sinkInfoList.size());
-  PrintSinks();
-}
-
-CSoftAE::~CSoftAE()
-{
-  Deinitialize();
-
-  /* free the streams */
-  CSingleLock streamLock(m_streamLock);
-  while (!m_streams.empty())
-  {
-    CSoftAEStream *s = m_streams.front();
-    delete s;
-  }
-
-  /* free the sounds */
-  CSingleLock soundLock(m_soundLock);
-  while (!m_sounds.empty())
-  {
-    CSoftAESound *s = m_sounds.front();
-    m_sounds.pop_front();
-    delete s;
-  }
-}
-
-IAESink *CSoftAE::GetSink(AEAudioFormat &newFormat, bool passthrough, std::string &device)
-{
-  device = passthrough ? m_passthroughDevice : m_device;
-
-  /* if we are raw, force the sample rate */
-  if (AE_IS_RAW(newFormat.m_dataFormat))
-  {
-    switch (newFormat.m_dataFormat)
-    {
-      case AE_FMT_AC3:
-      case AE_FMT_DTS:
-        break;
-
-      case AE_FMT_EAC3:
-        newFormat.m_sampleRate = 192000;
-        break;
-
-      case AE_FMT_TRUEHD:
-      case AE_FMT_DTSHD:
-        newFormat.m_sampleRate = 192000;
-        break;
-
-      default:
-        break;
-    }
-  }
-
-  IAESink *sink = CAESinkFactory::Create(device, newFormat, passthrough);
-  return sink;
-}
-
-/* this method MUST be called while holding m_streamLock */
-inline CSoftAEStream *CSoftAE::GetMasterStream()
-{
-  /* remove any destroyed streams first */
-  for (StreamList::iterator itt = m_streams.begin(); itt != m_streams.end();)
-  {
-    CSoftAEStream *stream = *itt;
-    if (stream->IsDestroyed())
-    {
-      RemoveStream(m_playingStreams, stream);
-      RemoveStream(m_streams       , stream);
-      delete stream;
-      continue;
-    }
-    ++itt;
-  }
-
-  if (!m_newStreams.empty())
-    return m_newStreams.back();
-
-  if (!m_streams.empty())
-    return m_streams.back();
-
-  return NULL;
-}
-
-/* save method to call outside of the main thread, use this one */
-void CSoftAE::OpenSink()
-{
-  m_reOpenEvent.Reset();
-  m_reOpen = true;
-  m_reOpenEvent.Wait();
-  m_wake.Set();
-}
-
-void CSoftAE::InternalCloseSink()
-{
-  /* close the old sink if it was open */
-  if (m_sink)
-  {
-    CExclusiveLock sinkLock(m_sinkLock);
-    m_sink->Drain();
-    m_sink->Deinitialize();
-    delete m_sink;
-    m_sink = NULL;
-  }
-}
-/* this must NEVER be called from outside the main thread or Initialization */
-void CSoftAE::InternalOpenSink()
-{
-  /* save off our raw/passthrough mode for checking */
-  bool wasTranscode           = m_transcode;
-  bool wasRawPassthrough      = m_rawPassthrough;
-  bool reInit                 = false;
-
-  LoadSettings();
-
-  /* initialize for analog output */
-  m_rawPassthrough = false;
-  m_streamStageFn = &CSoftAE::RunStreamStage;
-  m_outputStageFn = &CSoftAE::RunOutputStage;
-
-  /* initialize the new format for basic 2.0 output */
-  AEAudioFormat newFormat;
-  newFormat.m_dataFormat    = AE_FMT_FLOAT;
-  newFormat.m_sampleRate    = 44100;
-  newFormat.m_encodedRate   = 0;
-  newFormat.m_channelLayout = m_stereoUpmix ? m_stdChLayout : AE_CH_LAYOUT_2_0;
-  newFormat.m_frames        = 0;
-  newFormat.m_frameSamples  = 0;
-  newFormat.m_frameSize     = 0;
-
-  CSingleLock streamLock(m_streamLock);
-
-  m_masterStream = GetMasterStream();
-  if (m_masterStream)
-  {
-    /* choose the sample rate & channel layout based on the master stream */
-    newFormat.m_sampleRate = m_masterStream->GetSampleRate();
-    if (!m_stereoUpmix)
-      newFormat.m_channelLayout = m_masterStream->m_initChannelLayout;
-
-    if (m_masterStream->IsRaw())
-    {
-      newFormat.m_sampleRate    = m_masterStream->GetSampleRate();
-      newFormat.m_encodedRate   = m_masterStream->GetEncodedSampleRate();
-      newFormat.m_dataFormat    = m_masterStream->GetDataFormat();
-      newFormat.m_channelLayout = m_masterStream->m_initChannelLayout;
-      m_rawPassthrough = true;
-      m_streamStageFn  = &CSoftAE::RunRawStreamStage;
-      m_outputStageFn  = &CSoftAE::RunRawOutputStage;
-    }
-    else
-    {
-      if (!m_transcode)
-        newFormat.m_channelLayout.ResolveChannels(m_stdChLayout);
-      else
-      {
-        if (m_masterStream->m_initChannelLayout == AE_CH_LAYOUT_2_0)
-          m_transcode = false;
-        m_encoderInitSampleRateMul = 1.0 / newFormat.m_sampleRate;
-      }
-    }
-
-    /* if the stream is paused we cant use it for anything else */
-    if (m_masterStream->m_paused)
-      m_masterStream = NULL;
-  }
-  else
-    m_transcode = false;
-
-  if (!m_rawPassthrough && m_transcode)
-    newFormat.m_dataFormat = AE_FMT_AC3;
-
-  streamLock.Leave();
-
-  std::string device, driver;
-  if (m_transcode || m_rawPassthrough)
-    device = m_passthroughDevice;
-  else
-    device = m_device;
-
-  CAESinkFactory::ParseDevice(device, driver);
-  if (driver.empty() && m_sink)
-    driver = m_sink->GetName();
-
-  if (m_rawPassthrough)
-    CLog::Log(LOGINFO, "CSoftAE::InternalOpenSink - RAW passthrough enabled");
-  else if (m_transcode)
-    CLog::Log(LOGINFO, "CSoftAE::InternalOpenSink - Transcode passthrough enabled");
-
-  /*
-    try to use 48000hz if we are going to transcode, this prevents the sink
-    from being re-opened repeatedly when switching sources, which locks up
-    some receivers & crappy integrated sound drivers. Check for as.xml override
-  */
-  if (m_transcode && !m_rawPassthrough)
-  {
-    enum AEChannel ac3Layout[3] = {AE_CH_RAW, AE_CH_RAW, AE_CH_NULL};
-    newFormat.m_channelLayout = ac3Layout;
-    m_outputStageFn = &CSoftAE::RunTranscodeStage;
-    if (!g_advancedSettings.m_allowTranscode44100)
-      newFormat.m_sampleRate    = 48000;
-  }
-
-  /*
-    if there is an audio resample rate set, use it, this MAY NOT be honoured as
-    the audio sink may not support the requested format, and may change it.
-  */
-  if (g_advancedSettings.m_audioResample)
-  {
-    newFormat.m_sampleRate = g_advancedSettings.m_audioResample;
-    CLog::Log(LOGINFO, "CSoftAE::InternalOpenSink - Forcing samplerate to %d", newFormat.m_sampleRate);
-  }
-
-  /* only re-open the sink if its not compatible with what we need */
-  std::string sinkName;
-  if (m_sink)
-  {
-    sinkName = m_sink->GetName();
-    std::transform(sinkName.begin(), sinkName.end(), sinkName.begin(), ::toupper);
-  }
-
-  if (!m_sink || sinkName != driver || !m_sink->IsCompatible(newFormat, device))
-  {
-    CLog::Log(LOGINFO, "CSoftAE::InternalOpenSink - sink incompatible, re-starting");
-
-    /* take the sink lock */
-    CExclusiveLock sinkLock(m_sinkLock);
-
-    reInit = true;
-    //close the sink cause it gets reinited
-    InternalCloseSink();
-
-    /* get the display name of the device */
-    GetDeviceFriendlyName(device);
-
-    /* if we already have a driver, prepend it to the device string */
-    if (!driver.empty())
-      device = driver + ":" + device;
-
-    /* create the new sink */
-    m_sink = GetSink(newFormat, m_transcode || m_rawPassthrough, device);
-
-    /* perform basic sanity checks on the format returned by the sink */
-    ASSERT(newFormat.m_channelLayout.Count() > 0);
-    ASSERT(newFormat.m_dataFormat           <= AE_FMT_FLOAT);
-    ASSERT(newFormat.m_frames                > 0);
-    ASSERT(newFormat.m_frameSamples          > 0);
-    ASSERT(newFormat.m_frameSize            == (CAEUtil::DataFormatToBits(newFormat.m_dataFormat) >> 3) * newFormat.m_channelLayout.Count());
-    ASSERT(newFormat.m_sampleRate            > 0);
-
-    CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink - %s Initialized:", m_sink->GetName());
-    CLog::Log(LOGDEBUG, "  Output Device : %s", m_deviceFriendlyName.c_str());
-    CLog::Log(LOGDEBUG, "  Sample Rate   : %d", newFormat.m_sampleRate);
-    CLog::Log(LOGDEBUG, "  Sample Format : %s", CAEUtil::DataFormatToStr(newFormat.m_dataFormat));
-    CLog::Log(LOGDEBUG, "  Channel Count : %d", newFormat.m_channelLayout.Count());
-    CLog::Log(LOGDEBUG, "  Channel Layout: %s", ((std::string)newFormat.m_channelLayout).c_str());
-    CLog::Log(LOGDEBUG, "  Frames        : %d", newFormat.m_frames);
-    CLog::Log(LOGDEBUG, "  Frame Samples : %d", newFormat.m_frameSamples);
-    CLog::Log(LOGDEBUG, "  Frame Size    : %d", newFormat.m_frameSize);
-
-    m_sinkFormat              = newFormat;
-    m_sinkFormatSampleRateMul = 1.0 / (double)newFormat.m_sampleRate;
-    m_sinkBlockSize           = newFormat.m_frames * newFormat.m_frameSize;
-    m_sinkBlockTime           = 1000 * newFormat.m_frames / newFormat.m_sampleRate;
-    // check if sink controls volume, if so, init the volume.
-    m_sinkHandlesVolume       = m_sink->HasVolume();
-    if (m_sinkHandlesVolume)
-      m_sink->SetVolume(m_volume);
-
-    /* invalidate the buffer */
-    m_buffer.Empty();
-  }
-  else
-    CLog::Log(LOGINFO, "CSoftAE::InternalOpenSink - keeping old sink with : %s, %s, %dhz",
-                          CAEUtil::DataFormatToStr(newFormat.m_dataFormat),
-                          ((std::string)newFormat.m_channelLayout).c_str(),
-                          newFormat.m_sampleRate);
-
-  reInit = (reInit || m_chLayout != m_sinkFormat.m_channelLayout);
-  m_chLayout = m_sinkFormat.m_channelLayout;
-
-  size_t neededBufferSize = 0;
-  if (m_rawPassthrough)
-  {
-    if (!wasRawPassthrough)
-      m_buffer.Empty();
-
-    m_convertFn      = NULL;
-    m_bytesPerSample = CAEUtil::DataFormatToBits(m_sinkFormat.m_dataFormat) >> 3;
-    m_frameSize      = m_sinkFormat.m_frameSize;
-    m_frameSizeMul   = 1.0 / (double)m_frameSize;
-    neededBufferSize = m_sinkFormat.m_frames * m_sinkFormat.m_frameSize;
-  }
-  else
-  {
-    /* if we are transcoding */
-    if (m_transcode)
-    {
-      if (!wasTranscode || wasRawPassthrough)
-      {
-        /* invalidate the buffer */
-        m_buffer.Empty();
-        if (m_encoder)
-          m_encoder->Reset();
-      }
-
-      /* configure the encoder */
-      AEAudioFormat encoderFormat;
-      encoderFormat.m_dataFormat    = AE_FMT_FLOAT;
-      encoderFormat.m_sampleRate    = m_sinkFormat.m_sampleRate;
-      encoderFormat.m_encodedRate   = 0;
-      encoderFormat.m_channelLayout = m_chLayout;
-      encoderFormat.m_frames        = 0;
-      encoderFormat.m_frameSamples  = 0;
-      encoderFormat.m_frameSize     = 0;
-      
-      if (!m_encoder || !m_encoder->IsCompatible(encoderFormat))
-      {
-        m_buffer.Empty();
-        SetupEncoder(encoderFormat);
-        m_encoderFormat       = encoderFormat;
-        if (encoderFormat.m_frameSize > 0)
-          m_encoderFrameSizeMul = 1.0 / (double)m_sinkFormat.m_frameSize;
-        else
-          m_encoderFrameSizeMul = 1.0;
-      }
-
-      /* remap directly to the format we need for encode */
-      reInit = (reInit || m_chLayout != m_encoderFormat.m_channelLayout);
-      m_chLayout       = m_encoderFormat.m_channelLayout;
-      m_convertFn      = CAEConvert::FrFloat(m_encoderFormat.m_dataFormat);
-      neededBufferSize = m_encoderFormat.m_frames * sizeof(float) * m_chLayout.Count();
-      CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink - Encoding using layout: %s", ((std::string)m_chLayout).c_str());
-    }
-    else
-    {
-      m_convertFn      = CAEConvert::FrFloat(m_sinkFormat.m_dataFormat);
-      neededBufferSize = m_sinkFormat.m_frames * sizeof(float) * m_chLayout.Count();
-      CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink - Using speaker layout: %s", CAEUtil::GetStdChLayoutName(m_stdChLayout));
-    }
-
-    m_bytesPerSample = CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3;
-    m_frameSize      = m_bytesPerSample * m_chLayout.Count();
-    m_frameSizeMul   = 1.0 / (double)m_frameSize;
-  }
-
-  CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink - Internal Buffer Size: %d", (int)neededBufferSize);
-  if (m_buffer.Size() < neededBufferSize)
-    m_buffer.Alloc(neededBufferSize);
-
-  if (reInit)
-  {
-    if (!m_rawPassthrough)
-    {
-      /* re-init incompatible sounds */
-      CSingleLock soundLock(m_soundLock);
-      for (SoundList::iterator itt = m_sounds.begin(); itt != m_sounds.end(); ++itt)
-      {
-        CSoftAESound *sound = *itt;
-        if (!sound->IsCompatible())
-        {
-          StopSound(sound);
-          sound->Initialize();
-        }
-      }
-    }
-
-    /* re-init streams */
-    streamLock.Enter();
-    for (StreamList::iterator itt = m_streams.begin(); itt != m_streams.end(); ++itt)
-      (*itt)->Initialize();
-    streamLock.Leave();
-  }
-
-  /* any new streams need to be initialized */
-  for (StreamList::iterator itt = m_newStreams.begin(); itt != m_newStreams.end(); ++itt)
-  {
-    (*itt)->Initialize();
-    m_streams.push_back(*itt);
-    if (!(*itt)->m_paused)
-      m_playingStreams.push_back(*itt);
-  }
-  m_newStreams.clear();
-  m_streamsPlaying = !m_playingStreams.empty();
-
-  m_softSuspend = false;
-
-  /* notify any event listeners that we are done */
-  m_reOpen = false;
-  m_reOpenEvent.Set();
-  m_wake.Set();
-}
-
-void CSoftAE::ResetEncoder()
-{
-  if (m_encoder)
-    m_encoder->Reset();
-  m_encodedBuffer.Empty();
-}
-
-bool CSoftAE::SetupEncoder(AEAudioFormat &format)
-{
-  ResetEncoder();
-  delete m_encoder;
-  m_encoder = NULL;
-
-  if (!m_transcode)
-    return false;
-
-  m_encoder = new CAEEncoderFFmpeg();
-  if (m_encoder->Initialize(format))
-    return true;
-
-  delete m_encoder;
-  m_encoder = NULL;
-  return false;
-}
-
-void CSoftAE::Shutdown()
-{
-  Deinitialize();
-}
-
-bool CSoftAE::Initialize()
-{
-  CSingleLock lock(m_threadLock);
-  InternalOpenSink();
-  m_running = true;
-  m_thread  = new CThread(this, "SoftAE");
-  m_thread->Create();
-  m_thread->SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
-  return true;
-}
-
-void CSoftAE::OnSettingsChange(const std::string& setting)
-{
-  if (setting == "audiooutput.passthroughdevice" ||
-      setting == "audiooutput.audiodevice"       ||
-      setting == "audiooutput.mode"              ||
-      setting == "audiooutput.ac3passthrough"    ||
-      setting == "audiooutput.dtspassthrough"    ||
-      setting == "audiooutput.passthroughaac"    ||
-      setting == "audiooutput.truehdpassthrough" ||
-      setting == "audiooutput.dtshdpassthrough"  ||
-      setting == "audiooutput.channels"          ||
-      setting == "audiooutput.multichannellpcm"  ||
-      setting == "audiooutput.stereoupmix")
-  {
-    OpenSink();
-  }
-
-  if (setting == "audiooutput.normalizelevels" || setting == "audiooutput.stereoupmix")
-  {
-    /* re-init stream reamppers */
-    CSingleLock streamLock(m_streamLock);
-    for (StreamList::iterator itt = m_streams.begin(); itt != m_streams.end(); ++itt)
-      (*itt)->InitializeRemap();
-  }
-}
-
-void CSoftAE::LoadSettings()
-{
-  m_audiophile = g_advancedSettings.m_audioAudiophile;
-  if (m_audiophile)
-    CLog::Log(LOGINFO, "CSoftAE::LoadSettings - Audiophile switch enabled");
-
-  m_stereoUpmix = CSettings::Get().GetBool("audiooutput.stereoupmix");
-  if (m_stereoUpmix)
-    CLog::Log(LOGINFO, "CSoftAE::LoadSettings - Stereo upmix is enabled");
-
-  /* load the configuration */
-  m_stdChLayout = AE_CH_LAYOUT_2_0;
-  switch (CSettings::Get().GetInt("audiooutput.channels"))
-  {
-    default:
-    case  0: m_stdChLayout = AE_CH_LAYOUT_2_0; break; /* dont alow 1_0 output */
-    case  1: m_stdChLayout = AE_CH_LAYOUT_2_0; break;
-    case  2: m_stdChLayout = AE_CH_LAYOUT_2_1; break;
-    case  3: m_stdChLayout = AE_CH_LAYOUT_3_0; break;
-    case  4: m_stdChLayout = AE_CH_LAYOUT_3_1; break;
-    case  5: m_stdChLayout = AE_CH_LAYOUT_4_0; break;
-    case  6: m_stdChLayout = AE_CH_LAYOUT_4_1; break;
-    case  7: m_stdChLayout = AE_CH_LAYOUT_5_0; break;
-    case  8: m_stdChLayout = AE_CH_LAYOUT_5_1; break;
-    case  9: m_stdChLayout = AE_CH_LAYOUT_7_0; break;
-    case 10: m_stdChLayout = AE_CH_LAYOUT_7_1; break;
-  }
-
-  // force optical/coax to 2.0 output channels
-  if (!m_rawPassthrough && CSettings::Get().GetInt("audiooutput.mode") == AUDIO_IEC958)
-    m_stdChLayout = AE_CH_LAYOUT_2_0;
-
-  /* get the output devices and ensure they exist */
-  m_device            = CSettings::Get().GetString("audiooutput.audiodevice");
-  m_passthroughDevice = CSettings::Get().GetString("audiooutput.passthroughdevice");
-  VerifySoundDevice(m_device           , false);
-  VerifySoundDevice(m_passthroughDevice, true );
-
-  m_transcode = (
-    CSettings::Get().GetBool("audiooutput.ac3passthrough") /*||
-    CSettings::Get().GetBool("audiooutput.dtspassthrough") */
-  ) && (
-      (CSettings::Get().GetInt("audiooutput.mode") == AUDIO_IEC958) ||
-      (CSettings::Get().GetInt("audiooutput.mode") == AUDIO_HDMI && !CSettings::Get().GetBool("audiooutput.multichannellpcm"))
-  );
-}
-
-void CSoftAE::VerifySoundDevice(std::string& device, bool passthrough)
-{
-  /* check that the specified device exists */
-  std::string firstDevice;
-  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-  {
-    AESinkInfo sinkInfo = *itt;
-    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
-    {
-      CAEDeviceInfo& devInfo = *itt2;
-      if (passthrough && devInfo.m_deviceType == AE_DEVTYPE_PCM)
-        continue;
-      std::string deviceName = sinkInfo.m_sinkName + ":" + devInfo.m_deviceName;
-
-      /* remember the first device so we can default to it if required */
-      if (firstDevice.empty())
-        firstDevice = deviceName;
-
-      if (device == deviceName)
-        return;
-    }
-  }
-
-  /* if the device wasnt found, set it to the first viable output */
-  device = firstDevice;
-}
-
-inline void CSoftAE::GetDeviceFriendlyName(std::string &device)
-{
-  m_deviceFriendlyName = "Device not found";
-  /* Match the device and find its friendly name */
-  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-  {
-    AESinkInfo sinkInfo = *itt;
-    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
-    {
-      CAEDeviceInfo& devInfo = *itt2;
-      if (devInfo.m_deviceName == device)
-      {
-        m_deviceFriendlyName = devInfo.m_displayName;
-        break;
-      }
-    }
-  }
-  return;
-}
-
-void CSoftAE::Deinitialize()
-{
-  CSingleLock lock(m_threadLock);
-  if (m_thread)
-  {
-    Stop();
-    m_thread->StopThread(true);
-    delete m_thread;
-    m_thread = NULL;
-  }
-  lock.Leave();
-
-  CExclusiveLock sinkLock(m_sinkLock);
-  if (m_sink)
-  {
-    /* shutdown the sink */
-    m_sink->Deinitialize();
-    delete m_sink;
-    m_sink = NULL;
-  }
-
-  delete m_encoder;
-  m_encoder = NULL;
-  ResetEncoder();
-  m_buffer.DeAlloc();
-
-  _aligned_free(m_converted);
-  m_converted = NULL;
-  m_convertedSize = 0;
-
-  m_sinkInfoList.clear();  
-}
-
-void CSoftAE::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough)
-{
-  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-  {
-    AESinkInfo sinkInfo = *itt;
-    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
-    {
-      CAEDeviceInfo devInfo = *itt2;
-      if (passthrough && devInfo.m_deviceType == AE_DEVTYPE_PCM)
-        continue;
-
-      std::string device = sinkInfo.m_sinkName + ":" + devInfo.m_deviceName;
-
-      std::stringstream ss;
-
-      /* add the sink name if we have more then one sink type */
-      if (m_sinkInfoList.size() > 1)
-        ss << sinkInfo.m_sinkName << ": ";
-
-      ss << devInfo.m_displayName;
-      if (!devInfo.m_displayNameExtra.empty())
-        ss << ", " << devInfo.m_displayNameExtra;
-
-      devices.push_back(AEDevice(ss.str(), device));
-    }
-  }
-}
-
-std::string CSoftAE::GetDefaultDevice(bool passthrough)
-{
-  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-  {
-    AESinkInfo sinkInfo = *itt;
-    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
-    {
-      CAEDeviceInfo devInfo = *itt2;
-      if (passthrough && devInfo.m_deviceType == AE_DEVTYPE_PCM)
-        continue;
-
-      std::string device = sinkInfo.m_sinkName + ":" + devInfo.m_deviceName;
-      return device;
-    }
-  }
-  return "default";
-}
-
-bool CSoftAE::SupportsRaw()
-{
-  /* CSoftAE supports raw formats */
-  return true;
-}
-
-void CSoftAE::PauseStream(CSoftAEStream *stream)
-{
-  CSingleLock streamLock(m_streamLock);
-  RemoveStream(m_playingStreams, stream);
-  stream->m_paused = true;
-
-  m_reOpen = true;
-  m_wake.Set();
-}
-
-void CSoftAE::ResumeStream(CSoftAEStream *stream)
-{
-  CSingleLock streamLock(m_streamLock);
-  m_playingStreams.push_back(stream);
-  stream->m_paused = false;
-  streamLock.Leave();
-
-  m_streamsPlaying = true;
-  m_reOpen = true;
-  m_wake.Set();
-}
-
-void CSoftAE::Stop()
-{
-  m_running = false;
-  m_isSuspended = false;
-  m_wake.Set();
-
-  /* wait for the thread to stop */
-  CSingleLock lock(m_runningLock);
-}
-
-void CSoftAE::SetSoundMode(const int mode)
-{
-  m_soundMode = mode;
-
-  /* stop all currently playing sounds if they are being turned off */
-  if (mode == AE_SOUND_OFF || (mode == AE_SOUND_IDLE && m_streamsPlaying))
-    StopAllSounds();
-}
-
-IAEStream *CSoftAE::MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options/* = 0 */)
-{
-  CAEChannelInfo channelInfo(channelLayout);
-  CLog::Log(LOGINFO, "CSoftAE::MakeStream - %s, %u, %s",
-            CAEUtil::DataFormatToStr(dataFormat),
-            sampleRate, ((std::string)channelInfo).c_str());
-
-  /* ensure we have the encoded sample rate if the format is RAW */
-  if (AE_IS_RAW(dataFormat))
-    ASSERT(encodedSampleRate);
-
-  CSingleLock streamLock(m_streamLock);
-  CSoftAEStream *stream = new CSoftAEStream(dataFormat, sampleRate, encodedSampleRate, channelLayout, options, m_streamLock);
-  m_newStreams.push_back(stream);
-  streamLock.Leave();
-  // this is really needed here
-  OpenSink();
-  return stream;
-}
-
-IAESound *CSoftAE::MakeSound(const std::string& file)
-{
-  CSingleLock soundLock(m_soundLock);
-
-  CSoftAESound *sound = new CSoftAESound(file);
-  if (!sound->Initialize())
-  {
-    delete sound;
-    return NULL;
-  }
-
-  m_sounds.push_back(sound);
-  return sound;
-}
-
-void CSoftAE::PlaySound(IAESound *sound)
-{
-  if (m_soundMode == AE_SOUND_OFF || (m_soundMode == AE_SOUND_IDLE && m_streamsPlaying))
-    return;
-
-  float *samples = ((CSoftAESound*)sound)->GetSamples();
-  if (!samples)
-    return;
-
-  /* add the sound to the play list */
-  CSingleLock soundSampleLock(m_soundSampleLock);
-  SoundState ss = {
-    ((CSoftAESound*)sound),
-    samples,
-    ((CSoftAESound*)sound)->GetSampleCount()
-  };
-  m_playing_sounds.push_back(ss);
-
-  /* wake to play the sound */
-  m_softSuspend = false;
-  m_wake.Set();
-}
-
-void CSoftAE::FreeSound(IAESound *sound)
-{
-  if (!sound)
-    return;
-
-  sound->Stop();
-  CSingleLock soundLock(m_soundLock);
-  for (SoundList::iterator itt = m_sounds.begin(); itt != m_sounds.end(); ++itt)
-    if (*itt == sound)
-    {
-      m_sounds.erase(itt);
-      break;
-    }
-
-  delete (CSoftAESound*)sound;
-}
-
-void CSoftAE::GarbageCollect()
-{
-}
-
-unsigned int CSoftAE::GetSampleRate()
-{
-  if (m_transcode && m_encoder && !m_rawPassthrough)
-    return m_encoderFormat.m_sampleRate;
-
-  return m_sinkFormat.m_sampleRate;
-}
-
-void CSoftAE::StopSound(IAESound *sound)
-{
-  CSingleLock lock(m_soundSampleLock);
-  for (SoundStateList::iterator itt = m_playing_sounds.begin(); itt != m_playing_sounds.end(); )
-  {
-    if ((*itt).owner == sound)
-    {
-      (*itt).owner->ReleaseSamples();
-      itt = m_playing_sounds.erase(itt);
-    }
-    else
-      ++itt;
-  }
-}
-
-IAEStream *CSoftAE::FreeStream(IAEStream *stream)
-{
-  CSingleLock lock(m_streamLock);
-  RemoveStream(m_playingStreams, (CSoftAEStream*)stream);
-  RemoveStream(m_streams       , (CSoftAEStream*)stream);
-  // Reopen is old behaviour. Not opening when masterstream stops means clipping on S/PDIF.
-  if(!m_isSuspended && (m_masterStream == stream))
-  {
-    m_reOpen = true;
-    m_masterStream = NULL;
-  }
-
-  delete (CSoftAEStream*)stream;
-  return NULL;
-}
-
-double CSoftAE::GetDelay()
-{
-  double delayBuffer = 0.0, delaySink = 0.0, delayTranscoder = 0.0;
-
-  CSharedLock sinkLock(m_sinkLock);
-  if (m_sink)
-    delaySink = m_sink->GetDelay();
- 
-  if (m_transcode && m_encoder && !m_rawPassthrough)
-  {
-    delayBuffer     = (double)m_buffer.Used() * m_frameSizeMul * m_encoderInitSampleRateMul;
-    delayTranscoder = m_encoder->GetDelay((double)m_encodedBuffer.Used() * m_encoderFrameSizeMul);
-  }
-  else
-    delayBuffer = (double)m_buffer.Used() * m_frameSizeMul *m_sinkFormatSampleRateMul;
-
-  return delayBuffer + delaySink + delayTranscoder;
-}
-
-double CSoftAE::GetCacheTime()
-{
-  double timeBuffer = 0.0, timeSink = 0.0, timeTranscoder = 0.0;
-
-  CSharedLock sinkLock(m_sinkLock);
-  if (m_sink)
-    timeSink = m_sink->GetCacheTime();
-
-  if (m_transcode && m_encoder && !m_rawPassthrough)
-  {
-    timeBuffer     = (double)m_buffer.Used() * m_frameSizeMul * m_encoderInitSampleRateMul;
-    timeTranscoder = m_encoder->GetDelay((double)m_encodedBuffer.Used() * m_encoderFrameSizeMul);
-  }
-  else
-    timeBuffer = (double)m_buffer.Used() * m_frameSizeMul *m_sinkFormatSampleRateMul;
-
-  return timeBuffer + timeSink + timeTranscoder;
-}
-
-double CSoftAE::GetCacheTotal()
-{
-  double timeBuffer = 0.0, timeSink = 0.0, timeTranscoder = 0.0;
-
-  CSharedLock sinkLock(m_sinkLock);
-  if (m_sink)
-    timeSink = m_sink->GetCacheTotal();
-
-  if (m_transcode && m_encoder && !m_rawPassthrough)
-  {
-    timeBuffer     = (double)m_buffer.Size() * m_frameSizeMul * m_encoderInitSampleRateMul;
-    timeTranscoder = m_encoder->GetDelay((double)m_encodedBuffer.Size() * m_encoderFrameSizeMul);
-  }
-  else
-    timeBuffer = (double)m_buffer.Size() * m_frameSizeMul *m_sinkFormatSampleRateMul;
-
-  return timeBuffer + timeSink + timeTranscoder;
-}
-
-bool CSoftAE::IsSuspended()
-{
-  return m_isSuspended;
-}
-
-float CSoftAE::GetVolume()
-{
-  return m_volume;
-}
-
-void CSoftAE::SetVolume(float volume)
-{
-  m_volume = volume;
-  if (!m_sinkHandlesVolume)
-    return;
-
-  CSharedLock sinkLock(m_sinkLock);
-  if (m_sink)
-    m_sink->SetVolume(m_volume);
-}
-
-void CSoftAE::StopAllSounds()
-{
-  CSingleLock lock(m_soundSampleLock);
-  while (!m_playing_sounds.empty())
-  {
-    SoundState *ss = &(*m_playing_sounds.begin());
-    ss->owner->ReleaseSamples();
-    m_playing_sounds.pop_front();
-  }
-}
-
-bool CSoftAE::Suspend()
-{
-  CLog::Log(LOGDEBUG, "CSoftAE::Suspend - Suspending AE processing");
-  m_isSuspended = true;
-
-  StopAllSounds();
-
-  CSingleLock streamLock(m_streamLock);
-  for (StreamList::iterator itt = m_playingStreams.begin(); itt != m_playingStreams.end(); ++itt)
-  {
-    CSoftAEStream *stream = *itt;
-    stream->Flush();
-  }
-  streamLock.Leave();
-  #if defined(TARGET_LINUX)
-  /*workaround sinks not playing sound after resume */
-    bool ret = true;
-    if(m_sink)
-    {
-      /* Deinitialize and delete current m_sink */
-      // we don't want that Run reopens our device, so we wait.
-      m_saveSuspend.Reset();
-      // wait until we are looping in ProcessSuspend()
-      // this is more save to not come up unclean
-      // we cannot wait forever
-      ret = m_saveSuspend.WaitMSec(500);
-      if(ret)
-      {
-        CLog::Log(LOGDEBUG, "CSoftAE::Suspend - After Event");
-        CExclusiveLock sinkLock(m_sinkLock);
-        // remove all the sinks
-        for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-        {
-          itt->m_deviceInfoList.pop_back();
-        }
-        InternalCloseSink();
-      }
-      else
-      {
-        CLog::Log(LOGDEBUG, "CSoftAE::Suspend - Unload failed will continue");
-        m_saveSuspend.Reset();
-      }
-    }
-    // The device list is now empty and must be reenumerated afterwards.
-    if(ret)
-      m_sinkInfoList.clear();
-
-    // signal anybody, that we are gone now (beware of deadlocks)
-    // we don't unset the fields here, to care for reinit after resume
-    if(m_reOpen)
-      m_reOpenEvent.Set();
-  #endif
-
-  return true;
-}
-
-bool CSoftAE::Resume()
-{
-#if defined(TARGET_LINUX)
-  // We must make sure, that we don't return empty.
-  if(m_sinkInfoList.empty())
-  {
-    CLog::Log(LOGDEBUG, "CSoftAE::Resume - Re Enumerating Sinks");
-    CExclusiveLock sinkLock(m_sinkLock);
-    // Forced enumeration - we are sure that we start completely fresh.
-    CAESinkFactory::EnumerateEx(m_sinkInfoList, true);
-    sinkLock.Leave(); // we leave here explicitly to not lock while printing new sinks
-    PrintSinks();
-  }
-#endif
-  CLog::Log(LOGDEBUG, "CSoftAE::Resume - Resuming AE processing");
-  m_isSuspended = false;
-  // we flag reopen
-  m_reOpen = true;
-
-  return true;
-}
-
-void CSoftAE::Run()
-{
-  /* we release this when we exit the thread unblocking anyone waiting on "Stop" */
-  CSingleLock runningLock(m_runningLock);
-  CLog::Log(LOGINFO, "CSoftAE::Run - Thread Started");
-
-  bool hasAudio = false;
-  while (m_running)
-  {
-    bool restart = false;
-
-    /* with the new non blocking implementation - we just reOpen here, when it tells reOpen */
-    if ((this->*m_outputStageFn)(hasAudio) > 0)
-      hasAudio = false; /* taken some audio - reset our silence flag */
-
-    /* if we have enough room in the buffer */
-    if (m_buffer.Free() >= m_frameSize)
-    {
-      /* take some data for our use from the buffer */
-      uint8_t *out = (uint8_t*)m_buffer.Take(m_frameSize);
-      memset(out, 0, m_frameSize);
-
-      /* run the stream stage */
-      CSoftAEStream *oldMaster = m_masterStream;
-      if ((this->*m_streamStageFn)(m_chLayout.Count(), out, restart) > 0)
-        hasAudio = true; /* have some audio */
-
-      /* if in audiophile mode and the master stream has changed, flag for restart */
-      if (m_audiophile && oldMaster != m_masterStream)
-        restart = true;
-    }
-
-    /* Handle idle or forced suspend */
-    ProcessSuspend();
-
-    /* if we are told to restart */
-    if (m_reOpen || restart || !m_sink)
-    {
-      if(m_sinkIsSuspended && m_sink)
-      {
-        // hint for fritsch: remember lazy evaluation
-        m_reOpen = !m_sink->SoftResume() || m_reOpen;
-        m_sinkIsSuspended = false;
-        CLog::Log(LOGDEBUG, "CSoftAE::Run - Sink was forgotten");   
-      }
-      CLog::Log(LOGDEBUG, "CSoftAE::Run - Sink restart flagged");
-      InternalOpenSink();
-    }
-
-#if defined(TARGET_ANDROID)
-    else if (m_playingStreams.empty() 
-      &&     m_playing_sounds.empty()
-      && !g_advancedSettings.m_streamSilence)
-    {
-      // if we have nothing to do, take a dirt nap.
-      // we do not have to take a lock just to check empty.
-      // this keeps AE from sucking CPU if nothing is going on.
-      m_wake.WaitMSec(SOFTAE_IDLE_WAIT_MSEC);
-    }
-#endif
-  }
-}
-
-void CSoftAE::AllocateConvIfNeeded(size_t convertedSize, bool prezero)
-{
-  if (m_convertedSize < convertedSize)
-  {
-    _aligned_free(m_converted);
-    m_converted = (uint8_t *)_aligned_malloc(convertedSize, 16);
-    m_convertedSize = convertedSize;
-  }
-  if (prezero)
-    memset(m_converted, 0x00, convertedSize);
-}
-
-unsigned int CSoftAE::MixSounds(float *buffer, unsigned int samples)
-{
-  // no point doing anything if we have no sounds,
-  // we do not have to take a lock just to check empty
-  if (m_playing_sounds.empty())
-    return 0;
-
-  SoundStateList::iterator itt;
-  unsigned int mixed = 0;
-  CSingleLock lock(m_soundSampleLock);
-  for (itt = m_playing_sounds.begin(); itt != m_playing_sounds.end(); )
-  {
-    SoundState *ss = &(*itt);
-    float *out = buffer;
-
-    /* no more frames, so remove it from the list */
-    if (ss->sampleCount == 0)
-    {
-      ss->owner->ReleaseSamples();
-      itt = m_playing_sounds.erase(itt);
-      continue;
-    }
-
-    float volume = ss->owner->GetVolume();
-    unsigned int mixSamples = std::min(ss->sampleCount, samples);
-    #ifdef __SSE__
-      CAEUtil::SSEMulAddArray(out, ss->samples, volume, mixSamples);
-    #else
-      float *sample_buffer = ss->samples;
-      for (unsigned int i = 0; i < mixSamples; ++i)
-        *out++ += *sample_buffer++ * volume;
-    #endif
-
-    ss->sampleCount -= mixSamples;
-    ss->samples     += mixSamples;
-
-    ++itt;
-    ++mixed;
-  }
-  return mixed;
-}
-
-bool CSoftAE::FinalizeSamples(float *buffer, unsigned int samples, bool hasAudio)
-{
-  if (m_soundMode != AE_SOUND_OFF)
-    hasAudio |= (MixSounds(buffer, samples) > 0);
-
-  /* no need to process if we don't have audio (buffer is memset to 0) */
-  if (!hasAudio)
-    return false;
-
-  if (m_muted)
-  {
-    memset(buffer, 0, samples * sizeof(float));
-    return false;
-  }
-
-  /* deamplify */
-  if (!m_sinkHandlesVolume && m_volume < 1.0)
-  {
-    #ifdef __SSE__
-      CAEUtil::SSEMulArray(buffer, m_volume, samples);
-    #else
-      float *fbuffer = buffer;
-      for (unsigned int i = 0; i < samples; i++)
-        *fbuffer++ *= m_volume;
-    #endif
-  }
-
-  /* check if we need to clamp */
-  bool clamp = false;
-  float *fbuffer = buffer;
-  for (unsigned int i = 0; i < samples; i++, fbuffer++)
-  {
-    if (*fbuffer < -1.0f || *fbuffer > 1.0f)
-    {
-      clamp = true;
-      break;
-    }
-  }
-
-  /* if there were no samples outside of the range, dont clamp the buffer */
-  if (!clamp)
-    return true;
-
-  CLog::Log(LOGDEBUG, "CSoftAE::FinalizeSamples - Clamping buffer of %d samples", samples);
-  CAEUtil::ClampArray(buffer, samples);
-  return true;
-}
-
-unsigned int CSoftAE::WriteSink(CAEBuffer& src, unsigned int src_len, uint8_t *data, bool hasAudio)
-{
-  CExclusiveLock lock(m_sinkLock); /* lock to maintain delay consistency */
-
-  XbmcThreads::EndTime timeout(m_sinkBlockTime * 2);
-  while(m_sink && src.Used() >= src_len)
-  {
-    int frames = m_sink->AddPackets(data, m_sinkFormat.m_frames, hasAudio);
-
-    /* Return value of INT_MAX signals error in sink - restart */
-    if (frames == INT_MAX)
-    {
-      CLog::Log(LOGERROR, "CSoftAE::WriteSink - sink error - reinit flagged");
-      m_reOpen = true;
-      break;
-    }
-
-    if (frames)
-    {
-      src.Shift(NULL, src_len);
-      return frames;
-    }
-
-    if(timeout.IsTimePast())
-    {
-      CLog::Log(LOGERROR, "CSoftAE::WriteSink - sink blocked- reinit flagged");
-      m_reOpen = true;
-      break;
-    }
-
-    lock.Leave();
-    Sleep(m_sinkBlockTime / 4);
-    lock.Enter();
-  }
-  return 0;
-}
-
-int CSoftAE::RunOutputStage(bool hasAudio)
-{
-  const unsigned int needSamples = m_sinkFormat.m_frames * m_sinkFormat.m_channelLayout.Count();
-  const size_t needBytes = needSamples * sizeof(float);
-  if (m_buffer.Used() < needBytes)
-    return 0;
-
-  void *data = m_buffer.Raw(needBytes);
-  hasAudio = FinalizeSamples((float*)data, needSamples, hasAudio);
-
-  if (m_convertFn)
-  {
-    const unsigned int convertedBytes = m_sinkFormat.m_frames * m_sinkFormat.m_frameSize;
-    AllocateConvIfNeeded(convertedBytes, !hasAudio);
-    if (hasAudio)
-      m_convertFn((float*)data, needSamples, m_converted);
-    data = m_converted;
-  }
-
-  return WriteSink(m_buffer, needBytes, (uint8_t*)data, hasAudio);
-}
-
-int CSoftAE::RunRawOutputStage(bool hasAudio)
-{
-  if(m_buffer.Used() < m_sinkBlockSize)
-    return 0;
-
-  void *data = m_buffer.Raw(m_sinkBlockSize);
-
-  if (CAEUtil::S16NeedsByteSwap(AE_FMT_S16NE, m_sinkFormat.m_dataFormat))
-  {
-    /*
-     * It would really be preferable to handle this at packing stage, so that
-     * it could byteswap the data efficiently without wasting CPU time on
-     * swapping the huge IEC 61937 zero padding between frames (or not
-     * byteswap at all, if there are two byteswaps).
-     *
-     * Unfortunately packing is done on a higher level and we can't easily
-     * tell it the needed format from here, so do it here for now (better than
-     * nothing)...
-     */
-    AllocateConvIfNeeded(m_sinkBlockSize, !hasAudio);
-    if (hasAudio)
-      Endian_Swap16_buf((uint16_t *)m_converted, (uint16_t *)data, m_sinkBlockSize / 2);
-    data = m_converted;
-  }
-
-  return WriteSink(m_buffer, m_sinkBlockSize, (uint8_t*)data, hasAudio);
-}
-
-int CSoftAE::RunTranscodeStage(bool hasAudio)
-{
-  if (!m_encoder) return 0;
-  
-  /* if we dont have enough samples to encode yet, return */
-  unsigned int block     = m_encoderFormat.m_frames * m_encoderFormat.m_frameSize;
-  unsigned int sinkBlock = m_sinkFormat.m_frames    * m_sinkFormat.m_frameSize;
-
-  int encodedFrames = 0;
-  if (m_buffer.Used() >= block && m_encodedBuffer.Used() < sinkBlock * 2)
-  {
-    hasAudio = FinalizeSamples((float*)m_buffer.Raw(block), m_encoderFormat.m_frameSamples, hasAudio);
-
-    void *buffer;
-    if (m_convertFn)
-    {
-      unsigned int newsize = m_encoderFormat.m_frames * m_encoderFormat.m_frameSize;
-      AllocateConvIfNeeded(newsize, !hasAudio);
-      if (hasAudio)
-        m_convertFn((float*)m_buffer.Raw(block),
-          m_encoderFormat.m_frames * m_encoderFormat.m_channelLayout.Count(), m_converted);
-      buffer = m_converted;
-    }
-    else
-      buffer = m_buffer.Raw(block);
-
-    encodedFrames = m_encoder->Encode((float*)buffer, m_encoderFormat.m_frames);
-
-    uint8_t *packet;
-    unsigned int size = m_encoder->GetData(&packet);
-
-    CExclusiveLock sinkLock(m_sinkLock); /* lock to maintain delay consistency */
-
-    /* if there is not enough space for another encoded packet enlarge the buffer */
-    if (m_encodedBuffer.Free() < size)
-      m_encodedBuffer.ReAlloc(m_encodedBuffer.Used() + size);
-
-    m_buffer.Shift(NULL, encodedFrames * m_encoderFormat.m_frameSize);
-    m_encodedBuffer.Push(packet, size);
-  }
-
-  /* if we have enough data to write */
-  if (m_encodedBuffer.Used() >= sinkBlock)
-    WriteSink(m_encodedBuffer, sinkBlock, (uint8_t*)m_encodedBuffer.Raw(sinkBlock), hasAudio);
-
-  return encodedFrames;
-}
-
-void CSoftAE::PrintSinks()
-{
-  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
-  {
-    CLog::Log(LOGNOTICE, "Enumerated %s devices:", itt->m_sinkName.c_str());
-    int count = 0;
-    for (AEDeviceInfoList::iterator itt2 = itt->m_deviceInfoList.begin(); itt2 != itt->m_deviceInfoList.end(); ++itt2)
-    {
-      CLog::Log(LOGNOTICE, "    Device %d", ++count);
-      CAEDeviceInfo& info = *itt2;
-      std::stringstream ss((std::string)info);
-      std::string line;
-      while(std::getline(ss, line, '\n'))
-        CLog::Log(LOGNOTICE, "        %s", line.c_str());
-    }
-  }
-}
-
-unsigned int CSoftAE::RunRawStreamStage(unsigned int channelCount, void *out, bool &restart)
-{
-  StreamList resumeStreams;
-  static StreamList::iterator itt;
-  CSingleLock streamLock(m_streamLock);
-  /* handle playing streams */
-  for (itt = m_playingStreams.begin(); itt != m_playingStreams.end(); ++itt)
-  {
-    CSoftAEStream *sitt = *itt;
-    if (sitt == m_masterStream)
-      continue;
-
-    /* consume data from streams even though we cant use it */
-    uint8_t *frame = sitt->GetFrame();
-
-    /* flag the stream's slave to be resumed if it has drained */
-    if (!frame && sitt->IsDrained() && sitt->m_slave && sitt->m_slave->IsPaused())
-      resumeStreams.push_back(sitt);
-  }
-
-  /* nothing to do if we dont have a master stream */
-  if (!m_masterStream)
-    return 0;
-
-  /* get the frame and append it to the output */
-  uint8_t *frame = m_masterStream->GetFrame();
-  unsigned int mixed;
-  if (frame)
-  {
-    mixed = 1;
-    memcpy(out, frame, m_sinkFormat.m_frameSize);
-  }
-  else
-  {
-    mixed = 0;
-    if (m_masterStream->IsDrained() && m_masterStream->m_slave && m_masterStream->m_slave->IsPaused())
-      resumeStreams.push_back(m_masterStream);
-  }
-
-  ResumeSlaveStreams(resumeStreams);
-  return mixed;
-}
-
-unsigned int CSoftAE::RunStreamStage(unsigned int channelCount, void *out, bool &restart)
-{
-  // no point doing anything if we have no streams,
-  // we do not have to take a lock just to check empty
-  if (m_playingStreams.empty())
-    return 0;
-
-  float *dst = (float*)out;
-  unsigned int mixed = 0;
-
-  /* identify the master stream */
-  CSingleLock streamLock(m_streamLock);
-
-  /* mix in any running streams */
-  StreamList resumeStreams;
-  for (StreamList::iterator itt = m_playingStreams.begin(); itt != m_playingStreams.end(); ++itt)
-  {
-    CSoftAEStream *stream = *itt;
-
-    float *frame = (float*)stream->GetFrame();
-    if (!frame && stream->IsDrained() && stream->m_slave && stream->m_slave->IsPaused())
-      resumeStreams.push_back(stream);
-
-    if (!frame)
-      continue;
-
-    float volume = stream->GetVolume() * stream->GetReplayGain() * stream->RunLimiter(frame, channelCount);
-    #ifdef __SSE__
-    if (channelCount > 1)
-      CAEUtil::SSEMulAddArray(dst, frame, volume, channelCount);
-    else
-    #endif
-    {
-      for (unsigned int i = 0; i < channelCount; ++i)
-        *dst++ += *frame++ * volume;
-    }
-
-    ++mixed;
-  }
-
-  ResumeSlaveStreams(resumeStreams);
-  return mixed;
-}
-
-inline void CSoftAE::ResumeSlaveStreams(const StreamList &streams)
-{
-  if (streams.empty())
-    return;
-
-  /* resume any streams that need to be */
-  for (StreamList::const_iterator itt = streams.begin(); itt != streams.end(); ++itt)
-  {
-    CSoftAEStream *stream = *itt;
-    m_playingStreams.push_back(stream->m_slave);
-    stream->m_slave->m_paused = false;
-    stream->m_slave = NULL;
-  }
-}
-
-inline void CSoftAE::RemoveStream(StreamList &streams, CSoftAEStream *stream)
-{
-  StreamList::iterator f = std::find(streams.begin(), streams.end(), stream);
-  if (f != streams.end())
-    streams.erase(f);
-
-  if (streams == m_playingStreams)
-    m_streamsPlaying = !m_playingStreams.empty();
-}
-
-inline void CSoftAE::ProcessSuspend()
-{
-#if defined(TARGET_WINDOWS) || defined(TARGET_LINUX)
-  if (!m_softSuspend && m_playingStreams.empty() && m_playing_sounds.empty() &&
-      !g_advancedSettings.m_streamSilence)
-  {
-    m_softSuspend = true;
-    m_softSuspendTimeout.Set(10000); //10.0 second delay for softSuspend
-    Sleep(10);
-  }
-
-#endif
-  /* idle while in Suspend() state until Resume() called */
-  /* idle if nothing to play and user hasn't enabled     */
-  /* continuous streaming (silent stream) in as.xml      */
-  /* In case of Suspend stay in there until Resume is called from outer thread */
-  while (m_isSuspended || ((m_softSuspend && m_softSuspendTimeout.IsTimePast()) &&
-          m_running     && !m_reOpen))
-  {
-    if (!m_isSuspended && m_sink && !m_sinkIsSuspended)
-    {
-      /* put the sink in Suspend mode */
-      CExclusiveLock sinkLock(m_sinkLock);
-      if (m_sink && !m_sink->SoftSuspend())
-      {
-        m_sinkIsSuspended = false; //sink cannot be suspended
-        m_softSuspend   = false; //break suspend loop
-        break;
-      }
-      else
-      {
-        CLog::Log(LOGDEBUG, "Suspended the Sink");
-        m_sinkIsSuspended = true; //sink has suspended processing
-      }
-      sinkLock.Leave();
-    }
-    // Signal that the Suspend can go on now.
-    // Idea: Outer thread calls Suspend() - but
-    // because of AddPackets does not care about locks, we must make
-    // sure, that our school bus (AE::Run) is currently driving through
-    // some gas station, before we move away the sink.
-    if(m_isSuspended)
-      m_saveSuspend.Set();
-
-    /* idle for platform-defined time */
-    m_wake.WaitMSec(SOFTAE_IDLE_WAIT_MSEC);
-
-    /* check if we need to resume for stream or sound or somebody wants to open us
-     * the suspend checks are only there to:
-     * a) not run out of softSuspend directly when we are sleeping
-     * b) nail(!) the thread during real Suspend into this method
-     * Note: It is not enough to check the streams buffer, cause it might not be filled yet
-     * We have to check after ProcessSuspending() if the sink is still in softsleep and resume it
-     */
-    if (!m_isSuspended && (!m_playingStreams.empty() || !m_playing_sounds.empty()))
-    {
-      // the sink might still be not initialized after Resume of real suspend
-      m_reOpen = m_sink && (!m_sink->SoftResume() || m_reOpen); // sink returns false if it requires reinit (worthless with current implementation)
-      m_sinkIsSuspended = false; //sink processing data
-      m_softSuspend   = false; //break suspend loop (under some conditions)
-      CLog::Log(LOGDEBUG, "Resumed the Sink");
-      break;
-    }
-  }
-}
-
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
deleted file mode 100644
index 4415f76..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
+++ /dev/null
@@ -1,253 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <list>
-#include <vector>
-#include <map>
-
-#include "system.h"
-#include "threads/Thread.h"
-#include "threads/CriticalSection.h"
-#include "threads/SharedSection.h"
-#include "threads/SystemClock.h"
-
-#include "Interfaces/ThreadedAE.h"
-#include "Utils/AEBuffer.h"
-#include "Utils/AEAudioFormat.h"
-#include "AESinkFactory.h"
-
-#include "SoftAEStream.h"
-#include "SoftAESound.h"
-
-#include "cores/IAudioCallback.h"
-
-/* forward declarations */
-class IAESink;
-class IAEEncoder;
-
-class CSoftAE : public IThreadedAE
-{
-protected:
-  friend class CAEFactory;
-  CSoftAE();
-  virtual ~CSoftAE();
-
-public:
-  virtual void  Shutdown();
-  virtual bool  Initialize();
-  virtual void  OnSettingsChange(const std::string& setting);
-
-  virtual void   Run();
-  virtual void   Stop();
-  virtual bool   Suspend();
-  virtual bool   Resume();
-  virtual bool   IsSuspended();
-  virtual double GetDelay();
-
-  virtual float GetVolume();
-  virtual void  SetVolume(const float volume);
-  virtual void  SetMute(const bool enabled) { m_muted = enabled; }
-  virtual bool  IsMuted() { return m_muted; }
-  virtual void  SetSoundMode(const int mode);
-
-  /* returns a new stream for data in the specified format */
-  virtual IAEStream *MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options = 0);
-  virtual IAEStream *FreeStream(IAEStream *stream);
-
-  /* returns a new sound object */
-  virtual IAESound *MakeSound(const std::string& file);
-  virtual void      FreeSound(IAESound *sound);
-  void PlaySound(IAESound *sound);
-  void StopSound(IAESound *sound);
-
-  /* free's sounds that have expired */
-  virtual void GarbageCollect();
-
-  /* these are for the streams so they can provide compatible data */
-  unsigned int          GetSampleRate   ();
-  unsigned int          GetChannelCount () {return m_chLayout.Count()      ;}
-  CAEChannelInfo&       GetChannelLayout() {return m_chLayout              ;}
-  enum AEStdChLayout    GetStdChLayout  () {return m_stdChLayout           ;}
-  unsigned int          GetFrames       () {return m_sinkFormat.m_frames   ;}
-  unsigned int          GetFrameSize    () {return m_frameSize             ;}
-
-  /* these are for streams that are in RAW mode */
-  const AEAudioFormat*  GetSinkAudioFormat() {return &m_sinkFormat               ;}
-  enum AEDataFormat     GetSinkDataFormat () {return m_sinkFormat.m_dataFormat   ;}
-  CAEChannelInfo&       GetSinkChLayout   () {return m_sinkFormat.m_channelLayout;}
-  unsigned int          GetSinkFrameSize  () {return m_sinkFormat.m_frameSize    ;}
-
-  /* for streams so they can calc cachetimes correct */
-  double GetCacheTime();
-  double GetCacheTotal();
-
-  virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
-  virtual std::string GetDefaultDevice(bool passthrough);
-  virtual bool SupportsRaw();
-
-  /* internal stream methods */
-  void PauseStream (CSoftAEStream *stream);
-  void ResumeStream(CSoftAEStream *stream);
-
-private:
-  CThread *m_thread;
-
-  CSoftAEStream *GetMasterStream();
-
-  void LoadSettings();
-  void VerifySoundDevice(std::string &device, bool passthrough);
-  void OpenSink();
-
-  void InternalOpenSink();
-  void InternalCloseSink();
-  void ResetEncoder();
-  bool SetupEncoder(AEAudioFormat &format);
-  void Deinitialize();
-
-  inline void ProcessSuspend(); /* enter suspend state if nothing to play and sink allows */
-
-  inline void GetDeviceFriendlyName(std::string &device);
-
-  IAESink *GetSink(AEAudioFormat &desiredFormat, bool passthrough, std::string &device);
-  void StopAllSounds();
-
-  enum AEStdChLayout m_stdChLayout;
-  std::string m_device;
-  std::string m_passthroughDevice;
-  std::string m_deviceFriendlyName;
-  bool m_audiophile;
-  bool m_stereoUpmix;
-
-  /* internal vars */
-  bool             m_running, m_reOpen;
-  bool             m_sinkIsSuspended; /* The sink is in unusable state, e.g. SoftSuspended */
-  bool             m_isSuspended;      /* engine suspended by external function to release audio context */
-  bool             m_softSuspend;      /* latches after last stream or sound played for timer below for idle */
-  XbmcThreads::EndTime m_softSuspendTimeout; /* timer to hold sink open before soft suspend for idle */
-  CEvent           m_reOpenEvent;
-  CEvent           m_wake;
-  CEvent           m_saveSuspend;
-
-  CCriticalSection m_runningLock;     /* released when the thread exits */
-  CCriticalSection m_streamLock;      /* m_streams lock */
-  CCriticalSection m_soundLock;       /* m_sounds lock */
-  CCriticalSection m_soundSampleLock; /* m_playing_sounds lock */
-  CSharedSection   m_sinkLock;        /* lock for m_sink on re-open */
-  CCriticalSection m_threadLock;      /* locked while starting/stopping the thread */
-
-  /* the current configuration */
-  float               m_volume;
-  bool                m_muted;
-  CAEChannelInfo      m_chLayout;
-  unsigned int        m_frameSize;
-  double              m_frameSizeMul;
-
-  /* the sink, its format information, and conversion function */
-  AESinkInfoList            m_sinkInfoList;
-  IAESink                  *m_sink;
-  AEAudioFormat             m_sinkFormat;
-  double                    m_sinkFormatSampleRateMul;
-  unsigned int              m_sinkBlockSize;
-  unsigned int              m_sinkBlockTime;
-  bool                      m_sinkHandlesVolume;
-  AEAudioFormat             m_encoderFormat;
-  double                    m_encoderFrameSizeMul;
-  double                    m_encoderInitSampleRateMul;
-  unsigned int              m_bytesPerSample;
-  CAEConvert::AEConvertFrFn m_convertFn;
-
-  /* currently playing sounds */
-  typedef struct {
-    CSoftAESound *owner;
-    float        *samples;
-    unsigned int  sampleCount;
-  } SoundState;
-
-  typedef std::vector<CSoftAEStream*> StreamList;
-  typedef std::list  <CSoftAESound* > SoundList;
-  typedef std::list  <SoundState    > SoundStateList;  
-    
-  /* the streams, sounds, output buffer and output buffer fill size */
-  bool           m_transcode;
-  bool           m_rawPassthrough;
-  StreamList     m_newStreams, m_streams, m_playingStreams;
-  SoundList      m_sounds;
-  SoundStateList m_playing_sounds;
-  int            m_soundMode;
-  bool           m_streamsPlaying;
-
-  /* this will contain either float, or uint8_t depending on if we are in raw mode or not */
-  CAEBuffer      m_buffer;
-
-  /* the encoder */
-  IAEEncoder    *m_encoder;
-  CAEBuffer      m_encodedBuffer;
-
-  /* the output conversion buffer  */
-  uint8_t        *m_converted;
-  size_t          m_convertedSize;
-
-  void         AllocateConvIfNeeded(size_t convertedSize, bool prezero = false);
-
-  /* thread run stages */
-
-  /*! \brief Mix UI sounds into the current stream.
-   \param buffer the buffer to mix into.
-   \param samples the number of samples in the buffer.
-   \return the number of sounds mixed into the buffer.
-   */
-  unsigned int MixSounds        (float *buffer, unsigned int samples);
-
-  /*! \brief Finalize samples ready for sending to the output device.
-   Mixes in any UI sounds, applies volume adjustment, and clamps to [-1,1].
-   \param buffer the audio data.
-   \param samples the number of samples in the buffer.
-   \param hasAudio whether we have audio from a stream (true) or silence (false)
-   \return true if we have audio to output, false if we have only silence.
-   */
-  bool         FinalizeSamples  (float *buffer, unsigned int samples, bool hasAudio);
-
-  CSoftAEStream *m_masterStream;
-
-  /*! \brief Run the output stage on the audio.
-   Prepares streamed data, mixes in any UI sounds, converts to a format suitable
-   for the sink, then outputs to the sink.
-   \param hasAudio whether or not we have audio (true) or silence (false).
-   \return the number of samples sent to the sink.
-   */
-  int          (CSoftAE::*m_outputStageFn)(bool);
-  int          RunOutputStage   (bool hasAudio);
-  int          RunRawOutputStage(bool hasAudio);
-  int          RunTranscodeStage(bool hasAudio);
-
-  unsigned int (CSoftAE::*m_streamStageFn)(unsigned int channelCount, void *out, bool &restart);
-  unsigned int RunRawStreamStage (unsigned int channelCount, void *out, bool &restart);
-  unsigned int RunStreamStage    (unsigned int channelCount, void *out, bool &restart);
-
-  void         ResumeSlaveStreams(const StreamList &streams);
-  void         RunNormalizeStage (unsigned int channelCount, void *out, unsigned int mixed);
-
-  void         RemoveStream(StreamList &streams, CSoftAEStream *stream);
-  void         PrintSinks();
-
-  unsigned int WriteSink(CAEBuffer& src, unsigned int src_len, uint8_t *data, bool hasAudio);
-};
-
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
deleted file mode 100644
index 5fcaccf..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "Interfaces/AESound.h"
-
-#include <samplerate.h>
-#include "threads/SingleLock.h"
-#include "utils/log.h"
-#include "utils/EndianSwap.h"
-
-#include "AEFactory.h"
-#include "Utils/AEAudioFormat.h"
-
-#include "SoftAE.h"
-#include "SoftAESound.h"
-
-/* typecast AE to CSoftAE */
-#define AE (*((CSoftAE*)CAEFactory::GetEngine()))
-
-CSoftAESound::CSoftAESound(const std::string &filename) :
-  IAESound         (filename),
-  m_filename       (filename),
-  m_volume         (1.0f    ),
-  m_inUse          (0       )
-{
-  m_wavLoader.Load(filename);
-}
-
-CSoftAESound::~CSoftAESound()
-{
-}
-
-void CSoftAESound::DeInitialize()
-{
-}
-
-bool CSoftAESound::IsCompatible()
-{
-  if (!m_wavLoader.IsValid())
-    return false;
-
-  return m_wavLoader.IsCompatible(AE.GetSampleRate(), AE.GetChannelLayout());
-}
-
-bool CSoftAESound::Initialize()
-{
-  if (!m_wavLoader.IsValid())
-    return false;
-
-  return m_wavLoader.Initialize(
-    AE.GetSampleRate   (),
-    AE.GetChannelLayout(),
-    AE.GetStdChLayout  ()
-  );
-}
-
-unsigned int CSoftAESound::GetSampleCount()
-{
-  CSingleLock cs(m_critSection);
-  if (m_wavLoader.IsValid())
-    return m_wavLoader.GetSampleCount();
-  return 0;
-}
-
-float* CSoftAESound::GetSamples()
-{
-  CSingleLock cs(m_critSection);
-  if (!m_wavLoader.IsValid())
-    return NULL;
-
-  ++m_inUse;
-  return m_wavLoader.GetSamples();
-}
-
-void CSoftAESound::ReleaseSamples()
-{
-  CSingleLock cs(m_critSection);
-  ASSERT(m_inUse > 0);
-  --m_inUse;
-}
-
-bool CSoftAESound::IsPlaying()
-{
-  CSingleLock cs(m_critSection);
-  return (m_inUse > 0);
-}
-
-void CSoftAESound::Play()
-{
-  AE.PlaySound(this);
-}
-
-void CSoftAESound::Stop()
-{
-  AE.StopSound(this);
-}
-
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h
deleted file mode 100644
index cd50c0b..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "utils/StdString.h"
-#include "threads/CriticalSection.h"
-#include "threads/SharedSection.h"
-#include "Interfaces/AESound.h"
-#include "Utils/AEWAVLoader.h"
-
-class CSoftAESound : public IAESound
-{
-public:
-  CSoftAESound (const std::string &filename);
-  virtual ~CSoftAESound();
-
-  virtual void DeInitialize();
-  virtual bool Initialize();
-
-  virtual void   Play();
-  virtual void   Stop();
-  virtual bool   IsPlaying();
-
-  virtual void   SetVolume(float volume) { m_volume = std::max(0.0f, std::min(1.0f, volume)); }
-  virtual float  GetVolume()             { return m_volume      ; }
-
-  bool         IsCompatible();
-  unsigned int GetSampleCount();
-
-  /* ReleaseSamples must be called for each time GetSamples has been called */
-  virtual float* GetSamples    ();
-  void           ReleaseSamples();
-private:
-  CCriticalSection m_critSection;
-  std::string      m_filename;
-  CAEWAVLoader     m_wavLoader;
-  float            m_volume;
-  int              m_inUse;
-};
-
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
deleted file mode 100644
index b5c2da3..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
+++ /dev/null
@@ -1,687 +0,0 @@
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "system.h"
-#include "threads/SingleLock.h"
-#include "utils/log.h"
-#include "utils/MathUtils.h"
-
-#include "AEFactory.h"
-#include "Utils/AEUtil.h"
-
-#include "SoftAE.h"
-#include "SoftAEStream.h"
-
-#ifdef TARGET_WINDOWS
-#pragma comment(lib, "libsamplerate-0.lib")
-#endif
-
-/* typecast AE to CSoftAE */
-#define AE (*((CSoftAE*)CAEFactory::GetEngine()))
-
-using namespace std;
-
-CSoftAEStream::CSoftAEStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options, CCriticalSection& lock) :
-  m_lock            (lock ),
-  m_resampleRatio   (1.0  ),
-  m_internalRatio   (1.0  ),
-  m_convertBuffer   (NULL ),
-  m_valid           (false),
-  m_delete          (false),
-  m_volume          (1.0f ),
-  m_rgain           (1.0f ),
-  m_refillBuffer    (0    ),
-  m_convertFn       (NULL ),
-  m_ssrc            (NULL ),
-  m_framesBuffered  (0    ),
-  m_newPacket       (NULL ),
-  m_packet          (NULL ),
-  m_vizPacketPos    (NULL ),
-  m_draining        (false),
-  m_vizBufferSamples(0    ),
-  m_audioCallback   (NULL ),
-  m_fadeRunning     (false),
-  m_slave           (NULL )
-{
-  m_ssrcData.data_out = NULL;
-
-  m_initDataFormat        = dataFormat;
-  m_initSampleRate        = sampleRate;
-  m_initEncodedSampleRate = encodedSampleRate;
-  m_initChannelLayout     = channelLayout;
-  m_chLayoutCount         = channelLayout.Count();
-  m_forceResample         = (options & AESTREAM_FORCE_RESAMPLE) != 0;
-  m_paused                = (options & AESTREAM_PAUSED) != 0;
-  m_autoStart             = (options & AESTREAM_AUTOSTART) != 0;
-
-  if (m_autoStart)
-    m_paused = true;
-
-  ASSERT(m_initChannelLayout.Count());
-}
-
-void CSoftAEStream::InitializeRemap()
-{
-  CSingleLock lock(m_lock);
-
-  if (!AE_IS_RAW(m_initDataFormat))
-  {
-    /* re-init the remappers */
-    m_remap   .Initialize(m_initChannelLayout, AE.GetChannelLayout()           , false, false, AE.GetStdChLayout());
-    m_vizRemap.Initialize(m_initChannelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
-
-    /*
-    if the layout has changed we need to drop data that was already remapped
-    */
-    if (AE.GetChannelLayout() != m_aeChannelLayout)
-    {
-      InternalFlush();
-      m_aeChannelLayout = AE.GetChannelLayout();
-      m_samplesPerFrame = AE.GetChannelLayout().Count();
-      m_aeBytesPerFrame = AE_IS_RAW(m_initDataFormat) ? m_bytesPerFrame : (m_samplesPerFrame * sizeof(float));
-    }
-  }
-}
-
-void CSoftAEStream::Initialize()
-{
-  CSingleLock lock(m_lock);
-
-  if (m_valid)
-  {
-    InternalFlush();
-    delete m_newPacket;
-
-    if (m_convert)
-      _aligned_free(m_convertBuffer);
-
-    if (m_resample)
-    {
-      _aligned_free(m_ssrcData.data_out);
-      m_ssrcData.data_out = NULL;
-    }
-  }
-
-  enum AEDataFormat useDataFormat = m_initDataFormat;
-  if (AE_IS_RAW(m_initDataFormat))
-  {
-    /* we are raw, which means we need to work in the output format */
-    useDataFormat       = AE.GetSinkDataFormat();
-    m_initChannelLayout = AE.GetSinkChLayout  ();
-    m_samplesPerFrame   = m_initChannelLayout.Count();
-  }
-  else
-  {
-    if (!m_initChannelLayout.Count())
-    {
-      m_valid = false;
-      return;
-    }
-    m_samplesPerFrame = AE.GetChannelLayout().Count();
-  }
-
-  m_bytesPerSample  = (CAEUtil::DataFormatToBits(useDataFormat) >> 3);
-  m_bytesPerFrame   = m_bytesPerSample * m_initChannelLayout.Count();
-
-  m_aeChannelLayout = AE.GetChannelLayout();
-  m_aeBytesPerFrame = AE_IS_RAW(m_initDataFormat) ? m_bytesPerFrame : (m_samplesPerFrame * sizeof(float));
-  // set the waterlevel to 75 percent of the number of frames per second.
-  // this lets us drain the main buffer down futher before flagging an underrun.
-  m_waterLevel      = AE.GetSampleRate() - (AE.GetSampleRate() / 4);
-  m_refillBuffer    = m_waterLevel;
-
-  m_format.m_dataFormat    = useDataFormat;
-  m_format.m_sampleRate    = m_initSampleRate;
-  m_format.m_encodedRate   = m_initEncodedSampleRate;
-  m_format.m_channelLayout = m_initChannelLayout;
-  m_format.m_frames        = m_initSampleRate / 8;
-  m_format.m_frameSamples  = m_format.m_frames * m_initChannelLayout.Count();
-  m_format.m_frameSize     = m_bytesPerFrame;
-
-  m_newPacket = new PPacket();
-  if (AE_IS_RAW(m_initDataFormat))
-    m_newPacket->data.Alloc(m_format.m_frames * m_format.m_frameSize);
-  else
-  {
-    if (
-      !m_remap   .Initialize(m_initChannelLayout, m_aeChannelLayout               , false, false, AE.GetStdChLayout()) ||
-      !m_vizRemap.Initialize(m_initChannelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true))
-    {
-      m_valid = false;
-      return;
-    }
-
-    m_newPacket->data.Alloc(m_format.m_frameSamples * sizeof(float));
-  }
-
-  m_packet = NULL;
-
-  m_inputBuffer.Alloc(m_format.m_frames * m_format.m_frameSize);
-
-  m_resample      = (m_forceResample || m_initSampleRate != AE.GetSampleRate()) && !AE_IS_RAW(m_initDataFormat);
-  m_convert       = m_initDataFormat != AE_FMT_FLOAT && !AE_IS_RAW(m_initDataFormat);
-
-  /* if we need to convert, set it up */
-  if (m_convert)
-  {
-    /* get the conversion function and allocate a buffer for the data */
-    CLog::Log(LOGDEBUG, "CSoftAEStream::CSoftAEStream - Converting from %s to AE_FMT_FLOAT", CAEUtil::DataFormatToStr(m_initDataFormat));
-    m_convertFn = CAEConvert::ToFloat(m_initDataFormat);
-    if (m_convertFn)
-      m_convertBuffer = (float*)_aligned_malloc(m_format.m_frameSamples * sizeof(float), 16);
-    else
-      m_valid         = false;
-  }
-  else
-    m_convertBuffer = (float*)m_inputBuffer.Raw(m_format.m_frames * m_format.m_frameSize);
-
-  /* if we need to resample, set it up */
-  if (m_resample)
-  {
-    int err;
-    m_ssrc                   = src_new(SRC_SINC_MEDIUM_QUALITY, m_initChannelLayout.Count(), &err);
-    m_ssrcData.data_in       = m_convertBuffer;
-    m_internalRatio          = (double)AE.GetSampleRate() / (double)m_initSampleRate;
-    m_ssrcData.src_ratio     = m_internalRatio;
-    m_ssrcData.data_out      = (float*)_aligned_malloc(m_format.m_frameSamples * (int)std::ceil(m_ssrcData.src_ratio) * sizeof(float), 16);
-    m_ssrcData.output_frames = m_format.m_frames * (long)std::ceil(m_ssrcData.src_ratio);
-    m_ssrcData.end_of_input  = 0;
-    // we must buffer the same amount as before but taking the source sample rate into account
-    // there is no reason to decrease the buffer for upsampling
-    if (m_internalRatio < 1)
-    {
-      m_waterLevel *= (1.0 / m_internalRatio);
-      m_refillBuffer = m_waterLevel;
-    }
-  }
-
-  m_limiter.SetSamplerate(AE.GetSampleRate());
-
-  m_chLayoutCount = m_format.m_channelLayout.Count();
-  m_valid = true;
-}
-
-void CSoftAEStream::Destroy()
-{
-  CSingleLock lock(m_lock);
-
-  m_valid       = false;
-  m_delete      = true;
-}
-
-CSoftAEStream::~CSoftAEStream()
-{
-  CSingleLock lock(m_lock);
-
-  InternalFlush();
-  if (m_convert)
-    _aligned_free(m_convertBuffer);
-
-  if (m_resample)
-  {
-    _aligned_free(m_ssrcData.data_out);
-    src_delete(m_ssrc);
-    m_ssrc = NULL;
-  }
-
-  delete m_newPacket;
-  delete m_packet;
-
-  CLog::Log(LOGDEBUG, "CSoftAEStream::~CSoftAEStream - Destructed");
-}
-
-unsigned int CSoftAEStream::GetSpace()
-{
-  CSingleLock lock(m_lock);
-
-  if (!m_valid || m_draining)
-    return 0;
-
-  if (m_framesBuffered >= m_waterLevel)
-    return 0;
-
-  return m_inputBuffer.Free() + (std::max(0U, (m_waterLevel - m_framesBuffered)) * m_format.m_frameSize);
-}
-
-unsigned int CSoftAEStream::AddData(void *data, unsigned int size)
-{
-  CSingleLock lock(m_lock);
-
-  if (!m_valid || size == 0 || data == NULL)
-    return 0;
-
-  /* if the stream is draining */
-  if (m_draining)
-  {
-    /* if the stream has finished draining, cork it */
-    if (m_packet && !m_packet->data.Used() && m_outBuffer.empty())
-      m_draining = false;
-    else
-      return 0;
-  }
-
-  /* dont ever take more then GetSpace advertises */
-  size = std::min(size, GetSpace());
-  if (size == 0)
-    return 0;
-
-  unsigned int taken = 0;
-  while(size)
-  {
-    unsigned int copy = std::min((unsigned int)m_inputBuffer.Free(), size);
-    if (copy > 0)
-    {
-      m_inputBuffer.Push(data, copy);
-      size  -= copy;
-      taken += copy;
-      data   = (uint8_t*)data + copy;
-    }
-
-    if (m_inputBuffer.Free() == 0)
-    {
-      unsigned int consumed = ProcessFrameBuffer();
-      m_inputBuffer.Shift(NULL, consumed);
-    }
-  }
-
-  lock.Leave();
-
-  /* if the stream is flagged to autoStart when the buffer is full, then do it */
-  if (m_autoStart && m_framesBuffered >= m_waterLevel)
-    Resume();
-
-  return taken;
-}
-
-unsigned int CSoftAEStream::ProcessFrameBuffer()
-{
-  uint8_t     *data;
-  unsigned int frames, consumed, sampleSize;
-
-  /* convert the data if we need to */
-  unsigned int samples;
-  if (m_convert)
-  {
-    data       = (uint8_t*)m_convertBuffer;
-    samples    = m_convertFn(
-      (uint8_t*)m_inputBuffer.Raw(m_inputBuffer.Used()),
-      m_inputBuffer.Used() / m_bytesPerSample,
-      m_convertBuffer
-    );
-    sampleSize = sizeof(float);
-  }
-  else
-  {
-    data       = (uint8_t*)m_inputBuffer.Raw(m_inputBuffer.Used());
-    samples    = m_inputBuffer.Used() / m_bytesPerSample;
-    sampleSize = m_bytesPerSample;
-  }
-
-  if (samples == 0)
-    return 0;
-
-  /* resample it if we need to */
-  if (m_resample)
-  {
-    m_ssrcData.input_frames = samples / m_chLayoutCount;
-    if (src_process(m_ssrc, &m_ssrcData) != 0)
-      return 0;
-    data     = (uint8_t*)m_ssrcData.data_out;
-    frames   = m_ssrcData.output_frames_gen;
-    consumed = m_ssrcData.input_frames_used * m_bytesPerFrame;
-    if (!frames)
-      return consumed;
-
-    samples = frames * m_chLayoutCount;
-  }
-  else
-  {
-    data     = (uint8_t*)m_convertBuffer;
-    frames   = samples / m_chLayoutCount;
-    consumed = frames * m_bytesPerFrame;
-  }
-
-  if (m_refillBuffer)
-  {
-    if (frames > m_refillBuffer)
-      m_refillBuffer = 0;
-    else
-      m_refillBuffer -= frames;
-  }
-
-  /* buffer the data */
-  m_framesBuffered += frames;
-  const unsigned int inputBlockSize = m_format.m_frames * m_format.m_channelLayout.Count() * sampleSize;
-
-  size_t remaining = samples * sampleSize;
-  while (remaining)
-  {
-    size_t copy = std::min(m_newPacket->data.Free(), remaining);
-    m_newPacket->data.Push(data, copy);
-    data      += copy;
-    remaining -= copy;
-
-    /* wait till we have a full packet, or no more data before processing the packet */
-    if ((!m_draining || remaining) && m_newPacket->data.Free() > 0)
-      continue;
-
-    /* if we have a full block of data */
-    if (AE_IS_RAW(m_initDataFormat))
-    {
-      m_outBuffer.push_back(m_newPacket);
-      m_newPacket = new PPacket();
-      m_newPacket->data.Alloc(inputBlockSize);
-      continue;
-    }
-
-    /* make a new packet for downmix/remap */
-    PPacket *pkt = new PPacket();
-
-    /* downmix/remap the data */
-    size_t frames = m_newPacket->data.Used() / m_format.m_channelLayout.Count() / sizeof(float);
-    size_t used   = frames * m_aeChannelLayout.Count() * sizeof(float);
-    pkt->data.Alloc(used);
-    m_remap.Remap(
-      (float*)m_newPacket->data.Raw (m_newPacket->data.Used()),
-      (float*)pkt        ->data.Take(used),
-      frames
-    );
-
-    /* downmix for the viz if we have one */
-    if (m_audioCallback)
-    {
-      size_t vizUsed = frames * 2 * sizeof(float);
-      pkt->vizData.Alloc(vizUsed);
-      m_vizRemap.Remap(
-        (float*)m_newPacket->data   .Raw (m_newPacket->data.Used()),
-        (float*)pkt        ->vizData.Take(vizUsed),
-        frames
-      );
-    }
-
-    /* add the packet to the output */
-    m_outBuffer.push_back(pkt);
-    m_newPacket->data.Empty();
-  }
-
-  return consumed;
-}
-
-uint8_t* CSoftAEStream::GetFrame()
-{
-  CSingleLock lock(m_lock);
-
-  /* if we are fading, this runs even if we have underrun as it is time based */
-  if (m_fadeRunning)
-  {
-    m_volume += m_fadeStep;
-    m_volume = std::min(1.0f, std::max(0.0f, m_volume));
-    if (m_fadeDirUp)
-    {
-      if (m_volume >= m_fadeTarget)
-        m_fadeRunning = false;
-    }
-    else
-    {
-      if (m_volume <= m_fadeTarget)
-        m_fadeRunning = false;
-    }
-  }
-
-  /* if we have been deleted or are refilling but not draining */
-  if (!m_valid || m_delete || (m_refillBuffer && !m_draining))
-    return NULL;
-
-  /* if the packet is empty, advance to the next one */
-  if (!m_packet || m_packet->data.CursorEnd())
-  {
-    delete m_packet;
-    m_packet = NULL;
-
-    /* no more packets, return null */
-    if (m_outBuffer.empty())
-    {
-      if (m_draining)
-        return NULL;
-      else
-      {
-        /* underrun, we need to refill our buffers */
-        CLog::Log(LOGDEBUG, "CSoftAEStream::GetFrame - Underrun");
-        ASSERT(m_waterLevel > m_framesBuffered);
-        m_refillBuffer = m_waterLevel - m_framesBuffered;
-        return NULL;
-      }
-    }
-
-    /* get the next packet */
-    m_packet = m_outBuffer.front();
-    m_outBuffer.pop_front();
-  }
-
-  /* fetch one frame of data */
-  uint8_t *ret = (uint8_t*)m_packet->data.CursorRead(m_aeBytesPerFrame);
-
-  /* we have a frame, if we have a viz we need to hand the data to it */
-  if (m_audioCallback && !m_packet->vizData.CursorEnd())
-  {
-    float *vizData = (float*)m_packet->vizData.CursorRead(2 * sizeof(float));
-    memcpy(m_vizBuffer + m_vizBufferSamples, vizData, 2 * sizeof(float));
-    m_vizBufferSamples += 2;
-    if (m_vizBufferSamples == 512)
-    {
-      m_audioCallback->OnAudioData(m_vizBuffer, 512);
-      m_vizBufferSamples = 0;
-    }
-  }
-
-  --m_framesBuffered;
-  return ret;
-}
-
-double CSoftAEStream::GetDelay()
-{
-  CSingleLock lock(m_lock);
-
-  if (m_delete)
-    return 0.0;
-
-  double delay = AE.GetDelay();
-  delay += (double)(m_inputBuffer.Used() / m_format.m_frameSize) / (double)m_format.m_sampleRate;
-  delay += (double)m_framesBuffered                              / (double)AE.GetSampleRate();
-  return delay;
-}
-
-double CSoftAEStream::GetCacheTime()
-{
-  CSingleLock lock(m_lock);
-
-  if (m_delete)
-    return 0.0;
-
-  double time = AE.GetCacheTime();
-  time += (double)(m_inputBuffer.Used() / m_format.m_frameSize) / (double)m_format.m_sampleRate;
-  time += (double)m_framesBuffered                              / (double)AE.GetSampleRate();
-  return time;
-}
-
-double CSoftAEStream::GetCacheTotal()
-{
-  CSingleLock lock(m_lock);
-
-  if (m_delete)
-    return 0.0;
-
-  double total = AE.GetCacheTotal();
-  total += (double)(m_inputBuffer.Size() / m_format.m_frameSize) / (double)m_format.m_sampleRate;
-  total += (double)m_waterLevel                                  / (double)AE.GetSampleRate();
-  return total;
-}
-
-void CSoftAEStream::Pause()
-{
-  CSingleLock lock(m_lock);
-
-  if (m_paused)
-    return;
-  m_paused = true;
-  AE.PauseStream(this);
-}
-
-void CSoftAEStream::Resume()
-{
-  CSingleLock lock(m_lock);
-
-  if (!m_paused)
-    return;
-  m_paused    = false;
-  m_autoStart = false;
-  AE.ResumeStream(this);
-}
-
-void CSoftAEStream::Drain(bool wait)
-{
-  CSingleLock lock(m_lock);
-  m_draining = true;
-}
-
-bool CSoftAEStream::IsDrained()
-{
-  CSingleLock lock(m_lock);
-  return (m_draining && !m_packet && m_outBuffer.empty());
-}
-
-void CSoftAEStream::Flush()
-{
-  CLog::Log(LOGDEBUG, "CSoftAEStream::Flush");
-  CSingleLock lock(m_lock);
-  InternalFlush();
-
-  /* internal flush does not do this as these samples are still valid if we are re-initializing */
-  m_inputBuffer.Empty();
-}
-
-void CSoftAEStream::InternalFlush()
-{
-  /* reset the resampler */
-  if (m_resample)
-  {
-    m_ssrcData.end_of_input = 0;
-    src_reset(m_ssrc);
-  }
-
-  /* invalidate any incoming samples */
-  m_newPacket->data.Empty();
-
-  /*
-    clear the current buffered packet, we cant delete the data as it may be
-    in use by the AE thread, so we just seek to the end of the buffer
-  */
-  if (m_packet)
-    m_packet->data.CursorSeek(m_packet->data.Size());
-
-  /* clear any other buffered packets */
-  while (!m_outBuffer.empty())
-  {
-    PPacket *p = m_outBuffer.front();
-    m_outBuffer.pop_front();
-    delete p;
-  }
-
-  /* reset our counts */
-  m_framesBuffered = 0;
-  m_refillBuffer   = m_waterLevel;
-  m_draining       = false;
-}
-
-double CSoftAEStream::GetResampleRatio()
-{
-  CSingleLock lock(m_lock);
-  if (!m_resample)
-    return 1.0f;
-
-  return m_ssrcData.src_ratio;
-}
-
-bool CSoftAEStream::SetResampleRatio(double ratio)
-{
-  if (!m_resample)
-    return false;
-
-  CSingleLock lock(m_lock);
-
-  int oldRatioInt = (int)std::ceil(m_ssrcData.src_ratio);
-
-  m_resampleRatio = ratio;
-
-  src_set_ratio(m_ssrc, m_resampleRatio * m_internalRatio);
-  m_ssrcData.src_ratio = m_resampleRatio * m_internalRatio;
-
-  //Check the resample buffer size and resize if necessary.
-  if (oldRatioInt < std::ceil(m_ssrcData.src_ratio))
-  {
-    _aligned_free(m_ssrcData.data_out);
-    m_ssrcData.data_out      = (float*)_aligned_malloc(m_format.m_frameSamples * (int)std::ceil(m_ssrcData.src_ratio) * sizeof(float), 16);
-    m_ssrcData.output_frames = m_format.m_frames * (long)std::ceil(m_ssrcData.src_ratio);
-  }
-  return true;
-}
-
-void CSoftAEStream::RegisterAudioCallback(IAudioCallback* pCallback)
-{
-  CSingleLock lock(m_lock);
-  m_vizBufferSamples = 0;
-  m_audioCallback = pCallback;
-  if (m_audioCallback)
-    m_audioCallback->OnInitialize(2, m_initSampleRate, 32);
-}
-
-void CSoftAEStream::UnRegisterAudioCallback()
-{
-  CSingleLock lock(m_lock);
-  m_audioCallback = NULL;
-  m_vizBufferSamples = 0;
-}
-
-void CSoftAEStream::FadeVolume(float from, float target, unsigned int time)
-{
-  /* can't fade a RAW stream */
-  if (AE_IS_RAW(m_initDataFormat))
-    return;
-
-  CSingleLock lock(m_lock);
-  float delta   = target - from;
-  m_fadeDirUp   = target > from;
-  m_fadeTarget  = target;
-  m_fadeStep    = delta / (((float)AE.GetSampleRate() / 1000.0f) * (float)time);
-  m_fadeRunning = true;
-}
-
-bool CSoftAEStream::IsFading()
-{
-  CSingleLock lock(m_lock);
-  return m_fadeRunning;
-}
-
-void CSoftAEStream::RegisterSlave(IAEStream *slave)
-{
-  CSingleLock lock(m_lock);
-  m_slave = (CSoftAEStream*)slave;
-}
-
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
deleted file mode 100644
index 9ee607c..0000000
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
+++ /dev/null
@@ -1,161 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include <samplerate.h>
-#include <list>
-
-#include "threads/SharedSection.h"
-
-#include "Utils/AEAudioFormat.h"
-#include "Interfaces/AEStream.h"
-#include "Utils/AEConvert.h"
-#include "Utils/AERemap.h"
-#include "Utils/AEBuffer.h"
-#include "Utils/AELimiter.h"
-
-class IAEPostProc;
-class CSoftAEStream : public IAEStream
-{
-protected:
-  friend class CSoftAE;
-  CSoftAEStream(enum AEDataFormat format, unsigned int sampleRate, unsigned int encodedSamplerate, CAEChannelInfo channelLayout, unsigned int options, CCriticalSection& lock);
-  virtual ~CSoftAEStream();
-
-  void Initialize();
-  void InitializeRemap();
-  void Destroy();
-  uint8_t* GetFrame();
-
-  bool IsPaused   () { return m_paused; }
-  bool IsDestroyed() { return m_delete; }
-  bool IsValid    () { return m_valid;  }
-  const bool IsRaw() const { return AE_IS_RAW(m_initDataFormat); }  
-
-public:
-  virtual unsigned int      GetSpace        ();
-  virtual unsigned int      AddData         (void *data, unsigned int size);
-  virtual double            GetDelay        ();
-  virtual bool              IsBuffering     () { return m_refillBuffer > 0; }
-  virtual double            GetCacheTime    ();
-  virtual double            GetCacheTotal   ();
-
-  virtual void              Pause           ();
-  virtual void              Resume          ();
-  virtual void              Drain           (bool wait);
-  virtual bool              IsDraining      () { return m_draining;    }
-  virtual bool              IsDrained       ();
-  virtual void              Flush           ();
-
-  virtual float             GetVolume       ()             { return m_volume; }
-  virtual float             GetReplayGain   ()             { return m_rgain ; }
-  virtual float             GetAmplification()             { return m_limiter.GetAmplification(); }
-  virtual void              SetVolume       (float volume) { m_volume = std::max( 0.0f, std::min(1.0f, volume)); }
-  virtual void              SetReplayGain   (float factor) { m_rgain  = std::max( 0.0f, factor); }
-  virtual void              SetAmplification(float amplify){ m_limiter.SetAmplification(amplify); }
-
-  virtual float             RunLimiter(float* frame, int channels) { return m_limiter.Run(&frame, channels); }
-
-  virtual const unsigned int      GetFrameSize   () const  { return m_format.m_frameSize; }
-  virtual const unsigned int      GetChannelCount() const  { return m_initChannelLayout.Count(); }
-  
-  virtual const unsigned int      GetSampleRate  () const  { return m_initSampleRate; }
-  virtual const unsigned int GetEncodedSampleRate() const  { return m_initEncodedSampleRate; }
-  virtual const enum AEDataFormat GetDataFormat  () const  { return m_initDataFormat; }
-  
-  virtual double            GetResampleRatio();
-  virtual bool              SetResampleRatio(double ratio);
-  virtual void              RegisterAudioCallback(IAudioCallback* pCallback);
-  virtual void              UnRegisterAudioCallback();
-  virtual void              FadeVolume(float from, float to, unsigned int time);
-  virtual bool              IsFading();
-  virtual void              RegisterSlave(IAEStream *stream);
-private:
-  void InternalFlush();
-  void CheckResampleBuffers();
-
-  CCriticalSection& m_lock;
-  enum AEDataFormat m_initDataFormat;
-  unsigned int      m_initSampleRate;
-  unsigned int      m_initEncodedSampleRate;
-  CAEChannelInfo    m_initChannelLayout;
-  unsigned int      m_chLayoutCount;
-  
-  typedef struct
-  {
-    CAEBuffer data;
-    CAEBuffer vizData;
-  } PPacket;
-
-  AEAudioFormat m_format;
-
-  bool                    m_forceResample; /* true if we are to force resample even when the rates match */
-  bool                    m_resample;      /* true if the audio needs to be resampled  */
-  double                  m_resampleRatio; /* user specified resample ratio */
-  double                  m_internalRatio; /* internal resample ratio */ 
-  bool                    m_convert;       /* true if the bitspersample needs converting */
-  float                  *m_convertBuffer; /* buffer for converted data */
-  bool                    m_valid;         /* true if the stream is valid */
-  bool                    m_delete;        /* true if CSoftAE is to free this object */
-  CAERemap                m_remap;         /* the remapper */
-  float                   m_volume;        /* the volume level */
-  float                   m_rgain;         /* replay gain level */
-  unsigned int            m_waterLevel;    /* the fill level to fall below before calling the data callback */
-  unsigned int            m_refillBuffer;  /* how many frames that need to be buffered before we return any frames */
-
-  CAEConvert::AEConvertToFn m_convertFn;
-
-  CAEBuffer           m_inputBuffer;
-  unsigned int        m_bytesPerSample;
-  unsigned int        m_bytesPerFrame;
-  unsigned int        m_samplesPerFrame;
-  CAEChannelInfo      m_aeChannelLayout;
-  unsigned int        m_aeBytesPerFrame;
-  SRC_STATE          *m_ssrc;
-  SRC_DATA            m_ssrcData;
-  unsigned int        m_framesBuffered;
-  std::list<PPacket*> m_outBuffer;
-  unsigned int        ProcessFrameBuffer();
-  PPacket            *m_newPacket;
-  PPacket            *m_packet;
-  uint8_t            *m_packetPos;
-  float              *m_vizPacketPos;
-  bool                m_paused;
-  bool                m_autoStart;
-  bool                m_draining;
-  CAELimiter          m_limiter;
-
-  /* vizualization internals */
-  CAERemap           m_vizRemap;
-  float              m_vizBuffer[512];
-  unsigned int       m_vizBufferSamples;
-  IAudioCallback    *m_audioCallback;
-
-  /* fade values */
-  bool               m_fadeRunning;
-  bool               m_fadeDirUp;
-  float              m_fadeStep;
-  float              m_fadeTarget;
-  unsigned int       m_fadeTime;
-
-  /* slave stream */
-  CSoftAEStream     *m_slave;
-};
-
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index c2d7ffa..c1d53f5 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -39,10 +39,6 @@ SRCS += AESinkFactory.cpp
 SRCS += Sinks/AESinkNULL.cpp
 SRCS += Sinks/AESinkProfiler.cpp
 
-SRCS += Engines/SoftAE/SoftAE.cpp
-SRCS += Engines/SoftAE/SoftAEStream.cpp
-SRCS += Engines/SoftAE/SoftAESound.cpp
-
 SRCS += Engines/ActiveAE/ActiveAE.cpp
 SRCS += Engines/ActiveAE/ActiveAESink.cpp
 SRCS += Engines/ActiveAE/ActiveAEStream.cpp
-- 
1.8.4


From 61495782102287088a98e4e72b5a575413ceb79f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 13:25:23 +0200
Subject: [PATCH 07/94] adapt toggle passthrough to change in audio settings

---
 xbmc/Application.cpp | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a4970a9..b27d49d 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -1610,7 +1610,7 @@ void CApplication::OnSettingChanged(const CSetting *setting)
     }
     // this tells player whether to open an audio stream passthrough or PCM
     // if this is changed, audio stream has to be reopened
-    else if (settingId == "audiooutput.mode")
+    else if (settingId == "audiooutput.passthrough")
     {
       CApplicationMessenger::Get().MediaRestart(false);
       return;
@@ -2764,13 +2764,8 @@ bool CApplication::OnAction(const CAction &action)
 
   if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
   {
-    // TODO
-    // revisit after new audio settings page have been implemented
-    // makes no sense toggling a mode when you have three different settings
-    int mode = CSettings::Get().GetInt("audiooutput.mode");
-    if (++mode == 3)
-      mode = 0;
-    CSettings::Get().SetInt("audiooutput.mode", mode);
+    bool passthrough = CSettings::Get().GetBool("audiooutput.passthrough");
+    CSettings::Get().SetBool("audiooutput.passthrough", !passthrough);
 
     if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
     {
-- 
1.8.4


From 1f202228ab5b17200b5c93fb2752b11ecb9e26ea Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 14:21:39 +0200
Subject: [PATCH 08/94] update VS project after removal of SoftAE

---
 project/VS2010Express/XBMC.vcxproj         |  8 +-------
 project/VS2010Express/XBMC.vcxproj.filters | 18 ------------------
 2 files changed, 1 insertion(+), 25 deletions(-)

diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 65ec4a0..07d723e 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -393,9 +393,6 @@
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAESink.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAESound.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAEStream.cpp" />
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAE.cpp" />
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAESound.cpp" />
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAEStream.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Sinks\AESinkDirectSound.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Sinks\AESinkNULL.cpp" />
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Sinks\AESinkProfiler.cpp" />
@@ -1055,9 +1052,6 @@
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAESink.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAESound.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\ActiveAE\ActiveAEStream.h" />
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAE.h" />
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAESound.h" />
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAEStream.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Interfaces\AE.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Interfaces\AEEncoder.h" />
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Interfaces\AESink.h" />
@@ -2985,4 +2979,4 @@
     </VisualStudio>
   </ProjectExtensions>
   <Import Project="$(SolutionDir)\$(ProjectFileName).targets.user" Condition="Exists('$(SolutionDir)\$(ProjectFileName).targets.user')" />
-</Project>
+</Project>
\ No newline at end of file
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index 570fb6f..74e82c4 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -2316,15 +2316,6 @@
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\AESinkFactory.cpp">
       <Filter>cores\AudioEngine</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAE.cpp">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAESound.cpp">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAEStream.cpp">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\xbmc\cores\AudioEngine\Sinks\AESinkDirectSound.cpp">
       <Filter>cores\AudioEngine\Sinks</Filter>
     </ClCompile>
@@ -5377,15 +5368,6 @@
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\AESinkFactory.h">
       <Filter>cores\AudioEngine</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAE.h">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAESound.h">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\xbmc\cores\AudioEngine\Engines\SoftAE\SoftAEStream.h">
-      <Filter>cores\AudioEngine\Engines</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\xbmc\cores\AudioEngine\Interfaces\AE.h">
       <Filter>cores\AudioEngine\Interfaces</Filter>
     </ClInclude>
-- 
1.8.4


From 3babeb3bde293eb350bac816b59e2e97bac18077 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 18 Oct 2013 14:23:19 +0200
Subject: [PATCH 09/94] fix linker error on Windows after removal of SoftAE

---
 xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
index c8a521c..de9029b 100644
--- a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
@@ -32,6 +32,10 @@
 #include "AEUtil.h"
 #include "AERemap.h"
 
+#ifdef TARGET_WINDOWS
+#pragma comment(lib, "libsamplerate-0.lib")
+#endif 
+
 typedef struct
 {
   char     chunk_id[4];
-- 
1.8.4


From dfe343b2691826ffd0f28cf72e40bdcaebd33539 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 18 Oct 2013 17:06:18 +0200
Subject: [PATCH 10/94] AudioSettings: Remove AAC Setting for passthrough

---
 language/English/strings.po                          | 10 ++--------
 system/settings/darwin.xml                           |  3 ---
 system/settings/rbp.xml                              |  3 ---
 system/settings/settings.xml                         | 13 -------------
 xbmc/cores/AudioEngine/AEFactory.cpp                 |  2 --
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp |  2 --
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h   |  1 -
 xbmc/settings/Settings.cpp                           |  1 -
 8 files changed, 2 insertions(+), 33 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index a403c5d..009e1c0 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -1242,10 +1242,7 @@ msgctxt "#298"
 msgid "Bookmarks"
 msgstr ""
 
-#: system/settings/settings.xml
-msgctxt "#299"
-msgid "AAC capable receiver"
-msgstr ""
+#empty string with id 299
 
 msgctxt "#300"
 msgid "MP1 capable receiver"
@@ -14236,10 +14233,7 @@ msgctxt "#36366"
 msgid "Select this option if your receiver is capable of decoding DTS streams."
 msgstr ""
 
-#: system/settings/settings.xml
-msgctxt "#36367"
-msgid "Select this option if your receiver is capable of decoding AAC streams."
-msgstr ""
+#empty string with id 36367
 
 #: system/settings/settings.xml
 msgctxt "#36368"
diff --git a/system/settings/darwin.xml b/system/settings/darwin.xml
index 817a990..2cf4df6 100644
--- a/system/settings/darwin.xml
+++ b/system/settings/darwin.xml
@@ -8,9 +8,6 @@
     </category>
     <category id="audiooutput">
       <group id="1">
-        <setting id="audiooutput.passthroughaac">
-          <visible>false</visible>
-        </setting>
         <setting id="audiooutput.truehdpassthrough">
           <visible>false</visible>
         </setting>
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index ddd6635..b890555 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -41,9 +41,6 @@
         <setting id="audiooutput.stereoupmix">
           <visible>false</visible>
         </setting>
-        <setting id="audiooutput.passthroughaac">
-          <visible>false</visible>
-        </setting>
         <setting id="audiooutput.multichannellpcm">
           <visible>false</visible>
         </setting>
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index f310b96..2215f70 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2138,19 +2138,6 @@
             </dependency>
           </dependencies>       
         </setting>
-        <setting id="audiooutput.passthroughaac" type="boolean" label="299" help="36367">
-          <level>2</level>
-          <default>false</default>
-          <dependencies>
-            <dependency type="visible">
-              <and>
-                <condition setting="audiooutput.passthrough" operator="is">true</condition>
-                <condition on="property" name="aesettingvisible" setting="audiooutput.passthrough">audiooutput.passthrough</condition>
-                <condition on="property" name="aesettingvisible" setting="audiooutput.config">audiooutput.passthrough</condition>
-              </and>
-            </dependency>
-          </dependencies>     
-        </setting>
         <setting id="audiooutput.truehdpassthrough" type="boolean" label="349" help="36369">
           <level>2</level>
           <default>false</default>
diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index ba97a6b..4c1dc86 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -251,8 +251,6 @@ bool CAEFactory::SupportsRaw(AEDataFormat format)
     return false;
   if (format == AE_FMT_EAC3 && !CSettings::Get().GetBool("audiooutput.eac3passthrough"))
     return false;
-  if (format == AE_FMT_AAC && !CSettings::Get().GetBool("audiooutput.passthroughaac"))
-    return false;
   if (format == AE_FMT_TRUEHD && !CSettings::Get().GetBool("audiooutput.truehdpassthrough"))
     return false;
   if (format == AE_FMT_DTSHD && !CSettings::Get().GetBool("audiooutput.dtshdpassthrough"))
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index cc9fd75..e5e4c5c 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -1978,7 +1978,6 @@ void CActiveAE::LoadSettings()
   m_settings.truehdpassthrough = CSettings::Get().GetBool("audiooutput.truehdpassthrough");
   m_settings.dtspassthrough = CSettings::Get().GetBool("audiooutput.dtspassthrough");
   m_settings.dtshdpassthrough = CSettings::Get().GetBool("audiooutput.dtshdpassthrough");
-  m_settings.aacpassthrough = CSettings::Get().GetBool("audiooutput.passthroughaac");
 
   m_settings.resampleQuality = static_cast<AEQuality>(CSettings::Get().GetInt("audiooutput.processquality"));
 }
@@ -2041,7 +2040,6 @@ void CActiveAE::OnSettingsChange(const std::string& setting)
       setting == "audiooutput.ac3passthrough"    ||
       setting == "audiooutput.eac3passthrough"   ||
       setting == "audiooutput.dtspassthrough"    ||
-      setting == "audiooutput.passthroughaac"    ||
       setting == "audiooutput.truehdpassthrough" ||
       setting == "audiooutput.dtshdpassthrough"  ||
       setting == "audiooutput.channels"          ||
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 2ae0476..1ac7031 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -52,7 +52,6 @@ struct AudioSettings
   bool ac3passthrough;
   bool eac3passthrough;
   bool dtspassthrough;
-  bool aacpassthrough;
   bool truehdpassthrough;
   bool dtshdpassthrough;
   bool stereoupmix;
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 41e5d04..e61bce4 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -896,7 +896,6 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert("audiooutput.ac3passthrough");
   settingSet.insert("audiooutput.eac3passthrough");
   settingSet.insert("audiooutput.dtspassthrough");
-  settingSet.insert("audiooutput.passthroughaac");
   settingSet.insert("audiooutput.truehdpassthrough");
   settingSet.insert("audiooutput.dtshdpassthrough");
   settingSet.insert("audiooutput.audiodevice");
-- 
1.8.4


From a97f2ae76ea180f5bd55376279fc7fad8ae270bc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 19 Oct 2013 19:20:40 +0100
Subject: [PATCH 11/94] [rbp] Update to work with new audio settings

---
 system/settings/rbp.xml                            | 94 +++++++++++++---------
 .../AudioEngine/Engines/PiAudio/PiAudioAE.cpp      | 59 +++++++++++++-
 xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h |  4 +-
 xbmc/cores/omxplayer/OMXAudio.cpp                  |  6 +-
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp            | 35 +++-----
 xbmc/cores/omxplayer/OMXPlayerAudio.h              |  2 -
 6 files changed, 126 insertions(+), 74 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index b890555..866aed4 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -30,18 +30,64 @@
         </setting>
       </group>
     </category>
-    <category id="audiooutput">
+
+    <category id="audiooutput" label="772" help="36360">
       <group id="1">
-        <setting id="audiooutput.mode">
-          <default>2</default> <!-- AUDIO_HDMI -->
+        <setting id="audiooutput.audiodevice">
+          <level>1</level>
+          <default>HDMI</default>
+          <constraints>
+            <options>audiodevices</options>
+          </constraints>
+          <control type="list" format="string" />
         </setting>
-        <setting id="audiooutput.channels">
+        <setting id="audiooutput.dualaudio" type="boolean" label="37017" help="36542">
+          <level>2</level>
+          <default>false</default>
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.passthrough</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+        <setting id="audiooutput.boostcentre" type="boolean" label="37018" help="36543">
+          <level>2</level>
+          <default>false</default>
+        </setting>
+        <setting id="audiooutput.config">
           <visible>false</visible>
         </setting>
         <setting id="audiooutput.stereoupmix">
           <visible>false</visible>
         </setting>
-        <setting id="audiooutput.multichannellpcm">
+        <setting id="audiooutput.channels">
+          <visible>false</visible>
+        </setting>
+        <setting id="audiooutput.streamsilence">
+          <level>2</level>
+          <requirement>audiosupportsdrain</requirement>
+          <default>false</default>
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.streamsilence</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+      </group>
+      <group id="2">
+        <visible>false</visible>
+      </group>
+      <group id="3">
+        <setting id="audiooutput.passthrough">
+          <level>2</level>
+          <default>false</default>
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.passthrough</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+        <setting id="audiooutput.passthroughdevice">
           <visible>false</visible>
         </setting>
         <setting id="audiooutput.truehdpassthrough">
@@ -54,49 +100,19 @@
           <visible>false</visible>
         </setting>
         <setting id="audiooutput.ac3passthrough">
-          <default>true</default>
           <dependencies>
-            <dependency type="enable">
-              <and>
-                <or>
-                  <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                  <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-                </or>
-                <condition setting="audiooutput.dualaudio">false</condition>
-              </and>
+            <dependency type="visible">
+              <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.ac3passthrough</condition>
             </dependency>
           </dependencies>
         </setting>
         <setting id="audiooutput.dtspassthrough">
-          <default>true</default>
           <dependencies>
-            <dependency type="enable">
-              <and>
-                <or>
-                  <condition setting="audiooutput.mode">1</condition> <!-- AUDIO_IEC958 -->
-                  <condition setting="audiooutput.mode">2</condition> <!-- AUDIO_HDMI -->
-                </or>
-                <condition setting="audiooutput.dualaudio">false</condition>
-              </and>
+            <dependency type="visible">
+              <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.dtspassthrough</condition>
             </dependency>
           </dependencies>
         </setting>
-        <setting id="audiooutput.dualaudio" type="boolean" label="37017" help="36542">
-          <level>2</level>
-          <default>false</default>
-        </setting>
-        <setting id="audiooutput.boostcentre" type="boolean" label="37018" help="36543">
-          <level>2</level>
-          <default>false</default>
-        </setting>
-      </group>
-      <group id="2">
-        <visible>false</visible>
-      </group>
-      <group id="3">
-        <setting id="audiooutput.guisoundmode">
-          <visible>false</visible>
-        </setting>
       </group>
     </category>
   </section>
diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
index 6bcd69d..5daa1ff 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
@@ -48,7 +48,8 @@ bool CPiAudioAE::Initialize()
 void CPiAudioAE::UpdateStreamSilence()
 {
 #if defined(TARGET_RASPBERRY_PI)
-  bool enable = CSettings::Get().GetBool("audiooutput.streamsilence");
+  bool enable = CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI" &&
+                CSettings::Get().GetBool("audiooutput.streamsilence");
   char response[80] = "";
   char command[80] = "";
   sprintf(command, "force_audio hdmi %d", enable);
@@ -105,9 +106,27 @@ void CPiAudioAE::FreeSound(IAESound *sound)
 {
 }
 
-bool CPiAudioAE::SupportsRaw()
+bool CPiAudioAE::SupportsRaw(AEDataFormat format)
 {
-  return true;
+  bool supported = false;
+#if defined(TARGET_RASPBERRY_PI)
+  if (CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI")
+  {
+    if (!CSettings::Get().GetBool("audiooutput.dualaudio"))
+    {
+      DllBcmHost m_DllBcmHost;
+      m_DllBcmHost.Load();
+      if (format == AE_FMT_AC3 && CSettings::Get().GetBool("audiooutput.ac3passthrough") &&
+          m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eAC3, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
+        supported = true;
+      if (format == AE_FMT_DTS && CSettings::Get().GetBool("audiooutput.dtspassthrough") &&
+          m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eDTS, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
+        supported = true;
+      m_DllBcmHost.Unload();
+    }
+  }
+#endif
+  return supported;
 }
 
 bool CPiAudioAE::SupportsDrain()
@@ -117,11 +136,43 @@ bool CPiAudioAE::SupportsDrain()
 
 void CPiAudioAE::OnSettingsChange(const std::string& setting)
 {
-  if (setting == "audiooutput.streamsilence")
+  if (setting == "audiooutput.streamsilence" || setting == "audiooutput.audiodevice")
     UpdateStreamSilence();
 }
 
 void CPiAudioAE::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough)
 {
+   if (!passthrough)
+   {
+     devices.push_back(AEDevice("Analogue", "Analogue"));
+     devices.push_back(AEDevice("HDMI", "HDMI"));
+   }
 }
 
+std::string CPiAudioAE::GetDefaultDevice(bool passthrough)
+{
+  return "HDMI";
+}
+
+bool CPiAudioAE::IsSettingVisible(const std::string &settingId)
+{
+  if (settingId == "audiooutput.samplerate")
+    return true;
+
+  if (CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI")
+  {
+    if (settingId == "audiooutput.passthrough")
+      return true;
+    if (settingId == "audiooutput.dtspassthrough")
+      return true;
+    if (settingId == "audiooutput.ac3passthrough")
+      return true;
+    if (settingId == "audiooutput.channels")
+      return true;
+    if (settingId == "audiooutput.dualaudio")
+      return true;
+    if (settingId == "audiooutput.streamsilence")
+      return true;
+  }
+  return false;
+}
diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
index 419241b..5eefdd8 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
@@ -58,8 +58,10 @@ class CPiAudioAE : public IAE
 
   virtual void GarbageCollect() {};
   virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
+  virtual std::string GetDefaultDevice(bool passthrough);
+  virtual bool IsSettingVisible(const std::string &settingId);
 
-  virtual bool SupportsRaw();
+  virtual bool SupportsRaw(AEDataFormat format);
   virtual bool SupportsDrain();
 
   virtual void OnLostDevice() {}
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index c6ab3b9..74ac027 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -205,12 +205,12 @@ bool COMXAudio::PortSettingsChanged()
     if(!m_omx_splitter.Initialize("OMX.broadcom.audio_splitter", OMX_IndexParamAudioInit))
       return false;
   }
-  if (CSettings::Get().GetBool("audiooutput.dualaudio") || CSettings::Get().GetInt("audiooutput.mode") == AUDIO_ANALOG)
+  if (CSettings::Get().GetBool("audiooutput.dualaudio") || CSettings::Get().GetString("audiooutput.audiodevice") == "Analogue")
   {
     if(!m_omx_render_analog.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
       return false;
   }
-  if (CSettings::Get().GetBool("audiooutput.dualaudio") || CSettings::Get().GetInt("audiooutput.mode") == AUDIO_HDMI)
+  if (CSettings::Get().GetBool("audiooutput.dualaudio") || CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI")
   {
     if(!m_omx_render_hdmi.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
       return false;
@@ -235,6 +235,8 @@ bool COMXAudio::PortSettingsChanged()
     m_pcm_output.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
     m_pcm_output.eChannelMapping[1] = OMX_AUDIO_ChannelRF;
     m_pcm_output.nChannels = 2;
+    /* limit samplerate (through resampling) if requested */
+    m_pcm_output.nSamplingRate = std::min((int)m_pcm_output.nSamplingRate, CSettings::Get().GetInt("audiooutput.samplerate"));
 
     m_pcm_output.nPortIndex = m_omx_mixer.GetOutputPort();
     omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index 08b432f..999ce40 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -42,6 +42,7 @@
 
 #include "OMXPlayer.h"
 #include "linux/RBP.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 #include <iostream>
 #include <sstream>
@@ -83,7 +84,6 @@ class COMXMsgAudioCodecChange : public CDVDMsg
   m_messageQueue.SetMaxDataSize((small_mem ? 3:6) * 1024 * 1024);
 
   m_messageQueue.SetMaxTimeSize(8.0);
-  m_use_passthrough = false;
   m_passthrough = false;
   m_use_hw_decode = false;
   m_hw_decode = false;
@@ -95,15 +95,10 @@ class COMXMsgAudioCodecChange : public CDVDMsg
 OMXPlayerAudio::~OMXPlayerAudio()
 {
   CloseStream(false);
-
-  m_DllBcmHost.Unload();
 }
 
 bool OMXPlayerAudio::OpenStream(CDVDStreamInfo &hints)
 {
-  if(!m_DllBcmHost.Load())
-    return false;
-
   m_bad_state = false;
 
   COMXAudioCodecOMX *codec = new COMXAudioCodecOMX();
@@ -146,8 +141,6 @@ void OMXPlayerAudio::OpenStream(CDVDStreamInfo &hints, COMXAudioCodecOMX *codec)
   m_flush           = false;
   m_nChannels       = 0;
   m_stalled         = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
-  m_use_passthrough = (CSettings::Get().GetInt("audiooutput.mode") == AUDIO_HDMI &&
-                      !CSettings::Get().GetBool("audiooutput.dualaudio")) ? true : false ;
   m_use_hw_decode   = g_advancedSettings.m_omxHWAudioDecode;
   m_format.m_dataFormat    = GetDataFormat(m_hints);
   m_format.m_sampleRate    = 0;
@@ -511,13 +504,6 @@ bool OMXPlayerAudio::Passthrough() const
 AEDataFormat OMXPlayerAudio::GetDataFormat(CDVDStreamInfo hints)
 {
   AEDataFormat dataFormat = AE_FMT_S16NE;
-  bool hdmi_passthrough_dts = false;
-  bool hdmi_passthrough_ac3 = false;
-
-  if (m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eAC3, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
-    hdmi_passthrough_ac3 = true;
-  if (m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eDTS, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
-    hdmi_passthrough_dts = true;
 
   m_passthrough = false;
   m_hw_decode   = false;
@@ -525,18 +511,15 @@ AEDataFormat OMXPlayerAudio::GetDataFormat(CDVDStreamInfo hints)
   /* check our audio capabilties */
 
   /* pathrought is overriding hw decode*/
-  if(AUDIO_IS_BITSTREAM(CSettings::Get().GetInt("audiooutput.mode")) && m_use_passthrough)
+  if(hints.codec == AV_CODEC_ID_AC3 && CAEFactory::SupportsRaw(AE_FMT_AC3))
   {
-    if(hints.codec == AV_CODEC_ID_AC3 && CSettings::Get().GetBool("audiooutput.ac3passthrough") && hdmi_passthrough_ac3)
-    {
-      dataFormat = AE_FMT_AC3;
-      m_passthrough = true;
-    }
-    if(hints.codec == AV_CODEC_ID_DTS && CSettings::Get().GetBool("audiooutput.dtspassthrough") && hdmi_passthrough_dts)
-    {
-      dataFormat = AE_FMT_DTS;
-      m_passthrough = true;
-    }
+    dataFormat = AE_FMT_AC3;
+    m_passthrough = true;
+  }
+  if(hints.codec == AV_CODEC_ID_DTS && CAEFactory::SupportsRaw(AE_FMT_DTS))
+  {
+    dataFormat = AE_FMT_DTS;
+    m_passthrough = true;
   }
 
   /* hw decode */
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.h b/xbmc/cores/omxplayer/OMXPlayerAudio.h
index 394f309..685a686 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.h
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.h
@@ -50,7 +50,6 @@ class OMXPlayerAudio : public CThread
   OMXClock                  *m_av_clock;
   COMXAudio                 m_omxAudio;
   std::string               m_codec_name;
-  bool                      m_use_passthrough;
   bool                      m_passthrough;
   bool                      m_use_hw_decode;
   bool                      m_hw_decode;
@@ -70,7 +69,6 @@ class OMXPlayerAudio : public CThread
   int                       m_nChannels;
   bool                      m_DecoderOpen;
 
-  DllBcmHost                m_DllBcmHost;
   bool                      m_bad_state;
 
   virtual void OnStartup();
-- 
1.8.4


From 3c40f55253326fbe0017b65369d3389dd2c95d33 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 20 Oct 2013 13:54:45 +0200
Subject: [PATCH 12/94] remove a bunch of obsolete advanced settings related to
 audio

---
 xbmc/cores/AudioEngine/AESinkFactory.cpp      |  6 ++----
 xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp | 18 +++---------------
 xbmc/settings/AdvancedSettings.cpp            | 14 --------------
 xbmc/settings/AdvancedSettings.h              |  7 -------
 4 files changed, 5 insertions(+), 40 deletions(-)

diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index 906a824..e7fb9a3 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -101,8 +101,7 @@ IAESink *CAESinkFactory::Create(std::string &device, AEAudioFormat &desiredForma
 
 
 #if defined(TARGET_WINDOWS)
-  if ((driver.empty() ||
-    driver == "WASAPI") && !g_advancedSettings.m_audioForceDirectSound)
+  if (driver == "WASAPI")
     TRY_SINK(WASAPI)
   else
     TRY_SINK(DirectSound) // always fall back to DirectSound
@@ -141,8 +140,7 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
 {
 #if defined(TARGET_WINDOWS)
   ENUMERATE_SINK(DirectSound, force);
-  if (!g_advancedSettings.m_audioForceDirectSound)
-    ENUMERATE_SINK(WASAPI, force);
+  ENUMERATE_SINK(WASAPI, force);
 #elif defined(TARGET_ANDROID)
     ENUMERATE_SINK(AUDIOTRACK, force);
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
index 623c035..94e2c5b 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
@@ -500,12 +500,7 @@ unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool
       return INT_MAX;
     }
 
-    /* Inject one buffer of silence if sink has just opened */
-    /* to avoid losing start of stream or GUI sound         */
-    if (g_advancedSettings.m_streamSilence)
-      memcpy(buf, data, NumFramesRequested * m_format.m_frameSize); //fill buffer with audio
-    else
-      memset(buf,    0, NumFramesRequested * m_format.m_frameSize); //fill buffer with silence
+    memset(buf, 0, NumFramesRequested * m_format.m_frameSize); //fill buffer with silence
 
     hr = m_pRenderClient->ReleaseBuffer(NumFramesRequested, flags); //pass back to audio driver
     if (FAILED(hr))
@@ -520,7 +515,7 @@ unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool
     if (FAILED(hr))
       CLog::Log(LOGERROR, __FUNCTION__": AudioClient Start Failed");
     m_running = true; //signal that we're processing frames
-    return g_advancedSettings.m_streamSilence ? NumFramesRequested : 0U;
+    return 0U;
   }
 
 #ifndef _DEBUG
@@ -545,15 +540,8 @@ unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool
   {
     if(eventAudioCallback != WAIT_OBJECT_0 || !&buf)
     {
-      /* Event handle timed out - flag sink as dirty for re-initializing */
       CLog::Log(LOGERROR, __FUNCTION__": Endpoint Buffer timed out");
-      if (g_advancedSettings.m_streamSilence)
-      {
-        m_isDirty = true; //flag new device or re-init needed
-        Deinitialize();
-        m_running = false;
-        return INT_MAX;
-      }
+      return INT_MAX;
     }
   }
 
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 0f30d84..619490d 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -115,12 +115,6 @@ void CAdvancedSettings::Initialize()
   m_ac3Gain = 12.0f;
   m_audioApplyDrc = true;
   m_dvdplayerIgnoreDTSinWAV = false;
-  m_audioResample = 0;
-  m_allowTranscode44100 = false;
-  m_audioForceDirectSound = false;
-  m_audioAudiophile = false;
-  m_allChannelStereo = false;
-  m_streamSilence = false;
 
   //default hold time of 25 ms, this allows a 20 hertz sine to pass undistorted
   m_limiterHold = 0.025f;
@@ -502,14 +496,6 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetInt(pElement, "percentseekforwardbig", m_musicPercentSeekForwardBig, 0, 100);
     XMLUtils::GetInt(pElement, "percentseekbackwardbig", m_musicPercentSeekBackwardBig, -100, 0);
 
-    XMLUtils::GetInt(pElement, "resample", m_audioResample, 0, 192000);
-    XMLUtils::GetBoolean(pElement, "allowtranscode44100", m_allowTranscode44100);
-    XMLUtils::GetBoolean(pElement, "forceDirectSound", m_audioForceDirectSound);
-    XMLUtils::GetBoolean(pElement, "audiophile", m_audioAudiophile);
-    XMLUtils::GetBoolean(pElement, "allchannelstereo", m_allChannelStereo);
-    XMLUtils::GetBoolean(pElement, "streamsilence", m_streamSilence);
-    XMLUtils::GetString(pElement, "transcodeto", m_audioTranscodeTo);
-
     TiXmlElement* pAudioExcludes = pElement->FirstChildElement("excludefromlisting");
     if (pAudioExcludes)
       GetCustomRegexps(pAudioExcludes, m_audioExcludeFromListingRegExps);
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index e6e02ad..d46ee0b 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -138,13 +138,6 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     CStdString m_audioDefaultPlayer;
     float m_audioPlayCountMinimumPercent;
     bool m_dvdplayerIgnoreDTSinWAV;
-    int m_audioResample;
-    bool m_allowTranscode44100;
-    bool m_audioForceDirectSound;
-    bool m_audioAudiophile;
-    bool m_allChannelStereo;
-    bool m_streamSilence;
-    CStdString m_audioTranscodeTo;
     float m_limiterHold;
     float m_limiterRelease;
 
-- 
1.8.4


From 3ce36187bf19d85445b154389c5e4a60548c8520 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Fri, 18 Oct 2013 22:01:55 +0200
Subject: [PATCH 13/94] [osx/ios/atv2] - sync xcode project

---
 XBMC.xcodeproj/project.pbxproj | 2 --
 1 file changed, 2 deletions(-)

diff --git a/XBMC.xcodeproj/project.pbxproj b/XBMC.xcodeproj/project.pbxproj
index 044538c..c5c4be5 100644
--- a/XBMC.xcodeproj/project.pbxproj
+++ b/XBMC.xcodeproj/project.pbxproj
@@ -4180,7 +4180,6 @@
 		DFB0F471161B747500D744F4 /* AddonsOperations.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AddonsOperations.h; sourceTree = "<group>"; };
 		DFB15B2015F8FB8100CDF0DE /* SDLMain.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SDLMain.h; sourceTree = "<group>"; };
 		DFB15B2115F8FB8100CDF0DE /* SDLMain.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = SDLMain.mm; sourceTree = "<group>"; };
-		DFB65F6415373AE7006B8FF1 /* AEAudioFormat.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AEAudioFormat.h; sourceTree = "<group>"; };
 		DFB65F6515373AE7006B8FF1 /* AEFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AEFactory.cpp; sourceTree = "<group>"; };
 		DFB65F6615373AE7006B8FF1 /* AEFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AEFactory.h; sourceTree = "<group>"; };
 		DFB65F6A15373AE7006B8FF1 /* AEEncoderFFmpeg.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AEEncoderFFmpeg.cpp; sourceTree = "<group>"; };
@@ -7015,7 +7014,6 @@
 				DFB65F6C15373AE7006B8FF1 /* Engines */,
 				DFB65F8815373AE7006B8FF1 /* Interfaces */,
 				DFB65FA215373AE7006B8FF1 /* Utils */,
-				DFB65F6415373AE7006B8FF1 /* AEAudioFormat.h */,
 				DFB65F6515373AE7006B8FF1 /* AEFactory.cpp */,
 				DFB65F6615373AE7006B8FF1 /* AEFactory.h */,
 			);
-- 
1.8.4


From 5fc72477e52eb243fe3a3d94e3813b0714114000 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Sun, 20 Oct 2013 13:37:37 +0200
Subject: [PATCH 14/94] [AE/CA] - fix hidden settings for darwin

---
 system/settings/darwin.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/system/settings/darwin.xml b/system/settings/darwin.xml
index 2cf4df6..ba56a25 100644
--- a/system/settings/darwin.xml
+++ b/system/settings/darwin.xml
@@ -7,7 +7,7 @@
       </group>
     </category>
     <category id="audiooutput">
-      <group id="1">
+      <group id="3">
         <setting id="audiooutput.truehdpassthrough">
           <visible>false</visible>
         </setting>
-- 
1.8.4


From c9bc851e8d5202bd985c85621c3e4dd8b3772a09 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Fri, 18 Oct 2013 22:11:31 +0200
Subject: [PATCH 15/94] [AE/CA] - adapt to new audiosettings page

---
 .../AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp  | 58 ++++++++++++++--------
 .../AudioEngine/Engines/CoreAudio/CoreAudioAE.h    |  6 +--
 .../Engines/CoreAudio/CoreAudioAEHALOSX.cpp        |  2 +-
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp        |  7 ++-
 4 files changed, 45 insertions(+), 28 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
index 990163c..f067343 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
@@ -240,17 +240,14 @@ bool CCoreAudioAE::OpenCoreAudio(unsigned int sampleRate, bool forceRaw,
     case 10: m_stdChLayout = AE_CH_LAYOUT_7_1; break;
   }
 #endif
-  // force optical/coax to 2.0 output channels
-  if (!m_rawPassthrough && !m_transcode && CSettings::Get().GetInt("audiooutput.mode") == AUDIO_IEC958)
-    m_stdChLayout = AE_CH_LAYOUT_2_0;
 
   // setup the desired format
   m_format.m_channelLayout = CAEChannelInfo(m_stdChLayout);
 
   // if there is an audio resample rate set, use it.
-  if (g_advancedSettings.m_audioResample && !m_rawPassthrough)
+  if (CSettings::Get().GetInt("audiooutput.config") == AE_CONFIG_FIXED && !m_rawPassthrough)
   {
-    sampleRate = g_advancedSettings.m_audioResample;
+    sampleRate = CSettings::Get().GetInt("audiooutput.samplerate");
     CLog::Log(LOGINFO, "CCoreAudioAE::passthrough - Forcing samplerate to %d", sampleRate);
   }
 
@@ -406,11 +403,13 @@ void CCoreAudioAE::OnSettingsChange(const std::string& setting)
       setting == "audiooutput.custompassthrough" ||
       setting == "audiooutput.audiodevice"       ||
       setting == "audiooutput.customdevice"      ||
-      setting == "audiooutput.mode"              ||
       setting == "audiooutput.ac3passthrough"    ||
+      setting == "audiooutput.eac3passthrough"   ||
       setting == "audiooutput.dtspassthrough"    ||
-      setting == "audiooutput.channels"     ||
-      setting == "audiooutput.multichannellpcm")
+      setting == "audiooutput.channels"          ||
+      setting == "audiooutput.samplerate"        ||
+      setting == "audiooutput.config"            ||
+      setting == "audiooutput.passthrough"        )
   {
     // only reinit the engine if we not
     // suspended (resume will initialize
@@ -508,8 +507,30 @@ void CCoreAudioAE::SetSoundMode(const int mode)
     StopAllSounds();
 }
 
-bool CCoreAudioAE::SupportsRaw()
+bool CCoreAudioAE::SupportsRaw(AEDataFormat format)
 {
+  switch(format)
+  {
+    case AE_FMT_AC3:
+    case AE_FMT_DTS:
+    case AE_FMT_EAC3:
+    case AE_FMT_LPCM:
+      return true;
+    default:
+      return false;
+  }
+}
+
+bool CCoreAudioAE::IsSettingVisible(const std::string &settingId)
+{
+  if (settingId == "audiooutput.samplerate")
+  {
+    if (CSettings::Get().GetInt("audiooutput.config") == AE_CONFIG_FIXED)
+      return true;
+    else
+      return false;
+  }
+
   return true;
 }
 
@@ -534,20 +555,17 @@ IAEStream* CCoreAudioAE::MakeStream(enum AEDataFormat dataFormat,
   CLog::Log(LOGINFO, "CCoreAudioAE::MakeStream - %s, %u, %u, %s",
     CAEUtil::DataFormatToStr(dataFormat), sampleRate, encodedSamplerate, ((std::string)channelInfo).c_str());
 
+  bool multichannelpcm = CSettings::Get().GetInt("audiooutput.channels") > AE_CH_LAYOUT_2_0; //if more then 2 channels are set - assume lpcm capability
+#if defined(TARGET_DARWIN_IOS)
+  multichannelpcm = false;
+#endif
   // determine if we need to transcode this audio
   // when we're called, we'll either get the audio in an encoded form (COREAUDIO_IS_RAW==true)
   // that we can passthrough based on user options, or we'll get it unencoded
   // if it's unencoded, and is 5.1, we'll transcode it to AC3 if possible
-  bool transcode = CSettings::Get().GetBool("audiooutput.ac3passthrough") && 
-    (
-      (CSettings::Get().GetInt("audiooutput.mode") == AUDIO_IEC958) ||
-      (
-        (CSettings::Get().GetInt("audiooutput.mode") == AUDIO_HDMI) &&
-        !CSettings::Get().GetBool("audiooutput.multichannellpcm")
-      )
-    ) &&
-    !COREAUDIO_IS_RAW(dataFormat) &&
-    (channelInfo.Count() == 6);
+  bool transcode = CSettings::Get().GetBool("audiooutput.passthrough") && CSettings::Get().GetBool("audiooutput.ac3passthrough") && !multichannelpcm &&
+                   !COREAUDIO_IS_RAW(dataFormat) &&
+                  (channelInfo.Count() == 6);
   
   CCoreAudioAEStream *stream = new CCoreAudioAEStream(dataFormat, sampleRate, encodedSamplerate, channelLayout, options, transcode);
   CSingleLock streamLock(m_streamLock);
@@ -748,7 +766,7 @@ void CCoreAudioAE::MixSounds(float *buffer, unsigned int samples)
 void CCoreAudioAE::GarbageCollect()
 {
 #if defined(TARGET_DARWIN_OSX)
-  if (g_advancedSettings.m_streamSilence)
+  if (CSettings::Get().GetBool("audiooutput.streamsilence"))
     return;
   
   if (!m_streamsPlaying && m_playing_sounds.empty())
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
index 5e9d694..f31dada 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
@@ -91,9 +91,9 @@ class CCoreAudioAE : public IAE, public ICoreAudioSource
   virtual void      SetMute(const bool enabled);
   virtual bool      IsMuted();
   virtual void      SetSoundMode(const int mode);
-
-
-  virtual bool      SupportsRaw();
+  virtual bool      SupportsRaw(AEDataFormat format);
+  virtual bool      IsSettingVisible(const std::string &settingId);
+  virtual bool      SupportsDrain() { return true; }
 
   CCoreAudioAEHAL*  GetHAL();
 
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
index 52b2272..3728d5f 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
@@ -95,7 +95,7 @@ bool CCoreAudioAEHALOSX::InitializePCM(ICoreAudioSource *pSource, AEAudioFormat
 
   AudioChannelLayoutTag layout = g_LayoutMap[ CSettings::Get().GetInt("audiooutput.channels") ];
   // force optical/coax to 2.0 output channels
-  if (!m_Passthrough && CSettings::Get().GetInt("audiooutput.mode") == AUDIO_IEC958)
+  if (!m_Passthrough && CSettings::Get().GetInt("audiooutput.channels") ==  AE_CH_LAYOUT_2_0)
     layout = g_LayoutMap[1];
 
   if (!m_audioGraph->Open(pSource, format, outputDevice, allowMixing, layout, m_initVolume ))
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index ae3916b..69992cc 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -74,10 +74,9 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
     return false;
   }
 
-#if defined(TARGET_DARWIN)
-  int audioMode = CSettings::Get().GetInt("audiooutput.mode");
-  if (audioMode == AUDIO_HDMI)
-    m_bLpcmMode = CSettings::Get().GetBool("audiooutput.multichannellpcm");
+#if defined(TARGET_DARWIN_OSX)
+  if (CSettings::Get().GetInt("audiooutput.channels") >  AE_CH_LAYOUT_2_0)
+    m_bLpcmMode = true;
 #endif
 
   m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
-- 
1.8.4


From 2923fd724e61dcda1ad0a689e378546d50296885 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 22 Oct 2013 20:48:11 +0200
Subject: [PATCH 16/94] AE: make streamsilence an integer so it can define a
 timeout after which the mode is disabled

---
 language/English/strings.po          | 10 +++++++++-
 system/settings/settings.xml         |  8 ++++++--
 xbmc/cores/AudioEngine/AEFactory.cpp | 14 ++++++++++++++
 xbmc/cores/AudioEngine/AEFactory.h   |  1 +
 xbmc/settings/Settings.cpp           |  2 ++
 5 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 009e1c0..74a5e59 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6080,7 +6080,15 @@ msgctxt "#13553"
 msgid "%.1f Seconds"
 msgstr ""
 
-#empty strings from id 13554 to 13599
+msgctxt "#13554"
+msgid "%d Minute"
+msgstr ""
+
+msgctxt "#13555"
+msgid "%d Minutes"
+msgstr ""
+
+#empty strings from id 13556 to 13599
 
 #: system/settings/darwin.xml
 msgctxt "#13600"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 2215f70..f13b4d4 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2052,10 +2052,14 @@
           </constraints>
           <control type="spinner" format="string" />
         </setting>
-        <setting id="audiooutput.streamsilence" type="boolean" label="421" help="34111">
+        <setting id="audiooutput.streamsilence" type="integer" label="421" help="34111">
           <level>1</level>
           <requirement>audiosupportsdrain</requirement>
-          <default>true</default>
+          <default>1</default>
+          <constraints>
+            <options>audiostreamsilence</options>
+          </constraints>
+          <control type="spinner" format="string" />
         </setting>
       </group>
       <group id="2">
diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 4c1dc86..a5fc6e1 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -370,6 +370,20 @@ void CAEFactory::SettingOptionsAudioQualityLevelsFiller(const CSetting *setting,
     list.push_back(std::make_pair(g_localizeStrings.Get(13509), AE_QUALITY_REALLYHIGH));
 }
 
+void CAEFactory::SettingOptionsAudioStreamsilenceFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
+{
+  if (!AE)
+    return;
+
+  list.push_back(std::make_pair(g_localizeStrings.Get(20422), XbmcThreads::EndTime::InfiniteValue));
+  list.push_back(std::make_pair(g_localizeStrings.Get(13551), 0));
+  list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13554).c_str(), 1), 1));
+  for (int i = 2; i <= 10; i++)
+  {
+    list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13555).c_str(), i), i));
+  }
+}
+
 void CAEFactory::SettingOptionsAudioDevicesFillerGeneral(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current, bool passthrough)
 {
   current = ((const CSettingString*)setting)->GetValue();
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index 20e67a3..ccf57c1 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -74,6 +74,7 @@ class CAEFactory
   static void SettingOptionsAudioDevicesFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
   static void SettingOptionsAudioDevicesPassthroughFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
   static void SettingOptionsAudioQualityLevelsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static void SettingOptionsAudioStreamsilenceFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static bool IsSettingVisible(const std::string &condition, const std::string &value, const std::string &settingId);
 
   static void RegisterAudioCallback(IAudioCallback* pCallback);
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index e61bce4..b73bdda 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -372,6 +372,7 @@ void CSettings::Uninitialize()
   m_settingsManager->UnregisterSettingOptionsFiller("aequalitylevels");
   m_settingsManager->UnregisterSettingOptionsFiller("audiodevices");
   m_settingsManager->UnregisterSettingOptionsFiller("audiodevicespassthrough");
+  m_settingsManager->UnregisterSettingOptionsFiller("audiostreamsilence");
   m_settingsManager->UnregisterSettingOptionsFiller("charsets");
   m_settingsManager->UnregisterSettingOptionsFiller("epgguideviews");
   m_settingsManager->UnregisterSettingOptionsFiller("fontheights");
@@ -686,6 +687,7 @@ void CSettings::InitializeOptionFillers()
   m_settingsManager->RegisterSettingOptionsFiller("aequalitylevels", CAEFactory::SettingOptionsAudioQualityLevelsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("audiodevices", CAEFactory::SettingOptionsAudioDevicesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("audiodevicespassthrough", CAEFactory::SettingOptionsAudioDevicesPassthroughFiller);
+  m_settingsManager->RegisterSettingOptionsFiller("audiostreamsilence", CAEFactory::SettingOptionsAudioStreamsilenceFiller);
   m_settingsManager->RegisterSettingOptionsFiller("charsets", CCharsetConverter::SettingOptionsCharsetsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("epgguideviews", PVR::CGUIWindowPVRGuide::SettingOptionsEpgGuideViewFiller);
   m_settingsManager->RegisterSettingOptionsFiller("fonts", GUIFontManager::SettingOptionsFontsFiller);
-- 
1.8.4


From a996bfc6a403ce9b91eb438734b2df8fa50825c9 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 22 Oct 2013 20:48:44 +0200
Subject: [PATCH 17/94] ActiveAE: implement timeout for streamsilence

---
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.cpp     | 19 +++++++++++++------
 .../cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h |  3 ++-
 2 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 966b446..d2a8d12 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -163,7 +163,7 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
             m_device = *(data->device);
           }
           m_extError = false;
-          m_extSilence = false;
+          m_extSilenceTimer = 0;
           ReturnBuffers();
           OpenSink();
 
@@ -266,10 +266,14 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
         switch (signal)
         {
         case CSinkControlProtocol::SILENCEMODE:
-          m_extSilence = *(bool*)msg->data;
-          if (CSettings::Get().GetBool("audiooutput.streamsilence"))
-            m_extSilence = true;
-          if (m_extSilence)
+          bool silencemode;
+          silencemode = *(bool*)msg->data;
+          if (silencemode)
+            m_extSilenceTimeout = XbmcThreads::EndTime::InfiniteValue;
+          else
+            m_extSilenceTimeout = CSettings::Get().GetInt("audiooutput.streamsilence") * 60000;
+          m_extSilenceTimer.Set(m_extSilenceTimeout);
+          if (!m_extSilenceTimer.IsTimePast())
           {
             m_state = S_TOP_CONFIGURED_SILENCE;
             m_extTimeout = 0;
@@ -311,6 +315,7 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
           {
             m_state = S_TOP_CONFIGURED_PLAY;
             m_extTimeout = delay / 2;
+            m_extSilenceTimer.Set(m_extSilenceTimeout);
           }
           return;
         default:
@@ -403,7 +408,7 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
         switch (signal)
         {
         case CSinkControlProtocol::TIMEOUT:
-          if (m_extSilence)
+          if (!m_extSilenceTimer.IsTimePast())
           {
             m_state = S_TOP_CONFIGURED_SILENCE;
             m_extTimeout = 0;
@@ -435,6 +440,8 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
             m_sink = NULL;
             m_state = S_TOP_CONFIGURED_SUSPEND;
           }
+          else
+            m_state = S_TOP_CONFIGURED_PLAY;
           m_extTimeout = 0;
           return;
         default:
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
index 2aebbf6..52f4a17 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
@@ -116,7 +116,8 @@ class CActiveAESink : private CThread
   bool m_bStateMachineSelfTrigger;
   int m_extTimeout;
   bool m_extError;
-  bool m_extSilence;
+  int m_extSilenceTimeout;
+  XbmcThreads::EndTime m_extSilenceTimer;
 
   CSampleBuffer m_sampleOfSilence;
   uint8_t *m_convertBuffer;
-- 
1.8.4


From 6c6e2e46d2f207eb28361caffa23633efd838f6c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 23 Oct 2013 20:49:12 +0200
Subject: [PATCH 18/94] AE: rework streamsilence

---
 system/settings/rbp.xml                                  |  7 +++++--
 system/settings/settings.xml                             |  1 -
 xbmc/cores/AudioEngine/AEFactory.cpp                     | 14 +++++++++-----
 xbmc/cores/AudioEngine/AEFactory.h                       |  2 +-
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp     |  2 +-
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h       |  2 +-
 xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp |  2 +-
 xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp     |  6 +++---
 xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h       |  2 +-
 xbmc/cores/AudioEngine/Interfaces/AE.h                   |  2 +-
 xbmc/settings/Settings.cpp                               |  3 ---
 11 files changed, 23 insertions(+), 20 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 866aed4..166314a 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -65,13 +65,16 @@
         </setting>
         <setting id="audiooutput.streamsilence">
           <level>2</level>
-          <requirement>audiosupportsdrain</requirement>
-          <default>false</default>
+          <default>0</default>
           <dependencies>
             <dependency type="visible">
               <condition on="property" name="aesettingvisible" setting="audiooutput.audiodevice">audiooutput.streamsilence</condition>
             </dependency>
           </dependencies>
+          <constraints>
+            <options>audiostreamsilence</options>
+          </constraints>
+          <control type="spinner" format="string" />
         </setting>
       </group>
       <group id="2">
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index f13b4d4..d25dd72 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2054,7 +2054,6 @@
         </setting>
         <setting id="audiooutput.streamsilence" type="integer" label="421" help="34111">
           <level>1</level>
-          <requirement>audiosupportsdrain</requirement>
           <default>1</default>
           <constraints>
             <options>audiostreamsilence</options>
diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index a5fc6e1..18288bc 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -262,10 +262,10 @@ bool CAEFactory::SupportsRaw(AEDataFormat format)
   return false;
 }
 
-bool CAEFactory::SupportsDrain()
+bool CAEFactory::SupportsSilenceTimeout()
 {
   if(AE)
-    return AE->SupportsDrain();
+    return AE->SupportsSilenceTimeout();
 
   return false;
 }
@@ -377,10 +377,14 @@ void CAEFactory::SettingOptionsAudioStreamsilenceFiller(const CSetting *setting,
 
   list.push_back(std::make_pair(g_localizeStrings.Get(20422), XbmcThreads::EndTime::InfiniteValue));
   list.push_back(std::make_pair(g_localizeStrings.Get(13551), 0));
-  list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13554).c_str(), 1), 1));
-  for (int i = 2; i <= 10; i++)
+
+  if (AE->SupportsSilenceTimeout())
   {
-    list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13555).c_str(), i), i));
+    list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13554).c_str(), 1), 1));
+    for (int i = 2; i <= 10; i++)
+    {
+      list.push_back(std::make_pair(StringUtils::Format(g_localizeStrings.Get(13555).c_str(), i), i));
+    }
   }
 }
 
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index ccf57c1..745ddc1 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -54,7 +54,7 @@ class CAEFactory
   static void VerifyOutputDevice(std::string &device, bool passthrough);
   static std::string GetDefaultDevice(bool passthrough);
   static bool SupportsRaw(AEDataFormat format);
-  static bool SupportsDrain();
+  static bool SupportsSilenceTimeout();
 
   /**
    * Returns true if current AudioEngine supports at lest two basic quality levels
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index e5e4c5c..0837b7c 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2069,7 +2069,7 @@ bool CActiveAE::SupportsRaw(AEDataFormat format)
   return true;
 }
 
-bool CActiveAE::SupportsDrain()
+bool CActiveAE::SupportsSilenceTimeout()
 {
   return true;
 }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 1ac7031..e3e772a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -215,7 +215,7 @@ class CActiveAE : public IAE, private CThread
   virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
   virtual std::string GetDefaultDevice(bool passthrough);
   virtual bool SupportsRaw(AEDataFormat format);
-  virtual bool SupportsDrain();
+  virtual bool SupportsSilenceTimeout();
   virtual bool SupportsQualityLevel(enum AEQuality level);
   virtual bool IsSettingVisible(const std::string &settingId);
 
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
index f067343..d57dd5a 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
@@ -766,7 +766,7 @@ void CCoreAudioAE::MixSounds(float *buffer, unsigned int samples)
 void CCoreAudioAE::GarbageCollect()
 {
 #if defined(TARGET_DARWIN_OSX)
-  if (CSettings::Get().GetBool("audiooutput.streamsilence"))
+  if (CSettings::Get().GetInt("audiooutput.streamsilence") != 0)
     return;
   
   if (!m_streamsPlaying && m_playing_sounds.empty())
diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
index 5daa1ff..9eb46b7 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
@@ -49,7 +49,7 @@ void CPiAudioAE::UpdateStreamSilence()
 {
 #if defined(TARGET_RASPBERRY_PI)
   bool enable = CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI" &&
-                CSettings::Get().GetBool("audiooutput.streamsilence");
+                CSettings::Get().GetInt("audiooutput.streamsilence") != 0;
   char response[80] = "";
   char command[80] = "";
   sprintf(command, "force_audio hdmi %d", enable);
@@ -129,9 +129,9 @@ bool CPiAudioAE::SupportsRaw(AEDataFormat format)
   return supported;
 }
 
-bool CPiAudioAE::SupportsDrain()
+bool CPiAudioAE::SupportsSilenceTimeout()
 {
-  return true;
+  return false;
 }
 
 void CPiAudioAE::OnSettingsChange(const std::string& setting)
diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
index 5eefdd8..4836ed6 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
@@ -62,7 +62,7 @@ class CPiAudioAE : public IAE
   virtual bool IsSettingVisible(const std::string &settingId);
 
   virtual bool SupportsRaw(AEDataFormat format);
-  virtual bool SupportsDrain();
+  virtual bool SupportsSilenceTimeout();
 
   virtual void OnLostDevice() {}
   virtual void OnResetDevice() {}
diff --git a/xbmc/cores/AudioEngine/Interfaces/AE.h b/xbmc/cores/AudioEngine/Interfaces/AE.h
index e60aa66..d2f895c 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AE.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AE.h
@@ -209,7 +209,7 @@ class IAE
    * Returns true if the AudioEngine supports drain mode which is not streaming silence when idle
    * @returns true if the AudioEngine is capable of drain mode
    */
-  virtual bool SupportsDrain() { return false; }
+  virtual bool SupportsSilenceTimeout() { return false; }
 
   virtual void RegisterAudioCallback(IAudioCallback* pCallback) {}
 
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index b73bdda..72c8700 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -797,9 +797,6 @@ void CSettings::InitializeConditions()
   if (g_application.IsStandAlone())
     m_settingsManager->AddCondition("isstandalone");
 
-  if (CAEFactory::SupportsDrain())
-    m_settingsManager->AddCondition("audiosupportsdrain");
-
   if(CAEFactory::SupportsQualitySetting())
     m_settingsManager->AddCondition("has_ae_quality_levels");
 
-- 
1.8.4


From f4ba9e63790c8b4f42efba267eb383961d0825ec Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 26 Oct 2013 21:32:26 +0100
Subject: [PATCH 19/94] [rbp/omxplayer] Support timeout value of streamsilence

---
 .../AudioEngine/Engines/PiAudio/PiAudioAE.cpp      | 34 ++++++++++++++++++++--
 xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h |  6 +++-
 xbmc/cores/omxplayer/OMXAudio.cpp                  |  7 +++++
 3 files changed, 43 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
index 9eb46b7..ccf40b0 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.cpp
@@ -32,6 +32,7 @@
 #endif
 
 CPiAudioAE::CPiAudioAE()
+: CThread("CPiAudio")
 {
 }
 
@@ -42,14 +43,39 @@
 bool CPiAudioAE::Initialize()
 {
   UpdateStreamSilence();
+  Create();
   return true;
 }
 
+void CPiAudioAE::Process()
+{
+  while(!m_bStop)
+  {
+    /* thread just currently checks once a second if it's time to disable streamsilence */
+    Sleep(1000);
+
+    if (m_extSilenceTimer.IsTimePast())
+    {
+      UpdateStreamSilence(false);
+      m_extSilenceTimer.Set(XbmcThreads::EndTime::InfiniteValue);
+    }
+  }
+}
+
 void CPiAudioAE::UpdateStreamSilence()
 {
+  if (CSettings::Get().GetInt("audiooutput.streamsilence") > 0)
+    m_extSilenceTimeout = CSettings::Get().GetInt("audiooutput.streamsilence") * 60000;
+  else
+    m_extSilenceTimeout = XbmcThreads::EndTime::InfiniteValue;
+  m_extSilenceTimer.Set(m_extSilenceTimeout);
+  UpdateStreamSilence(CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI" &&
+              CSettings::Get().GetInt("audiooutput.streamsilence") != 0);
+}
+
+void CPiAudioAE::UpdateStreamSilence(bool enable)
+{
 #if defined(TARGET_RASPBERRY_PI)
-  bool enable = CSettings::Get().GetString("audiooutput.audiodevice") == "HDMI" &&
-                CSettings::Get().GetInt("audiooutput.streamsilence") != 0;
   char response[80] = "";
   char command[80] = "";
   sprintf(command, "force_audio hdmi %d", enable);
@@ -94,6 +120,8 @@ IAEStream *CPiAudioAE::MakeStream(enum AEDataFormat dataFormat, unsigned int sam
 
 IAEStream *CPiAudioAE::FreeStream(IAEStream *stream)
 {
+  // will retrigger the streamsilence timer
+  UpdateStreamSilence();
   return NULL;
 }
 
@@ -131,7 +159,7 @@ bool CPiAudioAE::SupportsRaw(AEDataFormat format)
 
 bool CPiAudioAE::SupportsSilenceTimeout()
 {
-  return false;
+  return true;
 }
 
 void CPiAudioAE::OnSettingsChange(const std::string& setting)
diff --git a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
index 4836ed6..944fba8 100644
--- a/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/PiAudio/PiAudioAE.h
@@ -29,13 +29,14 @@
 namespace PiAudioAE
 {
 
-class CPiAudioAE : public IAE
+class CPiAudioAE : public IAE, public CThread
 {
 protected:
   friend class ::CAEFactory;
   CPiAudioAE();
   virtual ~CPiAudioAE();
   virtual bool  Initialize();
+  virtual void Process();
 
 public:
   virtual bool   Suspend();
@@ -69,8 +70,11 @@ class CPiAudioAE : public IAE
 
 protected:
   void UpdateStreamSilence();
+  void UpdateStreamSilence(bool enable);
   // polled via the interface
   float m_aeVolume;
   bool m_aeMuted;
+  int m_extSilenceTimeout;
+  XbmcThreads::EndTime m_extSilenceTimer;
 };
 };
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 74ac027..764f26a 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -39,6 +39,7 @@
 #include "settings/Settings.h"
 #include "guilib/LocalizeStrings.h"
 #include "cores/AudioEngine/Utils/AEConvert.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 using namespace std;
 
@@ -776,6 +777,9 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
   CLog::Log(LOGDEBUG, "COMXAudio::Initialize device passthrough %d hwdecode %d",
      m_Passthrough, m_HWDecode);
 
+  /* dummy call to inform PiAudioAE that audo is active */
+  CAEFactory::MakeStream((enum AEDataFormat)0, 0, 0, (CAEChannelInfo)0, 0);
+
   return true;
 }
 
@@ -842,6 +846,9 @@ bool COMXAudio::Deinitialize()
 
   m_last_pts      = DVD_NOPTS_VALUE;
 
+  /* dummy call to inform PiAudioAE that audo is inactive */
+  CAEFactory::FreeStream(0);
+
   return true;
 }
 
-- 
1.8.4


From d65a5aaf22bf8a09747bd81025222c03c21859d4 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:34:39 +0200
Subject: [PATCH 20/94] videoplayer: adapt lateness detection and dropping to
 buffering

---
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  16 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |  12 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |  15 +-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |  31 ++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |   7 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            | 194 +++++++++++++++++----
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |  23 +++
 7 files changed, 260 insertions(+), 38 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 249222a..c0a6409 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -300,6 +300,8 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -641,7 +643,7 @@ void CXBMCRenderManager::SetViewMode(int iViewMode)
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -709,6 +711,7 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -1077,6 +1080,8 @@ void CXBMCRenderManager::PrepareNextRender()
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1093,3 +1098,12 @@ void CXBMCRenderManager::DiscardBuffer()
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index c469795..949c652b 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -98,10 +98,11 @@ class CXBMCRenderManager
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -176,6 +177,12 @@ class CXBMCRenderManager
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -222,6 +229,7 @@ class CXBMCRenderManager
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -233,6 +241,8 @@ class CXBMCRenderManager
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index baee6e0..8a88c0d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -123,6 +123,10 @@ struct DVDVideoUserData
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100
+#define DVP_FLAG_DRAIN              0x00000200
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -140,6 +144,9 @@ struct DVDVideoUserData
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+#define VC_HURRY    0x00000040
+
 class CDVDVideoCodec
 {
 public:
@@ -257,10 +264,16 @@ class CDVDVideoCodec
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
    */
   virtual unsigned GetAllowedReferences() { return 0; }
+
+  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced)
+  {
+    return false;
+  }
+
+  virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 143675a..b53c17a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -167,6 +167,7 @@ enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -353,6 +354,14 @@ void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -554,6 +563,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
   m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
 
@@ -663,6 +673,22 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -924,3 +950,8 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
   else
     return 0;
 }
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 2287031..8376f72 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -45,6 +45,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
   };
@@ -62,6 +63,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced) {pts=m_decoderPts; skippedDeint=m_skippedDeint; if (m_pFrame) interlaced = m_pFrame->interlaced_frame; return true;}
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -127,4 +130,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
 };
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 2321d2c..d8a61f8 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -39,6 +39,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
@@ -323,8 +324,10 @@ void CDVDPlayerVideo::Process()
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -434,6 +437,7 @@ void CDVDPlayerVideo::Process()
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -446,6 +450,7 @@ void CDVDPlayerVideo::Process()
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -463,8 +468,10 @@ void CDVDPlayerVideo::Process()
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -510,6 +517,28 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -562,15 +591,7 @@ void CDVDPlayerVideo::Process()
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
       // reset the request, the following while loop may break before
       // setting the flag to a new value
       bRequestDrop = false;
@@ -1183,33 +1204,12 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimeStamp += iFrameDuration;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
-  {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1242,7 +1242,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1542,3 +1542,127 @@ void CDVDPlayerVideo::CalcFrameRate()
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  int    interlaced;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iSkippedDeint = 0;
+  int    iBufferLevel;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetPts(iDecoderPts, iSkippedDeint, interlaced))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  if (interlaced)
+    iInterval = 2/m_fFrameRate*(double)DVD_TIME_BASE;
+  else
+    iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop
+      && m_droppingStats.m_dropRequests > 0)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iSkippedDeint)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped de-interlacing cycle, Sleeptime: %f, Bufferlevel: %d", iSleepTime, iBufferLevel);
+    }
+    else if (iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        result |= EOS_VERYLATE;
+        if (bNewFrame)
+          m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index f8ad541..186e271 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -36,6 +36,25 @@
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
+
 class CDVDPlayerVideo : public CThread
 {
 public:
@@ -104,6 +123,7 @@ class CDVDPlayerVideo : public CThread
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -129,6 +149,7 @@ class CDVDPlayerVideo : public CThread
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -182,5 +203,7 @@ class CDVDPlayerVideo : public CThread
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 
-- 
1.8.4


From 5289d4beab87e879b88723b3819a46cc35094aaf Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Sep 2012 16:05:21 +0200
Subject: [PATCH 21/94] video player: present correct pts to user for a/v sync
 (after buffering in renderer)

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 25 +++++++++++++++++++++++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  2 +-
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index d8a61f8..752a291 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1462,6 +1462,22 @@ void CDVDPlayerVideo::ResetFrameRateCalc()
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
@@ -1580,6 +1596,15 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   else
     iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
 
+
+  m_FlipTimeStamp = m_pClock->GetAbsoluteClock() + max(0.0, iSleepTime) + iInterval;
+
+  if( m_stalled )
+    m_iCurrentPts = DVD_NOPTS_VALUE;
+  else
+    m_iCurrentPts = iRenderPts - max(0.0, iSleepTime);
+
+
   if (m_droppingStats.m_lastDecoderPts > 0
       && bNewFrame
       && m_bAllowDrop
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 186e271..59c7f09 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -100,7 +100,7 @@ class CDVDPlayerVideo : public CThread
 
   bool InitializedOutputDevice();
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
   int    GetPullupCorrection()                     { return m_pullupCorrection.GetPatternLength(); }
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
-- 
1.8.4


From 907ec7c3a090ca68f37368d5b756fc1a43f18b4a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 16 Feb 2013 18:25:53 +0100
Subject: [PATCH 22/94] videoplayer: some rework and documentation

---
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      | 29 ++++++++++++++++++++--
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        | 11 ++++++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |  2 +-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |  2 +-
 4 files changed, 40 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 8a88c0d..b898491 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -145,7 +145,6 @@ struct DVDVideoUserData
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
 #define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
-#define VC_HURRY    0x00000040
 
 class CDVDVideoCodec
 {
@@ -270,10 +269,36 @@ class CDVDVideoCodec
    */
   virtual unsigned GetAllowedReferences() { return 0; }
 
-  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced)
+  /**
+   * For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - skippedDeint : indicates if decoder has just skipped a deinterlacing cycle
+   *   instead of dropping a full frame
+   * - interlaced : when detecting gaps in pts, player needs to know whether
+   *   it's interlaced or not
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case coded does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
   {
     return false;
   }
 
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
   virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index b53c17a..9f1fc03 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -951,6 +951,17 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
     return 0;
 }
 
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+{
+  pts = m_decoderPts;
+  skippedDeint = m_skippedDeint;
+  if (m_pFrame)
+    interlaced = m_pFrame->interlaced_frame;
+  else
+    interlaced = 0;
+  return true;
+}
+
 void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
 {
   m_codecControlFlags = flags;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 8376f72..c0ce198 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -63,7 +63,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
-  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced) {pts=m_decoderPts; skippedDeint=m_skippedDeint; if (m_pFrame) interlaced = m_pFrame->interlaced_frame; return true;}
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced);
   virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 752a291..0aef5ee 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1573,7 +1573,7 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iBufferLevel;
 
   // get decoder stats
-  if (!m_pVideoCodec->GetPts(iDecoderPts, iSkippedDeint, interlaced))
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
     iDecoderPts = pts;
   if (iDecoderPts == DVD_NOPTS_VALUE)
     iDecoderPts = pts;
-- 
1.8.4


From f5599129105901cc261b722f2a1cd0e6c3122512 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 1 Jun 2013 11:21:19 +0200
Subject: [PATCH 23/94] renderer: bump buffers to 5

---
 xbmc/cores/VideoRenderers/BaseRenderer.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index a61d3cf..df5fe0e 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -29,7 +29,7 @@
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 class CSetting;
 
-- 
1.8.4


From 9c0f9254ed24df39d2abb5a70e9278e4fa55a69e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:41:31 +0200
Subject: [PATCH 24/94] videoplayer: update frametime, it might change due to
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 0aef5ee..e7e5097 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -711,6 +711,8 @@ void CDVDPlayerVideo::Process()
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();
-- 
1.8.4


From 49e298f72234250bcc6dcb4c2786721a8d1aee8b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:43:06 +0200
Subject: [PATCH 25/94] videoplayer: give streams with invalid fps a chance for
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index e7e5097..c40d193 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1504,7 +1504,7 @@ void CDVDPlayerVideo::CalcFrameRate()
   double frameduration = m_pullupCorrection.GetFrameDuration();
 
   if (frameduration == DVD_NOPTS_VALUE ||
-      (g_advancedSettings.m_videoFpsDetect == 1 && m_pullupCorrection.GetPatternLength() > 1))
+      (g_advancedSettings.m_videoFpsDetect == 1 && (m_pullupCorrection.GetPatternLength() > 1 && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;
-- 
1.8.4


From 1ecba467cbd4549060419f8824b1c23f5dea734f Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:49:05 +0200
Subject: [PATCH 26/94] dvdplayer: allow rewinding at end of stream, do a seek
 after rewind

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index c412b9f..437276b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1548,7 +1548,7 @@ void CDVDPlayer::HandlePlaySpeed()
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
           &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
           &&  m_SpeedState.lasttime != GetTime())
     {
@@ -2214,6 +2214,12 @@ void CDVDPlayer::HandleMessages()
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet
-- 
1.8.4


From 870ce55e5db4bb5beeec820939baea4d3eee8aab Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:22:05 +0200
Subject: [PATCH 27/94] X11: ditch SDL for video and window events

---
 xbmc/Application.cpp                |   2 +-
 xbmc/system.h                       |   5 +
 xbmc/windowing/Makefile.in          |   1 +
 xbmc/windowing/WinEvents.cpp        |   4 +
 xbmc/windowing/WinEventsX11.cpp     | 784 ++++++++++++++++++++++++++++++++++++
 xbmc/windowing/WinEventsX11.h       |  65 +++
 xbmc/windowing/X11/WinSystemX11.cpp | 387 ++++++++++++------
 xbmc/windowing/X11/WinSystemX11.h   |  10 +-
 8 files changed, 1130 insertions(+), 128 deletions(-)
 create mode 100644 xbmc/windowing/WinEventsX11.cpp
 create mode 100644 xbmc/windowing/WinEventsX11.h

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index b27d49d..a016050 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -856,7 +856,7 @@ bool CApplication::CreateGUI()
 
   uint32_t sdlFlags = 0;
 
-#if defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)
+#if (defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)) && !defined(HAS_GLX)
   sdlFlags |= SDL_INIT_VIDEO;
 #endif
 
diff --git a/xbmc/system.h b/xbmc/system.h
index 1f4e15f..075e44a 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -171,16 +171,21 @@
 #define HAS_GL
 #ifdef HAVE_X11
 #define HAS_GLX
+#define HAS_X11_WIN_EVENTS
 #endif
 #ifdef HAVE_SDL
 #define HAS_SDL
 #ifndef HAS_SDL_OPENGL
 #define HAS_SDL_OPENGL
 #endif
+#ifndef HAVE_X11
 #define HAS_SDL_WIN_EVENTS
+#endif
 #else
+#ifndef HAVE_X11
 #define HAS_LINUX_EVENTS
 #endif
+#endif
 #define HAS_LINUX_NETWORK
 #define HAS_LIRC
 #ifdef HAVE_LIBPULSE
diff --git a/xbmc/windowing/Makefile.in b/xbmc/windowing/Makefile.in
index 6704967..4b41723 100644
--- a/xbmc/windowing/Makefile.in
+++ b/xbmc/windowing/Makefile.in
@@ -1,6 +1,7 @@
 SRCS=WinEventsSDL.cpp \
      WinEventsLinux.cpp \
      WinEventsWayland.cpp \
+     WinEventsX11.cpp \
      WinSystem.cpp \
      WinEvents.cpp
 
diff --git a/xbmc/windowing/WinEvents.cpp b/xbmc/windowing/WinEvents.cpp
index 1022ad2..8e64497 100644
--- a/xbmc/windowing/WinEvents.cpp
+++ b/xbmc/windowing/WinEvents.cpp
@@ -42,6 +42,10 @@
 #include "WinEventsSDL.h"
 #define WinEventsType CWinEventsSDL
 
+#elif (defined(TARGET_FREEBSD) || defined(TARGET_LINUX)) && defined(HAS_X11_WIN_EVENTS)
+#include "WinEventsX11.h"
+#define WinEventsType CWinEventsX11
+
 #elif defined(HAVE_WAYLAND)
 #include "WinEventsWayland.h"
 #define WinEventsType CWinEventsWayland
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
new file mode 100644
index 0000000..ad58aad
--- /dev/null
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -0,0 +1,784 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "system.h"
+
+#ifdef HAS_X11_WIN_EVENTS
+
+#include "WinEvents.h"
+#include "WinEventsX11.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include <X11/Xlib.h>
+#include "X11/WinSystemX11GL.h"
+#include "X11/keysymdef.h"
+#include "X11/XF86keysym.h"
+#include "utils/log.h"
+#include "guilib/GUIWindowManager.h"
+#include "input/MouseStat.h"
+
+CWinEventsX11Imp* CWinEventsX11Imp::WinEvents = 0;
+
+static uint32_t SymMappingsX11[][2] =
+{
+  {XK_BackSpace, XBMCK_BACKSPACE}
+, {XK_Tab, XBMCK_TAB}
+, {XK_Clear, XBMCK_CLEAR}
+, {XK_Return, XBMCK_RETURN}
+, {XK_Pause, XBMCK_PAUSE}
+, {XK_Escape, XBMCK_ESCAPE}
+, {XK_Delete, XBMCK_DELETE}
+// multi-media keys
+, {XF86XK_Back, XBMCK_BROWSER_BACK}
+, {XF86XK_Forward, XBMCK_BROWSER_FORWARD}
+, {XF86XK_Refresh, XBMCK_BROWSER_REFRESH}
+, {XF86XK_Stop, XBMCK_BROWSER_STOP}
+, {XF86XK_Search, XBMCK_BROWSER_SEARCH}
+, {XF86XK_Favorites, XBMCK_BROWSER_FAVORITES}
+, {XF86XK_HomePage, XBMCK_BROWSER_HOME}
+, {XF86XK_AudioMute, XBMCK_VOLUME_MUTE}
+, {XF86XK_AudioLowerVolume, XBMCK_VOLUME_DOWN}
+, {XF86XK_AudioRaiseVolume, XBMCK_VOLUME_UP}
+, {XF86XK_AudioNext, XBMCK_MEDIA_NEXT_TRACK}
+, {XF86XK_AudioPrev, XBMCK_MEDIA_PREV_TRACK}
+, {XF86XK_AudioStop, XBMCK_MEDIA_STOP}
+, {XF86XK_AudioPause, XBMCK_MEDIA_PLAY_PAUSE}
+, {XF86XK_Mail, XBMCK_LAUNCH_MAIL}
+, {XF86XK_Select, XBMCK_LAUNCH_MEDIA_SELECT}
+, {XF86XK_Launch0, XBMCK_LAUNCH_APP1}
+, {XF86XK_Launch1, XBMCK_LAUNCH_APP2}
+, {XF86XK_WWW, XBMCK_LAUNCH_FILE_BROWSER}
+, {XF86XK_AudioMedia, XBMCK_LAUNCH_MEDIA_CENTER }
+  // Numeric keypad
+, {XK_KP_0, XBMCK_KP0}
+, {XK_KP_1, XBMCK_KP1}
+, {XK_KP_2, XBMCK_KP2}
+, {XK_KP_3, XBMCK_KP3}
+, {XK_KP_4, XBMCK_KP4}
+, {XK_KP_5, XBMCK_KP5}
+, {XK_KP_6, XBMCK_KP6}
+, {XK_KP_7, XBMCK_KP7}
+, {XK_KP_8, XBMCK_KP8}
+, {XK_KP_9, XBMCK_KP9}
+, {XK_KP_Separator, XBMCK_KP_PERIOD}
+, {XK_KP_Divide, XBMCK_KP_DIVIDE}
+, {XK_KP_Multiply, XBMCK_KP_MULTIPLY}
+, {XK_KP_Subtract, XBMCK_KP_MINUS}
+, {XK_KP_Add, XBMCK_KP_PLUS}
+, {XK_KP_Enter, XBMCK_KP_ENTER}
+, {XK_KP_Equal, XBMCK_KP_EQUALS}
+  // Arrows + Home/End pad
+, {XK_Up, XBMCK_UP}
+, {XK_Down, XBMCK_DOWN}
+, {XK_Right, XBMCK_RIGHT}
+, {XK_Left, XBMCK_LEFT}
+, {XK_Insert, XBMCK_INSERT}
+, {XK_Home, XBMCK_HOME}
+, {XK_End, XBMCK_END}
+, {XK_Page_Up, XBMCK_PAGEUP}
+, {XK_Page_Down, XBMCK_PAGEDOWN}
+  // Function keys
+, {XK_F1, XBMCK_F1}
+, {XK_F2, XBMCK_F2}
+, {XK_F3, XBMCK_F3}
+, {XK_F4, XBMCK_F4}
+, {XK_F5, XBMCK_F5}
+, {XK_F6, XBMCK_F6}
+, {XK_F7, XBMCK_F7}
+, {XK_F8, XBMCK_F8}
+, {XK_F9, XBMCK_F9}
+, {XK_F10, XBMCK_F10}
+, {XK_F11, XBMCK_F11}
+, {XK_F12, XBMCK_F12}
+, {XK_F13, XBMCK_F13}
+, {XK_F14, XBMCK_F14}
+, {XK_F15, XBMCK_F15}
+  // Key state modifier keys
+, {XK_Num_Lock, XBMCK_NUMLOCK}
+, {XK_Caps_Lock, XBMCK_CAPSLOCK}
+, {XK_Scroll_Lock, XBMCK_SCROLLOCK}
+, {XK_Shift_R, XBMCK_RSHIFT}
+, {XK_Shift_L, XBMCK_LSHIFT}
+, {XK_Control_R, XBMCK_RCTRL}
+, {XK_Control_L, XBMCK_LCTRL}
+, {XK_Alt_R, XBMCK_RALT}
+, {XK_Alt_L, XBMCK_LALT}
+, {XK_Meta_R, XBMCK_RMETA}
+, {XK_Meta_L, XBMCK_LMETA}
+, {XK_Super_L, XBMCK_LSUPER}
+, {XK_Super_R, XBMCK_RSUPER}
+, {XK_Mode_switch, XBMCK_MODE}
+, {XK_Multi_key, XBMCK_COMPOSE}
+  // Miscellaneous function keys
+, {XK_Help, XBMCK_HELP}
+, {XK_Print, XBMCK_PRINT}
+//, {0, XBMCK_SYSREQ}
+, {XK_Break, XBMCK_BREAK}
+, {XK_Menu, XBMCK_MENU}
+, {XF86XK_PowerOff, XBMCK_POWER}
+, {XK_EcuSign, XBMCK_EURO}
+, {XK_Undo, XBMCK_UNDO}
+  /* Media keys */
+, {XF86XK_Eject, XBMCK_EJECT}
+, {XF86XK_Stop, XBMCK_STOP}
+, {XF86XK_AudioRecord, XBMCK_RECORD}
+, {XF86XK_AudioRewind, XBMCK_REWIND}
+, {XF86XK_Phone, XBMCK_PHONE}
+, {XF86XK_AudioPlay, XBMCK_PLAY}
+, {XF86XK_AudioRandomPlay, XBMCK_SHUFFLE}
+, {XF86XK_AudioForward, XBMCK_FASTFORWARD}
+};
+
+bool CWinEventsX11::MessagePump()
+{
+  return CWinEventsX11Imp::MessagePump();
+}
+
+size_t CWinEventsX11::GetQueueSize()
+{
+  return CWinEventsX11Imp::GetQueueSize();
+}
+
+CWinEventsX11Imp::CWinEventsX11Imp()
+{
+  m_display = 0;
+  m_window = 0;
+  m_keybuf = 0;
+  m_utf16buf = 0;
+}
+
+CWinEventsX11Imp::~CWinEventsX11Imp()
+{
+  if (m_keybuf);
+  {
+    free(m_keybuf);
+    m_keybuf = 0;
+  }
+
+  if (m_utf16buf)
+  {
+    free(m_utf16buf);
+    m_utf16buf = 0;
+  }
+
+  if (m_xic)
+  {
+    XUnsetICFocus(m_xic);
+    XDestroyIC(m_xic);
+    m_xic = 0;
+  }
+
+  if (m_xim)
+  {
+    XCloseIM(m_xim);
+    m_xim = 0;
+  }
+
+  m_symLookupTable.clear();
+}
+
+bool CWinEventsX11Imp::Init(Display *dpy, Window win)
+{
+  if (WinEvents)
+    return true;
+
+  WinEvents = new CWinEventsX11Imp();
+  WinEvents->m_display = dpy;
+  WinEvents->m_window = win;
+  WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
+  WinEvents->m_utf16buf = (uint16_t*)malloc(32*sizeof(uint16_t));
+  WinEvents->m_keymodState = 0;
+  WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+  WinEvents->m_structureChanged = false;
+  memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
+
+  // open input method
+  char *old_locale = NULL, *old_modifiers = NULL;
+  char res_name[8];
+  const char *p;
+  size_t n;
+
+  // set resource name to xbmc, not used
+  strcpy(res_name, "xbmc");
+
+  // save current locale, this should be "C"
+  p = setlocale(LC_ALL, NULL);
+  if (p)
+  {
+    old_locale = (char*)malloc(strlen(p) +1);
+    strcpy(old_locale, p);
+  }
+  p = XSetLocaleModifiers(NULL);
+  if (p)
+  {
+    old_modifiers = (char*)malloc(strlen(p) +1);
+    strcpy(old_modifiers, p);
+  }
+
+  // set users preferences and open input method
+  p = setlocale(LC_ALL, "");
+  XSetLocaleModifiers("");
+  WinEvents->m_xim = XOpenIM(WinEvents->m_display, NULL, res_name, res_name);
+
+  // restore old locale
+  if (old_locale)
+  {
+    setlocale(LC_ALL, old_locale);
+    free(old_locale);
+  }
+  if (old_modifiers)
+  {
+    XSetLocaleModifiers(old_modifiers);
+    free(old_modifiers);
+  }
+
+  WinEvents->m_xic = NULL;
+  if (WinEvents->m_xim)
+  {
+    WinEvents->m_xic = XCreateIC(WinEvents->m_xim,
+                                 XNClientWindow, WinEvents->m_window,
+                                 XNFocusWindow, WinEvents->m_window,
+                                 XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+                                 XNResourceName, res_name,
+                                 XNResourceClass, res_name,
+                                 NULL);
+  }
+
+  if (!WinEvents->m_xic)
+    CLog::Log(LOGWARNING,"CWinEventsX11::Init - no input method found");
+
+  // build Keysym lookup table
+  for (unsigned int i = 0; i < sizeof(SymMappingsX11)/(2*sizeof(uint32_t)); ++i)
+  {
+    WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
+  }
+
+  return true;
+}
+
+void CWinEventsX11Imp::Quit()
+{
+  if (!WinEvents)
+    return;
+
+  delete WinEvents;
+  WinEvents = 0;
+}
+
+bool CWinEventsX11Imp::HasStructureChanged()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = WinEvents->m_structureChanged;
+  WinEvents->m_structureChanged = false;
+  return ret;
+}
+
+bool CWinEventsX11Imp::MessagePump()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = false;
+  XEvent xevent;
+  unsigned long serial = 0;
+
+  while (WinEvents && XPending(WinEvents->m_display))
+  {
+    memset(&xevent, 0, sizeof (XEvent));
+    XNextEvent(WinEvents->m_display, &xevent);
+
+    //  ignore events generated by auto-repeat
+    if (xevent.type == KeyRelease && XPending(WinEvents->m_display))
+    {
+      XEvent peekevent;
+      XPeekEvent(WinEvents->m_display, &peekevent);
+      if ((peekevent.type == KeyPress) &&
+          (peekevent.xkey.keycode == xevent.xkey.keycode) &&
+          ((peekevent.xkey.time - xevent.xkey.time) < 2))
+      {
+        XNextEvent(WinEvents->m_display, &peekevent);
+        continue;
+      }
+    }
+
+    if (XFilterEvent(&xevent, None))
+      continue;
+
+    switch (xevent.type)
+    {
+      case MapNotify:
+      {
+        g_application.SetRenderGUI(true);
+        break;
+      }
+
+      case UnmapNotify:
+      {
+        g_application.SetRenderGUI(false);
+        break;
+      }
+
+      case FocusIn:
+      {
+        if (WinEvents->m_xic)
+          XSetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = true;
+        if (serial == xevent.xfocus.serial)
+          break;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        break;
+      }
+
+      case FocusOut:
+      {
+        if (WinEvents->m_xic)
+          XUnsetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = false;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        serial = xevent.xfocus.serial;
+        break;
+      }
+
+      case Expose:
+      {
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ConfigureNotify:
+      {
+        if (xevent.xconfigure.window != WinEvents->m_window)
+          break;
+
+        WinEvents->m_structureChanged = true;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_VIDEORESIZE;
+        newEvent.resize.w = xevent.xconfigure.width;
+        newEvent.resize.h = xevent.xconfigure.height;
+        ret |= g_application.OnEvent(newEvent);
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ClientMessage:
+      {
+        if (xevent.xclient.data.l[0] == WinEvents->m_wmDeleteMessage)
+          if (!g_application.m_bStop) CApplicationMessenger::Get().Quit();
+        break;
+      }
+
+      case KeyPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYDOWN;
+        KeySym xkeysym;
+
+        // fallback if we have no IM
+        if (!WinEvents->m_xic)
+        {
+          static XComposeStatus state;
+          char keybuf[32];
+          xkeysym = XLookupKeysym(&xevent.xkey, 0);
+          newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+          newEvent.key.keysym.scancode = xevent.xkey.keycode;
+          newEvent.key.state = xevent.xkey.state;
+          newEvent.key.type = xevent.xkey.type;
+          if (XLookupString(&xevent.xkey, keybuf, sizeof(keybuf), NULL, &state))
+          {
+            newEvent.key.keysym.unicode = keybuf[0];
+          }
+          ret |= ProcessKey(newEvent, 500);
+          break;
+        }
+
+        Status status;
+        int utf16size;
+        int utf16length;
+        int len;
+        len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                &xkeysym, &status);
+        if (status == XBufferOverflow)
+        {
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, len*sizeof(char));
+          len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                  WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                  &xkeysym, &status);
+        }
+        switch (status)
+        {
+          case XLookupNone:
+            break;
+          case XLookupChars:
+          case XLookupBoth:
+          {
+            if (len == 0)
+              break;
+            utf16size = len * sizeof(uint16_t);
+            if (utf16size > sizeof(WinEvents->m_utf16buf))
+            {
+              WinEvents->m_utf16buf = (uint16_t *)realloc(WinEvents->m_utf16buf,utf16size);
+              if (WinEvents->m_utf16buf == NULL)
+              {
+                break;
+              }
+            }
+            utf16length = Utf8ToUnicode(WinEvents->m_keybuf, len, WinEvents->m_utf16buf, utf16size);
+            if (utf16length < 0)
+            {
+              break;
+            }
+            for (unsigned int i = 0; i < utf16length - 1; i++)
+            {
+              newEvent.key.keysym.sym = XBMCK_UNKNOWN;
+              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[i];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+              ret |= ProcessKey(newEvent, 500);
+            }
+            if (utf16length > 0)
+            {
+              newEvent.key.keysym.scancode = xevent.xkey.keycode;
+              xkeysym = XLookupKeysym(&xevent.xkey, 0);
+              newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[utf16length - 1];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+
+              ret |= ProcessKey(newEvent, 500);
+            }
+            break;
+          }
+
+          case XLookupKeySym:
+          {
+            newEvent.key.keysym.scancode = xevent.xkey.keycode;
+            newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+            newEvent.key.state = xevent.xkey.state;
+            newEvent.key.type = xevent.xkey.type;
+            ret |= ProcessKey(newEvent, 500);
+            break;
+          }
+
+        }// switch status
+        break;
+      } //KeyPress
+
+      case KeyRelease:
+      {
+        XBMC_Event newEvent;
+        KeySym xkeysym;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYUP;
+        xkeysym = XLookupKeysym(&xevent.xkey, 0);
+        newEvent.key.keysym.scancode = xevent.xkey.keycode;
+        newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+        newEvent.key.state = xevent.xkey.state;
+        newEvent.key.type = xevent.xkey.type;
+        ret |= ProcessKey(newEvent, 0);
+        break;
+      }
+
+      // lose mouse coverage
+      case LeaveNotify:
+      {
+        g_Mouse.SetActive(false);
+        break;
+      }
+
+      case MotionNotify:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEMOTION;
+        newEvent.motion.xrel = (int16_t)xevent.xmotion.x_root;
+        newEvent.motion.yrel = (int16_t)xevent.xmotion.y_root;
+        newEvent.motion.x = (int16_t)xevent.xmotion.x;
+        newEvent.motion.y = (int16_t)xevent.xmotion.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONDOWN;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_PRESSED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonRelease:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONUP;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_RELEASED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      default:
+      {
+        break;
+      }
+    }// switch event.type
+  }// while
+
+  ret |= ProcessKeyRepeat();
+
+  return ret;
+}
+
+size_t CWinEventsX11Imp::GetQueueSize()
+{
+  int ret = 0;
+
+  if (WinEvents)
+    ret = XPending(WinEvents->m_display);
+
+  return ret;
+}
+
+bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event, int repeatDelay)
+{
+  if (event.type == XBMC_KEYDOWN)
+  {
+    // check key modifiers
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState |= XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState |= XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+    memcpy(&(WinEvents->m_lastKey), &event, sizeof(event));
+    WinEvents->m_repeatKeyTimeout.Set(repeatDelay);
+
+    bool ret = ProcessShortcuts(event);
+    if (ret)
+      return ret;
+  }
+  else if (event.type == XBMC_KEYUP)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState &= ~XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+    memset(&(WinEvents->m_lastKey), 0, sizeof(event));
+  }
+
+  return g_application.OnEvent(event);
+}
+
+bool CWinEventsX11Imp::ProcessShortcuts(XBMC_Event& event)
+{
+  if (event.key.keysym.mod & XBMCKMOD_ALT)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_TAB:  // ALT+TAB to minimize/hide
+        g_application.Minimize();
+        return true;
+
+      default:
+        return false;
+    }
+  }
+  return false;
+}
+
+bool CWinEventsX11Imp::ProcessKeyRepeat()
+{
+  if (WinEvents && (WinEvents->m_lastKey.type == XBMC_KEYDOWN))
+  {
+    if (WinEvents->m_repeatKeyTimeout.IsTimePast())
+    {
+      return ProcessKey(WinEvents->m_lastKey, 10);
+    }
+  }
+  return false;
+}
+
+int CWinEventsX11Imp::Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength)
+{
+  // p moves over the output buffer.  max_ptr points to the next to the last slot of the buffer.
+  uint16_t *p = utf16;
+  uint16_t const *const maxPtr = utf16 + utf16MaxLength;
+
+  // end_of_input points to the last byte of input as opposed to the next to the last byte.
+  char const *const endOfInput = utf8 + utf8Length - 1;
+
+  while (utf8 <= endOfInput)
+  {
+    unsigned char const c = *utf8;
+    if (p >= maxPtr)
+    {
+      //No more output space.
+      return -1;
+    }
+    if (c < 0x80)
+    {
+      //One byte ASCII.
+      *p++ = c;
+      utf8 += 1;
+    }
+    else if (c < 0xC0)
+    {
+      // Follower byte without preceding leader bytes.
+      return -1;
+    }
+    // 11 bits
+    else if (c < 0xE0)
+    {
+      // Two byte sequence.  We need one follower byte.
+      if (endOfInput - utf8 < 1 || (((utf8[1] ^ 0x80)) & 0xC0))
+      {
+        return -1;
+      }
+      *p++ = (uint16_t)(((c & 0x1F) << 6) + (utf8[1] & 0x3F));
+      utf8 += 2;
+    }
+    // 16 bis
+    else if (c < 0xF0)
+    {
+      // Three byte sequence.  We need two follower byte.
+      if (endOfInput - utf8 < 2 || ((utf8[1] ^ 0x80) & 0xC0) || ((utf8[2] ^ 0x80) & 0xC0))
+      {
+        return -1;
+      }
+      *p++ = (uint16_t)(((c & 0xF) << 12) + ((utf8[1] & 0x3F) << 6) + (utf8[2] & 0x3F));
+      utf8 += 3;
+    }
+    // 21 bits
+    else if (c < 0xF8)
+    {
+      int plane;
+      // Four byte sequence.  We need three follower bytes.
+      if (endOfInput - utf8 < 3 || ((utf8[1] ^ 0x80) & 0xC0) ||
+          ((utf8[2] ^ 0x80) & 0xC0) || ((utf8[3] ^ 0x80) & 0xC0))
+      {
+        return -1;
+      }
+      uint32_t unicode = ((c & 0x7) << 18) + ((utf8[1] & 0x3F) << 12) +
+                          ((utf8[2] & 0x3F) << 6) + (utf8[3] & 0x3F);
+      utf8 += 4;
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+    }
+    // 26 bits
+    else if (c < 0xFC)
+    {
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+      utf8 += 5;
+    }
+    // 31 bit
+    else
+    {
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+      utf8 += 6;
+    }
+  }
+  return p - utf16;
+}
+
+XBMCKey CWinEventsX11Imp::LookupXbmcKeySym(KeySym keysym)
+{
+  // try direct mapping first
+  std::map<uint32_t, uint32_t>::iterator it;
+  it = WinEvents->m_symLookupTable.find(keysym);
+  if (it != WinEvents->m_symLookupTable.end())
+  {
+    return (XBMCKey)(it->second);
+  }
+
+  // try ascii mappings
+  if (keysym>>8 == 0x00)
+    return (XBMCKey)(keysym & 0xFF);
+
+  return (XBMCKey)keysym;
+}
+#endif
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
new file mode 100644
index 0000000..ce57c23
--- /dev/null
+++ b/xbmc/windowing/WinEventsX11.h
@@ -0,0 +1,65 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#pragma once
+
+#include "WinEvents.h"
+#include <X11/Xlib.h>
+#include "threads/SystemClock.h"
+#include <map>
+
+class CWinEventsX11 : public IWinEvents
+{
+public:
+  virtual bool MessagePump();
+  virtual size_t GetQueueSize();
+};
+
+class CWinEventsX11Imp
+{
+public:
+  CWinEventsX11Imp();
+  virtual ~CWinEventsX11Imp();
+  static bool Init(Display *dpy, Window win);
+  static void Quit();
+  static bool HasStructureChanged();
+  static bool MessagePump();
+  static size_t GetQueueSize();
+
+protected:
+  static int Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength);
+  static XBMCKey LookupXbmcKeySym(KeySym keysym);
+  static bool ProcessKey(XBMC_Event &event, int repeatDelay);
+  static bool ProcessKeyRepeat();
+  static bool ProcessShortcuts(XBMC_Event& event);
+  static CWinEventsX11Imp *WinEvents;
+  Display *m_display;
+  Window m_window;
+  Atom m_wmDeleteMessage;
+  char *m_keybuf;
+  uint16_t *m_utf16buf;
+  XIM m_xim;
+  XIC m_xic;
+  XBMC_Event m_lastKey;
+  XbmcThreads::EndTime m_repeatKeyTimeout;
+  std::map<uint32_t,uint32_t> m_symLookupTable;
+  int m_keymodState;
+  bool m_structureChanged;
+};
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 7caae9d..a32f487 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -22,7 +22,6 @@
 
 #ifdef HAS_GLX
 
-#include <SDL/SDL_syswm.h>
 #include "WinSystemX11.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
@@ -34,27 +33,30 @@
 #include "XRandR.h"
 #include <vector>
 #include "threads/SingleLock.h"
-#include <X11/Xlib.h>
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
+//#include "settings/GUISettings.h"
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
 #endif
 
+#include "../WinEventsX11.h"
+#include "input/MouseStat.h"
+
 using namespace std;
 
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
   m_glContext = NULL;
-  m_SDLSurface = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
-  m_wmWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
+  m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
+  m_invisibleCursor = 0;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -67,18 +69,6 @@ bool CWinSystemX11::InitWindowSystem()
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-
-    SDL_EnableUNICODE(1);
-    // set repeat to 10ms to ensure repeat time < frame time
-    // so that hold times can be reliably detected
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, 10);
-
-    SDL_GL_SetAttribute(SDL_GL_RED_SIZE,   8);
-    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE,  8);
-    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-
     return CWinSystemBase::InitWindowSystem();
   }
   else
@@ -116,45 +106,37 @@ bool CWinSystemX11::DestroyWindowSystem()
 
 bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
 {
-  RESOLUTION_INFO& desktop = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP);
-
-  if (fullScreen &&
-      (res.iWidth != desktop.iWidth || res.iHeight != desktop.iHeight ||
-       res.fRefreshRate != desktop.fRefreshRate || res.iScreen != desktop.iScreen))
-  {
-    //on the first call to SDL_SetVideoMode, SDL stores the current displaymode
-    //SDL restores the displaymode on SDL_QUIT(), if we change the displaymode
-    //before the first call to SDL_SetVideoMode, SDL changes the displaymode back
-    //to the wrong mode on exit
-
-    CLog::Log(LOGINFO, "CWinSystemX11::CreateNewWindow initializing to desktop resolution first");
-    if (!SetFullScreen(true, desktop, false))
-      return false;
-  }
-
   if(!SetFullScreen(fullScreen, res, false))
     return false;
 
-  CBaseTexture* iconTexture = CTexture::LoadFromFile("special://xbmc/media/icon.png");
-
-  if (iconTexture)
-    SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture->GetPixels(), iconTexture->GetWidth(), iconTexture->GetHeight(), 32, iconTexture->GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
-  SDL_WM_SetCaption("XBMC Media Center", NULL);
-  delete iconTexture;
-
-  // register XRandR Events
-#if defined(HAS_XRANDR)
-  int iReturn;
-  XRRQueryExtension(m_dpy, &m_RREventBase, &iReturn);
-  XRRSelectInput(m_dpy, m_wmWindow, RRScreenChangeNotifyMask);
-#endif
-
   m_bWindowCreated = true;
   return true;
 }
 
 bool CWinSystemX11::DestroyWindow()
 {
+  if (!m_glWindow)
+    return true;
+
+  if (m_glContext)
+    glXMakeCurrent(m_dpy, None, NULL);
+
+  if (m_invisibleCursor)
+  {
+    XUndefineCursor(m_dpy, m_glWindow);
+    XFreeCursor(m_dpy, m_invisibleCursor);
+    m_invisibleCursor = 0;
+  }
+
+  CWinEventsX11Imp::Quit();
+
+  XUnmapWindow(m_dpy, m_glWindow);
+  XSync(m_dpy,TRUE);
+  XUngrabKeyboard(m_dpy, CurrentTime);
+  XUngrabPointer(m_dpy, CurrentTime);
+  XDestroyWindow(m_dpy, m_glWindow);
+  m_glWindow = 0;
+
   return true;
 }
 
@@ -164,67 +146,105 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
+  if (!SetWindow(newWidth, newHeight, false))
+  {
+    return false;
+  }
+
+  RefreshGlxContext();
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
+  m_bFullScreen = false;
 
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
+  return false;
+}
 
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
+void CWinSystemX11::RefreshWindow()
+{
+  g_xrandr.Query(true);
+  XOutput out  = g_xrandr.GetCurrentOutput();
+  XMode   mode = g_xrandr.GetCurrentMode(out.name);
+
+  // only overwrite desktop resolution, if we are not in fullscreen mode
+  if (!g_graphicsContext.IsFullScreenVideo())
   {
-    SetGrabMode();
-    RefreshGlxContext();
-    return true;
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
+    UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, mode.w, mode.h, mode.hz);
+    g_settings.m_ResInfo[RES_DESKTOP].strId     = mode.id;
+    g_settings.m_ResInfo[RES_DESKTOP].strOutput = out.name;
   }
 
-  return false;
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < g_settings.m_ResInfo.size(); ++i)
+  {
+    if (g_settings.m_ResInfo[i].strId == mode.id)
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    return;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
 }
 
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  m_nWidth      = res.iWidth;
-  m_nHeight     = res.iHeight;
-  m_bFullScreen = fullScreen;
 
 #if defined(HAS_XRANDR)
   XOutput out;
   XMode mode;
-  out.name = res.strOutput;
-  mode.w   = res.iWidth;
-  mode.h   = res.iHeight;
-  mode.hz  = res.fRefreshRate;
-  mode.id  = res.strId;
+
+  if (fullScreen)
+  {
+    out.name = res.strOutput;
+    mode.w   = res.iWidth;
+    mode.h   = res.iHeight;
+    mode.hz  = res.fRefreshRate;
+    mode.id  = res.strId;
+  }
+  else
+  {
+    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
+    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+  }
  
-  if(m_bFullScreen)
+  XOutput currout  = g_xrandr.GetCurrentOutput();
+  XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
+
+  // only call xrandr if mode changes
+  if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
+      currmode.hz != mode.hz || currmode.id != mode.id)
   {
+    CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
     OnLostDevice();
     g_xrandr.SetMode(out, mode);
   }
-  else
-    g_xrandr.RestoreState();
 #endif
 
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
-
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
-  {
-    if ((m_SDLSurface->flags & SDL_OPENGL) != SDL_OPENGL)
-      CLog::Log(LOGERROR, "CWinSystemX11::SetFullScreen SDL_OPENGL not set, SDL_GetError:%s", SDL_GetError());
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen))
+    return false;
 
-    SetGrabMode();
-    RefreshGlxContext();
+  RefreshGlxContext();
 
-    return true;
-  }
+  m_nWidth      = res.iWidth;
+  m_nHeight     = res.iHeight;
+  m_bFullScreen = fullScreen;
 
-  return false;
+  return true;
 }
 
 void CWinSystemX11::UpdateResolutions()
@@ -326,17 +346,10 @@ bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
 bool CWinSystemX11::RefreshGlxContext()
 {
   bool retVal = false;
-  SDL_SysWMinfo info;
-  SDL_VERSION(&info.version);
-  if (SDL_GetWMInfo(&info) <= 0)
-  {
-    CLog::Log(LOGERROR, "Failed to get window manager info from SDL");
-    return false;
-  }
 
-  if(m_glWindow == info.info.x11.window && m_glContext)
+  if (m_glContext)
   {
-    CLog::Log(LOGERROR, "GLX: Same window as before, refreshing context");
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
     return true;
@@ -348,8 +361,6 @@ bool CWinSystemX11::RefreshGlxContext()
   int availableVisuals    = 0;
   vMask.screen = DefaultScreen(m_dpy);
   XWindowAttributes winAttr;
-  m_glWindow = info.info.x11.window;
-  m_wmWindow = info.info.x11.wmwindow;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
      or XGetVisualInfo() fail. That shouldn't happen unless something is
@@ -420,7 +431,10 @@ bool CWinSystemX11::RefreshGlxContext()
 
 void CWinSystemX11::ShowOSMouse(bool show)
 {
-  SDL_ShowCursor(show ? 1 : 0);
+  if (show)
+    XUndefineCursor(m_dpy,m_glWindow);
+  else if (m_invisibleCursor)
+    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -434,8 +448,6 @@ void CWinSystemX11::ResetOSScreensaver()
     {
       m_screensaverReset.StartZero();
       XResetScreenSaver(m_dpy);
-      //need to flush the output buffer, since we don't check for events on m_dpy
-      XFlush(m_dpy);
     }
   }
   else
@@ -451,13 +463,27 @@ void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 
   m_minimized = !bActivated;
 }
+
+void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
+{
+  if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
+      !g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.ToggleFullScreenRoot();
+  if (!bGaining)
+    m_bIgnoreNextFocusMessage = false;
+}
+
 bool CWinSystemX11::Minimize()
 {
   m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
   if (m_bWasFullScreenBeforeMinimize)
+  {
+    m_bIgnoreNextFocusMessage = true;
     g_graphicsContext.ToggleFullScreenRoot();
+  }
+
+  XIconifyWindow(m_dpy, m_glWindow, DefaultScreen(m_dpy));
 
-  SDL_WM_IconifyWindow();
   m_minimized = true;
   return true;
 }
@@ -467,13 +493,13 @@ bool CWinSystemX11::Restore()
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_wmWindow);
+  XUnmapWindow(m_dpy, m_glWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_wmWindow);
+  XMapWindow(m_dpy, m_glWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -505,6 +531,7 @@ void CWinSystemX11::CheckDisplayEvents()
   if (bGotEvent || bTimeout)
   {
     CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+    RefreshWindow();
 
     CSingleLock lock(m_resourceSection);
 
@@ -563,37 +590,151 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-void CWinSystemX11::SetGrabMode(const CSetting *setting /*= NULL*/)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
 {
-  bool enabled;
-  if (setting)
-    enabled = ((CSettingBool*)setting)->GetValue();
-  else
-    enabled = CSettings::Get().GetBool("input.enablesystemkeys");
-    
-  if (m_SDLSurface && m_SDLSurface->flags & SDL_FULLSCREEN)
+  bool changeWindow = false;
+  bool changeSize = false;
+  bool mouseActive = false;
+  float mouseX, mouseY;
+
+  if (m_glWindow && (m_bFullScreen != fullscreen))
   {
-    if (enabled)
+    mouseActive = g_Mouse.IsActive();
+    if (mouseActive)
     {
-      //SDL will always call XGrabPointer and XGrabKeyboard when in fullscreen
-      //so temporarily zero the SDL_FULLSCREEN flag, then turn off SDL grab mode
-      //this will make SDL call XUnGrabPointer and XUnGrabKeyboard
-      m_SDLSurface->flags &= ~SDL_FULLSCREEN;
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
-      m_SDLSurface->flags |= SDL_FULLSCREEN;
+      Window root_return, child_return;
+      int root_x_return, root_y_return;
+      int win_x_return, win_y_return;
+      unsigned int mask_return;
+      bool isInWin = XQueryPointer(m_dpy, m_glWindow, &root_return, &child_return,
+                                   &root_x_return, &root_y_return,
+                                   &win_x_return, &win_y_return,
+                                   &mask_return);
+      if (isInWin)
+      {
+        mouseX = (float)win_x_return/m_nWidth;
+        mouseY = (float)win_y_return/m_nHeight;
+        g_Mouse.SetActive(false);
+      }
+      else
+        mouseActive = false;
     }
-    else
+    DestroyWindow();
+  }
+
+  // create main window
+  if (!m_glWindow)
+  {
+    GLint att[] =
     {
-      //turn off key grabbing, which will actually make SDL turn it on when in fullscreen
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
-    }
+      GLX_RGBA,
+      GLX_RED_SIZE, 8,
+      GLX_GREEN_SIZE, 8,
+      GLX_BLUE_SIZE, 8,
+      GLX_ALPHA_SIZE, 8,
+      GLX_DEPTH_SIZE, 24,
+      GLX_DOUBLEBUFFER,
+      None
+    };
+    Colormap cmap;
+    XSetWindowAttributes swa;
+    XVisualInfo *vi;
+
+    vi = glXChooseVisual(m_dpy, DefaultScreen(m_dpy), att);
+    cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
+
+    int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
+    swa.override_redirect = fullscreen ? True : False;
+    swa.border_pixel = fullscreen ? 0 : 5;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.colormap = cmap;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
+                     ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
+                     PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
+                     EnterWindowMask | LeaveWindowMask | ExposureMask;
+    unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
+
+    m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    // define invisible cursor
+    Pixmap bitmapNoData;
+    XColor black;
+    static char noData[] = { 0,0,0,0,0,0,0,0 };
+    black.red = black.green = black.blue = 0;
+
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_glWindow, noData, 8, 8);
+    m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
+                                            &black, &black, 0, 0);
+    XFreePixmap(m_dpy, bitmapNoData);
+    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+
+    //init X11 events
+    CWinEventsX11Imp::Init(m_dpy, m_glWindow);
+
+    changeWindow = true;
+    changeSize = true;
   }
-}
 
-void CWinSystemX11::OnSettingChanged(const CSetting *setting)
-{
-  if (setting->GetId() == "input.enablesystemkeys")
-    SetGrabMode(setting);
+  if (!CWinEventsX11Imp::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
+  {
+    changeSize = true;
+  }
+
+  if (changeSize || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_glWindow, width, height);
+  }
+
+  if (changeWindow)
+  {
+    if (!fullscreen)
+    {
+      XWMHints wm_hints;
+      XClassHint class_hints;
+      XTextProperty windowName, iconName;
+      std::string titleString = "XBMC Media Center";
+      char *title = (char*)titleString.c_str();
+
+      XStringListToTextProperty(&title, 1, &windowName);
+      XStringListToTextProperty(&title, 1, &iconName);
+      wm_hints.initial_state = NormalState;
+      wm_hints.input = True;
+      wm_hints.icon_pixmap = None;
+      wm_hints.flags = StateHint | IconPixmapHint | InputHint;
+
+      XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
+                            NULL, 0, NULL, &wm_hints,
+                            NULL);
+
+      // register interest in the delete window message
+      Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
+      XSetWMProtocols(m_dpy, m_glWindow, &wmDeleteMessage, 1);
+    }
+    XMapRaised(m_dpy, m_glWindow);
+    XSync(m_dpy,TRUE);
+
+    if (changeWindow && mouseActive)
+    {
+      XWarpPointer(m_dpy, None, m_glWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+    }
+
+    if (fullscreen)
+    {
+      int result = -1;
+      while (result != GrabSuccess)
+      {
+        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, m_glWindow, None, CurrentTime);
+        XbmcThreads::ThreadSleep(100);
+      }
+      XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+
+    }
+  }
+  return true;
 }
 
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 2454fb1..f5e5731 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -54,6 +54,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   virtual bool EnableFrameLimiter();
 
   virtual void NotifyAppActiveChange(bool bActivated);
+  virtual void NotifyAppFocusChange(bool bGaining);
 
   virtual bool Minimize();
   virtual bool Restore() ;
@@ -66,20 +67,21 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  virtual void OnSettingChanged(const CSetting *setting);
+  void RefreshWindow();
 
 protected:
   bool RefreshGlxContext();
   void CheckDisplayEvents();
   void OnLostDevice();
+  bool SetWindow(int width, int height, bool fullscreen);
 
-  SDL_Surface* m_SDLSurface;
+  Window       m_glWindow;
   GLXContext   m_glContext;
-  GLXWindow    m_glWindow;
-  Window       m_wmWindow;
   Display*     m_dpy;
+  Cursor       m_invisibleCursor;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
+  bool         m_bIgnoreNextFocusMessage;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-- 
1.8.4


From eaede54d5093cc43266763d09b72df7868cf1270 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:24:22 +0200
Subject: [PATCH 28/94] X11: Add xbmc icon

---
 xbmc/windowing/X11/WinSystemX11.cpp | 126 +++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |   3 +-
 2 files changed, 127 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index a32f487..11ed79b 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -137,6 +137,9 @@ bool CWinSystemX11::DestroyWindow()
   XDestroyWindow(m_dpy, m_glWindow);
   m_glWindow = 0;
 
+  if (m_icon)
+    XFreePixmap(m_dpy, m_icon);
+
   return true;
 }
 
@@ -691,8 +694,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
 
   if (changeWindow)
   {
+    m_icon = None;
     if (!fullscreen)
     {
+      CreateIconPixmap();
       XWMHints wm_hints;
       XClassHint class_hints;
       XTextProperty windowName, iconName;
@@ -703,7 +708,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
       XStringListToTextProperty(&title, 1, &iconName);
       wm_hints.initial_state = NormalState;
       wm_hints.input = True;
-      wm_hints.icon_pixmap = None;
+      wm_hints.icon_pixmap = m_icon;
       wm_hints.flags = StateHint | IconPixmapHint | InputHint;
 
       XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
@@ -737,4 +742,123 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
   return true;
 }
 
+bool CWinSystemX11::CreateIconPixmap()
+{
+  int depth;
+  XImage *img = NULL;
+  Visual *vis;
+  XWindowAttributes wndattribs;
+  XVisualInfo visInfo;
+  double rRatio;
+  double gRatio;
+  double bRatio;
+  int outIndex = 0;
+  int i,j;
+  int numBufBytes;
+  unsigned char *buf;
+  uint32_t *newBuf = 0;
+  size_t numNewBufBytes;
+
+  // Get visual Info
+  XGetWindowAttributes(m_dpy, m_glWindow, &wndattribs);
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_dpy, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  depth = visInfo.depth;
+  vis = visInfo.visual;
+
+  if (depth < 15)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - no suitable depth");
+    return false;
+  }
+
+  rRatio = vis->red_mask / 255.0;
+  gRatio = vis->green_mask / 255.0;
+  bRatio = vis->blue_mask / 255.0;
+
+  CTexture iconTexture;
+  iconTexture.LoadFromFile("special://xbmc/media/icon.png");
+  buf = iconTexture.GetPixels();
+
+  numBufBytes = iconTexture.GetWidth() * iconTexture.GetHeight() * 4;
+
+  if (depth>=24)
+    numNewBufBytes = (4 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+  else
+    numNewBufBytes = (2 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+
+  newBuf = (uint32_t*)malloc(numNewBufBytes);
+  if (!newBuf)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - malloc failed");
+    return false;
+  }
+
+  for (i=0; i<iconTexture.GetHeight();++i)
+  {
+    for (j=0; j<iconTexture.GetWidth();++j)
+    {
+      unsigned int pos = i*iconTexture.GetPitch()+j*4;
+      unsigned int r, g, b;
+      r = (buf[pos+2] * rRatio);
+      g = (buf[pos+1] * gRatio);
+      b = (buf[pos+0] * bRatio);
+      r &= vis->red_mask;
+      g &= vis->green_mask;
+      b &= vis->blue_mask;
+      newBuf[outIndex] = r | g | b;
+      ++outIndex;
+    }
+  }
+  img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
+                     iconTexture.GetWidth(), iconTexture.GetHeight(),
+                     (depth>=24)?32:16, 0);
+  if (!img)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not create image");
+    free(newBuf);
+    return false;
+  }
+  if (!XInitImage(img))
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - init image failed");
+    XDestroyImage(img);
+    return false;
+  }
+
+  // set byte order
+  union
+  {
+    char c[sizeof(short)];
+    short s;
+  } order;
+  order.s = 1;
+  if ((1 == order.c[0]))
+  {
+    img->byte_order = LSBFirst;
+  }
+  else
+  {
+    img->byte_order = MSBFirst;
+  }
+
+  // create icon pixmap from image
+  m_icon = XCreatePixmap(m_dpy, m_glWindow, img->width, img->height, depth);
+  GC gc = XCreateGC(m_dpy, m_glWindow, 0, NULL);
+  XPutImage(m_dpy, m_icon, gc, img, 0, 0, 0, 0, img->width, img->height);
+  XFreeGC(m_dpy, gc);
+  XDestroyImage(img); // this also frees newBuf
+
+  return true;
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index f5e5731..6953b68 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -79,6 +79,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
+  Pixmap       m_icon;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
@@ -90,7 +91,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
-  void SetGrabMode(const CSetting *setting = NULL);
+  bool CreateIconPixmap();
 
   CStopWatch m_screensaverReset;
 };
-- 
1.8.4


From 40f1403ac91fc653ef3f43def170dbe1201fa235 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 20 May 2012 14:11:26 +0200
Subject: [PATCH 29/94] X11: add SDL joystick until we have a better solution

---
 xbmc/windowing/WinEventsX11.cpp | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index ad58aad..6f57a87 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -35,6 +35,10 @@
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
+#ifdef HAS_SDL_JOYSTICK
+#include "input/SDLJoystick.h"
+#endif
+
 CWinEventsX11Imp* CWinEventsX11Imp::WinEvents = 0;
 
 static uint32_t SymMappingsX11[][2] =
@@ -556,6 +560,28 @@ bool CWinEventsX11Imp::MessagePump()
 
   ret |= ProcessKeyRepeat();
 
+#ifdef HAS_SDL_JOYSTICK
+  SDL_Event event;
+  while (SDL_PollEvent(&event))
+  {
+    switch(event.type)
+    {
+      case SDL_JOYBUTTONUP:
+      case SDL_JOYBUTTONDOWN:
+      case SDL_JOYAXISMOTION:
+      case SDL_JOYBALLMOTION:
+      case SDL_JOYHATMOTION:
+        g_Joystick.Update(event);
+        ret = true;
+        break;
+
+      default:
+        break;
+    }
+    memset(&event, 0, sizeof(SDL_Event));
+  }
+#endif
+
   return ret;
 }
 
-- 
1.8.4


From 49d468cfd60c593b2e317665798454f24eebf381 Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 12:35:55 +0200
Subject: [PATCH 30/94] X11: factor out code handling device reset notification

---
 xbmc/windowing/X11/WinSystemX11.cpp | 22 ++++++++++++++--------
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 11ed79b..b3be9fc 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -533,14 +533,7 @@ void CWinSystemX11::CheckDisplayEvents()
 
   if (bGotEvent || bTimeout)
   {
-    CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-    RefreshWindow();
-
-    CSingleLock lock(m_resourceSection);
-
-    // tell any shared resources
-    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-      (*i)->OnResetDevice();
+    NotifyXRREvent();
 
     // reset fail safe timer
     m_dpyLostTime = 0;
@@ -548,6 +541,19 @@ void CWinSystemX11::CheckDisplayEvents()
 #endif
 }
 
+void CWinSystemX11::NotifyXRREvent()
+{
+  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  RefreshWindow();
+
+  CSingleLock lock(m_resourceSection);
+
+  // tell any shared resources
+  for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+    (*i)->OnResetDevice();
+
+}
+
 void CWinSystemX11::OnLostDevice()
 {
   CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 6953b68..d60d04a 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -68,6 +68,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
   void RefreshWindow();
+  void NotifyXRREvent();
 
 protected:
   bool RefreshGlxContext();
-- 
1.8.4


From b4026e4e3a8ebcc9991aa3875d5245520d52c3af Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:02:00 +0200
Subject: [PATCH 31/94] X11: move xrandr events to WinEventsX11

---
 xbmc/windowing/WinEventsX11.cpp     | 42 +++++++++++++++++++++++++++++++++++++
 xbmc/windowing/WinEventsX11.h       |  5 +++++
 xbmc/windowing/X11/WinSystemX11.cpp |  6 +++++-
 3 files changed, 52 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 6f57a87..d77cb2a 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -35,6 +35,10 @@
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
+#if defined(HAS_XRANDR)
+#include <X11/extensions/Xrandr.h>
+#endif
+
 #ifdef HAS_SDL_JOYSTICK
 #include "input/SDLJoystick.h"
 #endif
@@ -212,6 +216,7 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
+  WinEvents->m_xrrEventPending = false;
   memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
 
   // open input method
@@ -275,6 +280,13 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
     WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
   }
 
+  // register for xrandr events
+#if defined(HAS_XRANDR)
+  int iReturn;
+  XRRQueryExtension(WinEvents->m_display, &WinEvents->m_RREventBase, &iReturn);
+  XRRSelectInput(WinEvents->m_display, WinEvents->m_window, RRScreenChangeNotifyMask);
+#endif
+
   return true;
 }
 
@@ -297,6 +309,15 @@ bool CWinEventsX11Imp::HasStructureChanged()
   return ret;
 }
 
+void CWinEventsX11Imp::SetXRRFailSafeTimer(int millis)
+{
+  if (!WinEvents)
+    return;
+
+  WinEvents->m_xrrFailSafeTimer.Set(millis);
+  WinEvents->m_xrrEventPending = true;
+}
+
 bool CWinEventsX11Imp::MessagePump()
 {
   if (!WinEvents)
@@ -556,10 +577,31 @@ bool CWinEventsX11Imp::MessagePump()
         break;
       }
     }// switch event.type
+
+#if defined(HAS_XRANDR)
+    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
+    {
+      XRRUpdateConfiguration(&xevent);
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+    }
+#endif
+
   }// while
 
   ret |= ProcessKeyRepeat();
 
+#if defined(HAS_XRANDR)
+  if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
+  {
+    CLog::Log(LOGERROR,"CWinEventsX11::MessagePump - missed XRR Events");
+    g_Windowing.NotifyXRREvent();
+    WinEvents->m_xrrEventPending = false;
+  }
+#endif
+
 #ifdef HAS_SDL_JOYSTICK
   SDL_Event event;
   while (SDL_PollEvent(&event))
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index ce57c23..a412f32 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -40,6 +40,8 @@ class CWinEventsX11Imp
   static bool Init(Display *dpy, Window win);
   static void Quit();
   static bool HasStructureChanged();
+  static void PendingResize(int width, int height);
+  static void SetXRRFailSafeTimer(int millis);
   static bool MessagePump();
   static size_t GetQueueSize();
 
@@ -62,4 +64,7 @@ class CWinEventsX11Imp
   std::map<uint32_t,uint32_t> m_symLookupTable;
   int m_keymodState;
   bool m_structureChanged;
+  int m_RREventBase;
+  XbmcThreads::EndTime m_xrrFailSafeTimer;
+  bool m_xrrEventPending;
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index b3be9fc..7259674 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -510,7 +510,7 @@ bool CWinSystemX11::Show(bool raise)
 
 void CWinSystemX11::CheckDisplayEvents()
 {
-#if defined(HAS_XRANDR)
+#if defined(HAS_XRANDR) && defined(HAS_SDL_VIDEO_X11)
   bool bGotEvent(false);
   bool bTimeout(false);
   XEvent Event;
@@ -566,8 +566,12 @@ void CWinSystemX11::OnLostDevice()
       (*i)->OnLostDevice();
   }
 
+#if defined(HAS_SDL_VIDEO_X11)
   // fail safe timer
   m_dpyLostTime = CurrentHostCounter();
+#else
+  CWinEventsX11Imp::SetXRRFailSafeTimer(3000);
+#endif
 }
 
 void CWinSystemX11::Register(IDispResource *resource)
-- 
1.8.4


From 85c659d33c307c26e6890637f3aca60769c04ca5 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 12 Apr 2012 15:43:56 +0200
Subject: [PATCH 32/94] xrandr: remove method RestoreState

---
 xbmc/windowing/X11/WinSystemX11.cpp | 13 +++++++++++--
 xbmc/windowing/X11/XRandR.cpp       | 19 -------------------
 xbmc/windowing/X11/XRandR.h         |  1 -
 3 files changed, 11 insertions(+), 22 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 7259674..dccc44f 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -80,9 +80,18 @@ bool CWinSystemX11::InitWindowSystem()
 bool CWinSystemX11::DestroyWindowSystem()
 {
 #if defined(HAS_XRANDR)
-  //restore videomode on exit
+  //restore desktop resolution on exit
   if (m_bFullScreen)
-    g_xrandr.RestoreState();
+  {
+    XOutput out;
+    XMode mode;
+    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
+    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    g_xrandr.SetMode(out, mode);
+  }
 #endif
 
   if (m_dpy)
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index bd22dbf..df2b5fb 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -139,25 +139,6 @@ void CXRandR::SaveState()
   Query(true);
 }
 
-void CXRandR::RestoreState()
-{
-  vector<XOutput>::iterator outiter;
-  for (outiter=m_current.begin() ; outiter!=m_current.end() ; outiter++)
-  {
-    vector<XMode> modes = (*outiter).modes;
-    vector<XMode>::iterator modeiter;
-    for (modeiter=modes.begin() ; modeiter!=modes.end() ; modeiter++)
-    {
-      XMode mode = *modeiter;
-      if (mode.isCurrent)
-      {
-        SetMode(*outiter, mode);
-        return;
-      }
-    }
-  }
-}
-
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
   if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 0aec487..00b49dc 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -99,7 +99,6 @@ class CXRandR
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
-  void RestoreState();
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
-- 
1.8.4


From 422aa20387ad099a2e4cbcef2b1fa9868a3dcaec Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 20 May 2012 13:17:10 +0200
Subject: [PATCH 33/94] xrandr: observe orientation

---
 xbmc/windowing/X11/WinSystemX11.cpp | 89 ++++++++++++++++++++++++++++++-------
 xbmc/windowing/X11/WinSystemX11.h   |  2 +
 xbmc/windowing/X11/XRandR.cpp       |  7 +++
 xbmc/windowing/X11/XRandR.h         |  1 +
 4 files changed, 82 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index dccc44f..a046401 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -85,11 +85,11 @@ bool CWinSystemX11::DestroyWindowSystem()
   {
     XOutput out;
     XMode mode;
-    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
-    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
     g_xrandr.SetMode(out, mode);
   }
 #endif
@@ -173,25 +173,34 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
 
 void CWinSystemX11::RefreshWindow()
 {
-  g_xrandr.Query(true);
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
   XOutput out  = g_xrandr.GetCurrentOutput();
   XMode   mode = g_xrandr.GetCurrentMode(out.name);
 
+  RotateResolutions();
+
   // only overwrite desktop resolution, if we are not in fullscreen mode
   if (!g_graphicsContext.IsFullScreenVideo())
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
-    UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, mode.w, mode.h, mode.hz);
-    g_settings.m_ResInfo[RES_DESKTOP].strId     = mode.id;
-    g_settings.m_ResInfo[RES_DESKTOP].strOutput = out.name;
+    if (!out.isRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
   }
 
   RESOLUTION_INFO res;
   unsigned int i;
   bool found(false);
-  for (i = RES_DESKTOP; i < g_settings.m_ResInfo.size(); ++i)
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
   {
-    if (g_settings.m_ResInfo[i].strId == mode.id)
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
     {
       found = true;
       break;
@@ -227,16 +236,24 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
   else
   {
-    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
-    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
   }
  
   XOutput currout  = g_xrandr.GetCurrentOutput();
   XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
 
+  // flip h/w when rotated
+  if (m_bIsRotated)
+  {
+    int w = mode.w;
+    mode.w = mode.h;
+    mode.h = w;
+  }
+
   // only call xrandr if mode changes
   if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
       currmode.hz != mode.hz || currmode.id != mode.id)
@@ -269,7 +286,11 @@ void CWinSystemX11::UpdateResolutions()
   {
     XOutput out  = g_xrandr.GetCurrentOutput();
     XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    m_bIsRotated = out.isRotated;
+    if (!m_bIsRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
   }
@@ -308,6 +329,16 @@ void CWinSystemX11::UpdateResolutions()
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
       res.iScreenHeight = mode.h;
+      if (!m_bIsRotated)
+      {
+        res.iWidth  = mode.w;
+        res.iHeight = mode.h;
+      }
+      else
+      {
+        res.iWidth  = mode.h;
+        res.iHeight = mode.w;
+      }
       if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
         res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
       else
@@ -335,6 +366,30 @@ void CWinSystemX11::UpdateResolutions()
 
 }
 
+void CWinSystemX11::RotateResolutions()
+{
+#if defined(HAS_XRANDR)
+  XOutput out  = g_xrandr.GetCurrentOutput();
+  if (out.isRotated == m_bIsRotated)
+    return;
+
+  for (unsigned int i = 0; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    int width = CDisplaySettings::Get().GetResolutionInfo(i).iWidth;
+    CDisplaySettings::Get().GetResolutionInfo(i).iWidth = CDisplaySettings::Get().GetResolutionInfo(i).iHeight;
+    CDisplaySettings::Get().GetResolutionInfo(i).iHeight = width;
+  }
+  // update desktop resolution
+//  int h = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+//  int w = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+//  float hz = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+//  UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, w, h, hz);
+
+  m_bIsRotated = out.isRotated;
+
+#endif
+}
+
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
 {
   int value;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index d60d04a..eb8005e 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -75,12 +75,14 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   void CheckDisplayEvents();
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen);
+  void RotateResolutions();
 
   Window       m_glWindow;
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
   Pixmap       m_icon;
+  bool         m_bIsRotated;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index df2b5fb..29715c7 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -98,6 +98,13 @@ bool CXRandR::Query(bool force)
     xoutput.y = (output->Attribute("y") != NULL ? atoi(output->Attribute("y")) : 0);
     xoutput.wmm = (output->Attribute("wmm") != NULL ? atoi(output->Attribute("wmm")) : 0);
     xoutput.hmm = (output->Attribute("hmm") != NULL ? atoi(output->Attribute("hmm")) : 0);
+    if (output->Attribute("rotation") != NULL
+        && (strcasecmp(output->Attribute("rotation"), "left") == 0 || strcasecmp(output->Attribute("rotation"), "right") == 0))
+    {
+      xoutput.isRotated = true;
+    }
+    else
+      xoutput.isRotated = false;
 
     if (!xoutput.isConnected)
        continue;
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 00b49dc..508604d 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -86,6 +86,7 @@ class XOutput
   int wmm;
   int hmm;
   std::vector<XMode> modes;
+  bool isRotated;
 };
 
 class CXRandR
-- 
1.8.4


From cfee1ab0c2fee606b9568e7b97774fdd57924c30 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:54:15 +0200
Subject: [PATCH 34/94] xrandr: allow getting info for multiple screen's

Refactored by: Joakim Plate <elupus@xbmc.org>
---
 xbmc/windowing/X11/XRandR.cpp | 65 +++++++++++++++++++++++++++++++++----------
 xbmc/windowing/X11/XRandR.h   |  8 ++++--
 2 files changed, 57 insertions(+), 16 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 29715c7..9e181f2 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -39,6 +39,7 @@
 CXRandR::CXRandR(bool query)
 {
   m_bInit = false;
+  m_numScreens = 1;
   if (query)
     Query();
 }
@@ -55,11 +56,21 @@ bool CXRandR::Query(bool force)
     return false;
 
   m_outputs.clear();
-  m_current.clear();
+  // query all screens
+  for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
+  {
+    if(!Query(force, screennum))
+      return false;
+  }
+  return true;
+}
 
+bool CXRandR::Query(bool force, int screennum)
+{
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
+  cmd.append("-q --screen %d", screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
@@ -79,7 +90,7 @@ bool CXRandR::Query(bool force)
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != 0)
+  if (strcasecmp(pRootElement->Value(), "screen") != screennum)
   {
     // TODO ERROR
     return false;
@@ -92,6 +103,7 @@ bool CXRandR::Query(bool force)
     xoutput.name.TrimLeft(" \n\r\t");
     xoutput.name.TrimRight(" \n\r\t");
     xoutput.isConnected = (strcasecmp(output->Attribute("connected"), "true") == 0);
+    xoutput.screen = screennum;
     xoutput.w = (output->Attribute("w") != NULL ? atoi(output->Attribute("w")) : 0);
     xoutput.h = (output->Attribute("h") != NULL ? atoi(output->Attribute("h")) : 0);
     xoutput.x = (output->Attribute("x") != NULL ? atoi(output->Attribute("x")) : 0);
@@ -123,7 +135,6 @@ bool CXRandR::Query(bool force)
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
       {
-        m_current.push_back(xoutput);
         hascurrent = true;
       }
     }
@@ -247,17 +258,6 @@ bool CXRandR::SetMode(XOutput output, XMode mode)
   return true;
 }
 
-XOutput CXRandR::GetCurrentOutput()
-{
-  Query();
-  for (unsigned int j = 0; j < m_outputs.size(); j++)
-  {
-    if(m_outputs[j].isConnected)
-      return m_outputs[j];
-  }
-  XOutput empty;
-  return empty;
-}
 XMode CXRandR::GetCurrentMode(CStdString outputName)
 {
   Query();
@@ -331,6 +331,43 @@ void CXRandR::LoadCustomModeLinesToAllOutputs(void)
   }
 }
 
+void CXRandR::SetNumScreens(unsigned int num)
+{
+  m_numScreens = num;
+  m_bInit = false;
+}
+
+bool CXRandR::IsOutputConnected(CStdString name)
+{
+  bool result = false;
+  Query();
+
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == name)
+    {
+      result = true;
+      break;
+    }
+  }
+  return result;
+}
+
+XOutput* CXRandR::GetOutput(CStdString outputName)
+{
+  XOutput *result = 0;
+  Query();
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == outputName)
+    {
+      result = &m_outputs[i];
+      break;
+    }
+  }
+  return result;
+}
+
 CXRandR g_xrandr;
 
 #endif // HAS_XRANDR
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 508604d..d37838a 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -79,6 +79,7 @@ class XOutput
     }
   CStdString name;
   bool isConnected;
+  int screen;
   int w;
   int h;
   int x;
@@ -94,12 +95,15 @@ class CXRandR
 public:
   CXRandR(bool query=false);
   bool Query(bool force=false);
+  bool Query(bool force, int screennum);
   std::vector<XOutput> GetModes(void);
-  XOutput GetCurrentOutput();
   XMode   GetCurrentMode(CStdString outputName);
+  XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
+  void SetNumScreens(unsigned int num);
+  bool IsOutputConnected(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
@@ -107,10 +111,10 @@ class CXRandR
 
 private:
   bool m_bInit;
-  std::vector<XOutput> m_current;
   std::vector<XOutput> m_outputs;
   CStdString m_currentOutput;
   CStdString m_currentMode;
+  unsigned int m_numScreens;
 };
 
 extern CXRandR g_xrandr;
-- 
1.8.4


From e5b1cb349535a98dd20aabd10a3fe402ecef4605 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:44:00 +0200
Subject: [PATCH 35/94] X11: fix multi-head setups

---
 language/English/strings.po         |   4 +-
 system/settings/settings.xml        |  11 ++
 xbmc/rendering/gl/RenderSystemGL.h  |   1 +
 xbmc/settings/DisplaySettings.cpp   |  44 +++++-
 xbmc/settings/DisplaySettings.h     |   2 +
 xbmc/settings/Settings.cpp          |   6 +
 xbmc/windowing/WinEventsX11.cpp     |   7 +
 xbmc/windowing/X11/WinSystemX11.cpp | 260 +++++++++++++++++++++---------------
 xbmc/windowing/X11/WinSystemX11.h   |  10 +-
 9 files changed, 229 insertions(+), 116 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 74a5e59..291932d 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -1019,7 +1019,9 @@ msgctxt "#245"
 msgid "Sizing: (%i,%i)->(%i,%i) (Zoom x%2.2f) AR:%2.2f:1 (Pixels: %2.2f:1) (VShift: %2.2f)"
 msgstr ""
 
-#empty string with id 246
+msgctxt "#246"
+msgid "Monitor"
+msgstr ""
 
 msgctxt "#247"
 msgid "Scripts"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index d25dd72..e1176d6 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1865,6 +1865,15 @@
   <section id="system" label="13000" help="36349">
     <category id="videoscreen" label="21373" help="36350">
       <group id="1">
+        <setting id="videoscreen.monitor" type="string" label="246" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>Default</default>
+          <constraints>
+            <options>monitors</options>
+          </constraints>
+          <control type="spinner" format="string" delayed="true" />
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -1886,6 +1895,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.screenmode" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="list" format="string" />
         </setting>
@@ -1903,6 +1913,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.resolution" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="spinner" format="string" delayed="true" />
         </setting>
diff --git a/xbmc/rendering/gl/RenderSystemGL.h b/xbmc/rendering/gl/RenderSystemGL.h
index 4bd540b..f1e2c50 100644
--- a/xbmc/rendering/gl/RenderSystemGL.h
+++ b/xbmc/rendering/gl/RenderSystemGL.h
@@ -44,6 +44,7 @@ class CRenderSystemGL : public CRenderSystemBase
   virtual bool IsExtSupported(const char* extension);
 
   virtual void SetVSync(bool vsync);
+  virtual void ResetVSync() { m_bVsyncInit = false; }
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index bf307f6..1a85651 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -219,13 +219,19 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
 
   const std::string &settingId = setting->GetId();
   if (settingId == "videoscreen.resolution" ||
-      settingId == "videoscreen.screen")
+      settingId == "videoscreen.screen" ||
+      settingId == "videoscreen.monitor")
   {
     RESOLUTION newRes = RES_DESKTOP;
     if (settingId == "videoscreen.resolution")
       newRes = (RESOLUTION)((CSettingInt*)setting)->GetValue();
     else if (settingId == "videoscreen.screen")
       newRes = GetResolutionForScreen();
+    else if (settingId == "videoscreen.monitor")
+    {
+      g_Windowing.UpdateResolutions();
+      newRes = GetResolutionForScreen();
+    }
 
     string screenmode = GetStringFromResolution(newRes);
     CSettings::Get().SetString("videoscreen.screenmode", screenmode);
@@ -236,7 +242,11 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
     RESOLUTION newRes = GetResolutionFromString(((CSettingString*)setting)->GetValue());
 
     SetCurrentResolution(newRes, false);
-    g_graphicsContext.SetVideoResolution(newRes);
+    bool outputChanged = false;
+#if defined(HAS_GLX)
+    outputChanged = !g_Windowing.IsCurrentOutput(CSettings::Get().GetString("videoscreen.monitor"));
+#endif
+    g_graphicsContext.SetVideoResolution(newRes, outputChanged);
 
     // check if the old or the new resolution was/is windowed
     // in which case we don't show any prompt to the user
@@ -622,6 +632,10 @@ void CDisplaySettings::SettingOptionsScreensFiller(const CSetting *setting, std:
   if (g_advancedSettings.m_canWindowed)
     list.push_back(make_pair(g_localizeStrings.Get(242), DM_WINDOWED));
 
+#if defined(HAS_GLX)
+  list.push_back(make_pair(g_localizeStrings.Get(244), 0));
+#else
+
   for (int idx = 0; idx < g_Windowing.GetNumScreens(); idx++)
   {
     int screen = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP + idx).iScreen;
@@ -636,6 +650,7 @@ void CDisplaySettings::SettingOptionsScreensFiller(const CSetting *setting, std:
     RESOLUTION_INFO resInfo = CDisplaySettings::Get().GetResolutionInfo(res);
     current = resInfo.iScreen;
   }
+#endif
 }
 
 void CDisplaySettings::SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
@@ -663,3 +678,28 @@ void CDisplaySettings::SettingOptionsPreferredStereoscopicViewModesFiller(const
   SettingOptionsStereoscopicModesFiller(setting, list, current);
   list.push_back(make_pair(g_localizeStrings.Get(36525), RENDER_STEREO_MODE_AUTO)); // option for autodetect
 }
+
+void CDisplaySettings::SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current)
+{
+#if defined(HAS_GLX)
+  std::vector<CStdString> monitors;
+  g_Windowing.GetConnectedOutputs(&monitors);
+  for (unsigned int i=0; i<monitors.size(); ++i)
+  {
+    if(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
+    {
+      current = monitors[i];
+    }
+    list.push_back(make_pair(monitors[i], monitors[i]));
+  }
+#endif
+}
+
+void CDisplaySettings::ClearCustomResolutions()
+{
+  if (m_resolutions.size() > RES_CUSTOM)
+  {
+    std::vector<RESOLUTION_INFO>::iterator firstCustom = m_resolutions.begin()+RES_CUSTOM;
+    m_resolutions.erase(firstCustom, m_resolutions.end());
+  }
+}
diff --git a/xbmc/settings/DisplaySettings.h b/xbmc/settings/DisplaySettings.h
index cc4002b..d80f1dc 100644
--- a/xbmc/settings/DisplaySettings.h
+++ b/xbmc/settings/DisplaySettings.h
@@ -78,6 +78,7 @@ class CDisplaySettings : public ISettingCallback, public ISubSettings,
 
   void ApplyCalibrations();
   void UpdateCalibrations();
+  void ClearCustomResolutions();
 
   float GetZoomAmount() const { return m_zoomAmount; }
   void SetZoomAmount(float zoomAmount) { m_zoomAmount = zoomAmount; }
@@ -95,6 +96,7 @@ class CDisplaySettings : public ISettingCallback, public ISubSettings,
   static void SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsStereoscopicModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsPreferredStereoscopicViewModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static void SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
 
 protected:
   CDisplaySettings();
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 72c8700..8096883 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -387,6 +387,7 @@ void CSettings::Uninitialize()
   m_settingsManager->UnregisterSettingOptionsFiller("screens");
   m_settingsManager->UnregisterSettingOptionsFiller("stereoscopicmodes");
   m_settingsManager->UnregisterSettingOptionsFiller("preferedstereoscopicviewmodes");
+  m_settingsManager->UnregisterSettingOptionsFiller("monitors");
   m_settingsManager->UnregisterSettingOptionsFiller("shutdownstates");
   m_settingsManager->UnregisterSettingOptionsFiller("startupwindows");
   m_settingsManager->UnregisterSettingOptionsFiller("streamlanguages");
@@ -701,6 +702,7 @@ void CSettings::InitializeOptionFillers()
   m_settingsManager->RegisterSettingOptionsFiller("screens", CDisplaySettings::SettingOptionsScreensFiller);
   m_settingsManager->RegisterSettingOptionsFiller("stereoscopicmodes", CDisplaySettings::SettingOptionsStereoscopicModesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("preferedstereoscopicviewmodes", CDisplaySettings::SettingOptionsPreferredStereoscopicViewModesFiller);
+  m_settingsManager->RegisterSettingOptionsFiller("monitors", CDisplaySettings::SettingOptionsMonitorsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("shutdownstates", CPowerManager::SettingOptionsShutdownStatesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("startupwindows", ADDON::CSkinInfo::SettingOptionsStartupWindowsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("streamlanguages", CLangInfo::SettingOptionsStreamLanguagesFiller);
@@ -731,6 +733,9 @@ void CSettings::InitializeConditions()
 #ifdef HAS_GL
   m_settingsManager->AddCondition("has_gl");
 #endif
+#ifdef HAS_GLX
+  m_settingsManager->AddCondition("has_glx");
+#endif
 #ifdef HAS_GLES
   m_settingsManager->AddCondition("has_gles");
 #endif
@@ -878,6 +883,7 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert("videoscreen.screen");
   settingSet.insert("videoscreen.resolution");
   settingSet.insert("videoscreen.screenmode");
+  settingSet.insert("videoscreen.monitor");
   m_settingsManager->RegisterCallback(&CDisplaySettings::Get(), settingSet);
 
   settingSet.clear();
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index d77cb2a..d98f12f 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -526,9 +526,16 @@ bool CWinEventsX11Imp::MessagePump()
         break;
       }
 
+      case EnterNotify:
+      {
+        g_Windowing.NotifyMouseCoverage(true);
+        break;
+      }
+
       // lose mouse coverage
       case LeaveNotify:
       {
+        g_Windowing.NotifyMouseCoverage(false);
         g_Mouse.SetActive(false);
         break;
       }
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index a046401..3966ad2 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -35,7 +35,8 @@
 #include "threads/SingleLock.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
-//#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "windowing/WindowingFactory.h"
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
@@ -57,6 +58,7 @@
   m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
   m_invisibleCursor = 0;
+  m_bIsInternalXrr = false;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -69,7 +71,8 @@ bool CWinSystemX11::InitWindowSystem()
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-    return CWinSystemBase::InitWindowSystem();
+    bool ret = CWinSystemBase::InitWindowSystem();
+    return ret;
   }
   else
     CLog::Log(LOGERROR, "GLX Error: No Display found");
@@ -106,6 +109,8 @@ bool CWinSystemX11::DestroyWindowSystem()
 
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
+    // i have seen core dumps on ATI if the display is not closed here
+    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
@@ -128,7 +133,10 @@ bool CWinSystemX11::DestroyWindow()
     return true;
 
   if (m_glContext)
+  {
+    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
+  }
 
   if (m_invisibleCursor)
   {
@@ -158,7 +166,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
-  if (!SetWindow(newWidth, newHeight, false))
+  if (!SetWindow(newWidth, newHeight, false, CSettings::Get().GetString("videoscreen.monitor")))
   {
     return false;
   }
@@ -167,58 +175,11 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
+  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
 
   return false;
 }
 
-void CWinSystemX11::RefreshWindow()
-{
-  if (!g_xrandr.Query(true))
-  {
-    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-    return;
-  }
-  XOutput out  = g_xrandr.GetCurrentOutput();
-  XMode   mode = g_xrandr.GetCurrentMode(out.name);
-
-  RotateResolutions();
-
-  // only overwrite desktop resolution, if we are not in fullscreen mode
-  if (!g_graphicsContext.IsFullScreenVideo())
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
-    if (!out.isRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
-    else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
-  }
-
-  RESOLUTION_INFO res;
-  unsigned int i;
-  bool found(false);
-  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
-  {
-    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
-    {
-      found = true;
-      break;
-    }
-  }
-
-  if (!found)
-  {
-    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
-    return;
-  }
-
-  if (g_graphicsContext.IsFullScreenRoot())
-    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
-  else
-    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
-}
-
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
 
@@ -243,8 +204,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
   }
  
-  XOutput currout  = g_xrandr.GetCurrentOutput();
-  XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
+  XMode   currmode = g_xrandr.GetCurrentMode(out.name);
 
   // flip h/w when rotated
   if (m_bIsRotated)
@@ -255,16 +215,17 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
 
   // only call xrandr if mode changes
-  if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
+  if (currmode.w != mode.w || currmode.h != mode.h ||
       currmode.hz != mode.hz || currmode.id != mode.id)
   {
     CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
     OnLostDevice();
+    m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
   }
 #endif
 
-  if (!SetWindow(res.iWidth, res.iHeight, fullScreen))
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
     return false;
 
   RefreshGlxContext();
@@ -272,6 +233,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
+  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
 
   return true;
 }
@@ -280,19 +242,30 @@ void CWinSystemX11::UpdateResolutions()
 {
   CWinSystemBase::UpdateResolutions();
 
-
 #if defined(HAS_XRANDR)
-  if(g_xrandr.Query())
-  {
-    XOutput out  = g_xrandr.GetCurrentOutput();
-    XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    m_bIsRotated = out.isRotated;
+  CStdString currentMonitor;
+  int numScreens = XScreenCount(m_dpy);
+  g_xrandr.SetNumScreens(numScreens);
+  if(g_xrandr.Query(true))
+  {
+    currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+    // check if the monitor is connected
+    XOutput *out = g_xrandr.GetOutput(currentMonitor);
+    if (!out)
+    {
+      // choose first output
+      currentMonitor = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(currentMonitor);
+      CSettings::Get().SetString("videoscreen.monitor", currentMonitor);
+    }
+    XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
+    m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.w, mode.h, mode.hz);
     else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
   }
   else
 #endif
@@ -303,23 +276,22 @@ void CWinSystemX11::UpdateResolutions()
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
-
 #if defined(HAS_XRANDR)
 
+  // erase previous stored modes
+  CDisplaySettings::Get().ClearCustomResolutions();
+
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
-  vector<XOutput>::iterator outiter;
-  vector<XOutput> outs;
-  outs = g_xrandr.GetModes();
-  CLog::Log(LOGINFO, "Number of connected outputs: %"PRIdS"", outs.size());
+
+  XOutput *out = g_xrandr.GetOutput(currentMonitor);
   string modename = "";
 
-  for (outiter = outs.begin() ; outiter != outs.end() ; outiter++)
+  if (out != NULL)
   {
-    XOutput out = *outiter;
     vector<XMode>::iterator modeiter;
-    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out.name.c_str(), out.modes.size());
+    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out->name.c_str(), out->modes.size());
 
-    for (modeiter = out.modes.begin() ; modeiter!=out.modes.end() ; modeiter++)
+    for (modeiter = out->modes.begin() ; modeiter!=out->modes.end() ; modeiter++)
     {
       XMode mode = *modeiter;
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
@@ -339,15 +311,15 @@ void CWinSystemX11::UpdateResolutions()
         res.iWidth  = mode.h;
         res.iHeight = mode.w;
       }
-      if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
-        res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
+      if (mode.h>0 && mode.w>0 && out->hmm>0 && out->wmm>0)
+        res.fPixelRatio = ((float)out->wmm/(float)mode.w) / (((float)out->hmm/(float)mode.h));
       else
         res.fPixelRatio = 1.0f;
 
       CLog::Log(LOGINFO, "Pixel Ratio: %f", res.fPixelRatio);
 
-      res.strMode.Format("%s: %s @ %.2fHz", out.name.c_str(), mode.name.c_str(), mode.hz);
-      res.strOutput    = out.name;
+      res.strMode.Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
+      res.strOutput    = out->name;
       res.strId        = mode.id;
       res.iSubtitles   = (int)(0.95*mode.h);
       res.fRefreshRate = mode.hz;
@@ -366,28 +338,19 @@ void CWinSystemX11::UpdateResolutions()
 
 }
 
-void CWinSystemX11::RotateResolutions()
+void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 {
-#if defined(HAS_XRANDR)
-  XOutput out  = g_xrandr.GetCurrentOutput();
-  if (out.isRotated == m_bIsRotated)
-    return;
-
-  for (unsigned int i = 0; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  vector<XOutput> outs;
+  outs = g_xrandr.GetModes();
+  for(unsigned int i=0; i<outs.size(); ++i)
   {
-    int width = CDisplaySettings::Get().GetResolutionInfo(i).iWidth;
-    CDisplaySettings::Get().GetResolutionInfo(i).iWidth = CDisplaySettings::Get().GetResolutionInfo(i).iHeight;
-    CDisplaySettings::Get().GetResolutionInfo(i).iHeight = width;
+    outputs->push_back(outs[i].name);
   }
-  // update desktop resolution
-//  int h = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-//  int w = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-//  float hz = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-//  UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, w, h, hz);
-
-  m_bIsRotated = out.isRotated;
+}
 
-#endif
+bool CWinSystemX11::IsCurrentOutput(CStdString output)
+{
+  return m_currentOutput.Equals(output);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
@@ -417,8 +380,11 @@ bool CWinSystemX11::RefreshGlxContext()
   if (m_glContext)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
+    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
+    XSync(m_dpy, FALSE);
+    g_Windowing.ResetVSync();
     return true;
   }
 
@@ -484,6 +450,8 @@ bool CWinSystemX11::RefreshGlxContext()
     {
       // make this context current
       glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
+      g_Windowing.ResetVSync();
+      XSync(m_dpy, False);
       retVal = true;
     }
     else
@@ -525,24 +493,53 @@ void CWinSystemX11::ResetOSScreensaver()
 
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
-  if (bActivated && m_bWasFullScreenBeforeMinimize && !g_graphicsContext.IsFullScreenRoot())
+  if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
+  {
     g_graphicsContext.ToggleFullScreenRoot();
 
+    m_bWasFullScreenBeforeMinimize = false;
+  }
   m_minimized = !bActivated;
 }
 
 void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
 {
   if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
-      !g_graphicsContext.IsFullScreenRoot())
+      !m_bFullScreen)
+  {
+    m_bWasFullScreenBeforeMinimize = false;
     g_graphicsContext.ToggleFullScreenRoot();
+    m_minimized = false;
+  }
   if (!bGaining)
     m_bIgnoreNextFocusMessage = false;
 }
 
+void CWinSystemX11::NotifyMouseCoverage(bool covered)
+{
+  if (!m_bFullScreen)
+    return;
+
+  if (covered)
+  {
+    int result = -1;
+    while (result != GrabSuccess && result != AlreadyGrabbed)
+    {
+      result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+      XbmcThreads::ThreadSleep(100);
+    }
+    XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+  }
+  else
+  {
+    XUngrabKeyboard(m_dpy, CurrentTime);
+    XUngrabPointer(m_dpy, CurrentTime);
+  }
+}
+
 bool CWinSystemX11::Minimize()
 {
-  m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
+  m_bWasFullScreenBeforeMinimize = m_bFullScreen;
   if (m_bWasFullScreenBeforeMinimize)
   {
     m_bIgnoreNextFocusMessage = true;
@@ -608,13 +605,46 @@ void CWinSystemX11::CheckDisplayEvents()
 void CWinSystemX11::NotifyXRREvent()
 {
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-  RefreshWindow();
+  m_windowDirty = true;
 
-  CSingleLock lock(m_resourceSection);
+  // if external event update resolutions
+  if (!m_bIsInternalXrr)
+  {
+    UpdateResolutions();
+  }
+  else if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+  m_bIsInternalXrr = false;
 
-  // tell any shared resources
-  for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-    (*i)->OnResetDevice();
+  CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  XOutput *out = g_xrandr.GetOutput(currentOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
+
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    i = RES_DESKTOP;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
 
 }
 
@@ -667,14 +697,14 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStdString &output)
 {
   bool changeWindow = false;
   bool changeSize = false;
   bool mouseActive = false;
   float mouseX, mouseY;
 
-  if (m_glWindow && (m_bFullScreen != fullscreen))
+  if (m_glWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
   {
     mouseActive = g_Mouse.IsActive();
     if (mouseActive)
@@ -696,6 +726,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
       else
         mouseActive = false;
     }
+    OnLostDevice();
     DestroyWindow();
   }
 
@@ -717,7 +748,11 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     XSetWindowAttributes swa;
     XVisualInfo *vi;
 
-    vi = glXChooseVisual(m_dpy, DefaultScreen(m_dpy), att);
+    XOutput *out = g_xrandr.GetOutput(output);
+    if (!out)
+      out = g_xrandr.GetOutput(m_currentOutput);
+    m_nScreen = out->screen;
+    vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
@@ -733,7 +768,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
     m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
-                    0, 0, width, height, 0, vi->depth,
+                    out->x, out->y, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
@@ -804,14 +839,19 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     if (fullscreen)
     {
       int result = -1;
-      while (result != GrabSuccess)
+      while (result != GrabSuccess && result != AlreadyGrabbed)
       {
-        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, m_glWindow, None, CurrentTime);
+        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
         XbmcThreads::ThreadSleep(100);
       }
       XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
-
     }
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnResetDevice();
+
+    m_windowDirty = false;
   }
   return true;
 }
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index eb8005e..7d53d36 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -67,15 +67,16 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  void RefreshWindow();
   void NotifyXRREvent();
+  void GetConnectedOutputs(std::vector<CStdString> *outputs);
+  bool IsCurrentOutput(CStdString output);
+  void NotifyMouseCoverage(bool covered);
 
 protected:
   bool RefreshGlxContext();
   void CheckDisplayEvents();
   void OnLostDevice();
-  bool SetWindow(int width, int height, bool fullscreen);
-  void RotateResolutions();
+  bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
 
   Window       m_glWindow;
   GLXContext   m_glContext;
@@ -90,6 +91,9 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
+  CStdString                   m_currentOutput;
+  bool                         m_windowDirty;
+  bool                         m_bIsInternalXrr;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
-- 
1.8.4


From 306a07f2e491d21e5b56a537e778dd45583ec08b Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:36:32 +0200
Subject: [PATCH 36/94] X11: remove all DefaultScreen and RootWindow macros

---
 xbmc/windowing/X11/WinSystemX11.cpp   | 6 +++---
 xbmc/windowing/X11/WinSystemX11.h     | 1 +
 xbmc/windowing/X11/WinSystemX11GL.cpp | 2 +-
 3 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 3966ad2..462a805 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -270,7 +270,7 @@ void CWinSystemX11::UpdateResolutions()
   else
 #endif
   {
-    int x11screen = DefaultScreen(m_dpy);
+    int x11screen = m_nScreen;
     int w = DisplayWidth(m_dpy, x11screen);
     int h = DisplayHeight(m_dpy, x11screen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
@@ -392,7 +392,7 @@ bool CWinSystemX11::RefreshGlxContext()
   XVisualInfo *visuals;
   XVisualInfo *vInfo      = NULL;
   int availableVisuals    = 0;
-  vMask.screen = DefaultScreen(m_dpy);
+  vMask.screen = m_nScreen;
   XWindowAttributes winAttr;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
@@ -546,7 +546,7 @@ bool CWinSystemX11::Minimize()
     g_graphicsContext.ToggleFullScreenRoot();
   }
 
-  XIconifyWindow(m_dpy, m_glWindow, DefaultScreen(m_dpy));
+  XIconifyWindow(m_dpy, m_glWindow, m_nScreen);
 
   m_minimized = true;
   return true;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 7d53d36..51e33c2 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -49,6 +49,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
   virtual void UpdateResolutions();
   virtual int  GetNumScreens() { return 1; }
+  virtual int  GetCurrentScreen() { return m_nScreen; }
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
index 81c6800..8a8ff83 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GL.cpp
@@ -204,7 +204,7 @@ bool CWinSystemX11GL::CreateNewWindow(const CStdString& name, bool fullScreen, R
     return false;
 
   m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, DefaultScreen(m_dpy));
+  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
   m_glxext += " ";
 
   CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
-- 
1.8.4


From 59938103c2fb554f1ac6f8fd84ea5a32e212b3ee Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:45:22 +0200
Subject: [PATCH 37/94] X11: remove all DefaultScreen and RootWindow macros
 (VideoRefClock)

Note this is on a separate display connection.
---
 xbmc/video/VideoReferenceClock.cpp | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 3ba991a..7eecd40 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -271,7 +271,7 @@ bool CVideoReferenceClock::SetupGLX()
   }
 
   bool          ExtensionFound = false;
-  istringstream Extensions(glXQueryExtensionsString(m_Dpy, DefaultScreen(m_Dpy)));
+  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
   string        ExtensionStr;
 
   while (!ExtensionFound)
@@ -298,7 +298,7 @@ bool CVideoReferenceClock::SetupGLX()
     m_bIsATI = true;
   }
 
-  m_vInfo = glXChooseVisual(m_Dpy, DefaultScreen(m_Dpy), singleBufferAttributes);
+  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
   if (!m_vInfo)
   {
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
@@ -309,15 +309,16 @@ bool CVideoReferenceClock::SetupGLX()
   {
     Swa.border_pixel = 0;
     Swa.event_mask = StructureNotifyMask;
-    Swa.colormap = XCreateColormap(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), m_vInfo->visual, AllocNone );
+    Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
     SwaMask = CWBorderPixel | CWColormap | CWEventMask;
 
-    m_Window = XCreateWindow(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), 0, 0, 256, 256, 0,
+    m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
                            m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
   }
   else
   {
-    m_pixmap = XCreatePixmap(m_Dpy, DefaultRootWindow(m_Dpy), 256, 256, m_vInfo->depth);
+    Window window = g_Windowing.GetWindow();
+    m_pixmap = XCreatePixmap(m_Dpy, window, 256, 256, m_vInfo->depth);
     if (!m_pixmap)
     {
       CLog::Log(LOGDEBUG, "CVideoReferenceClock: unable to create pixmap");
@@ -384,7 +385,7 @@ bool CVideoReferenceClock::SetupGLX()
 
   //set up receiving of RandR events, we'll get one when the refreshrate changes
   XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), RRScreenChangeNotifyMask);
+  XRRSelectInput(m_Dpy, g_Windowing.GetWindow(), RRScreenChangeNotifyMask);
 
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
@@ -519,7 +520,7 @@ int CVideoReferenceClock::GetRandRRate()
   int RefreshRate;
   XRRScreenConfiguration *CurrInfo;
 
-  CurrInfo = XRRGetScreenInfo(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen));
+  CurrInfo = XRRGetScreenInfo(m_Dpy, g_Windowing.GetWindow());
   RefreshRate = XRRConfigCurrentRate(CurrInfo);
   XRRFreeScreenConfigInfo(CurrInfo);
 
-- 
1.8.4


From 93767fb106373fdf0fac8e443ab42adbfdf9fa4b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 20 Jun 2012 17:37:11 +0200
Subject: [PATCH 38/94] X11: recreate gl context after output has changed

---
 xbmc/windowing/X11/WinSystemX11.cpp   | 24 ++++++++++++++----------
 xbmc/windowing/X11/WinSystemX11.h     |  1 +
 xbmc/windowing/X11/WinSystemX11GL.cpp |  9 +++++++++
 3 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 462a805..4588b28 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -171,7 +171,6 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
     return false;
   }
 
-  RefreshGlxContext();
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
@@ -222,14 +221,13 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     OnLostDevice();
     m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
+    return true;
   }
 #endif
 
   if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
     return false;
 
-  RefreshGlxContext();
-
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
@@ -380,11 +378,8 @@ bool CWinSystemX11::RefreshGlxContext()
   if (m_glContext)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-    XSync(m_dpy, FALSE);
-    g_Windowing.ResetVSync();
     return true;
   }
 
@@ -444,14 +439,14 @@ bool CWinSystemX11::RefreshGlxContext()
     {
       glXMakeCurrent(m_dpy, None, NULL);
       glXDestroyContext(m_dpy, m_glContext);
+      XSync(m_dpy, FALSE);
+      m_newGlContext = true;
     }
 
     if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
     {
       // make this context current
       glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-      g_Windowing.ResetVSync();
-      XSync(m_dpy, False);
       retVal = true;
     }
     else
@@ -728,6 +723,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     }
     OnLostDevice();
     DestroyWindow();
+    m_windowDirty = true;
   }
 
   // create main window
@@ -846,13 +842,21 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       }
       XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
     }
+
+    CDirtyRegionList dr;
+    RefreshGlxContext();
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    g_Windowing.ResetVSync();
+    m_windowDirty = false;
+
     CSingleLock lock(m_resourceSection);
     // tell any shared resources
     for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
       (*i)->OnResetDevice();
-
-    m_windowDirty = false;
   }
+
   return true;
 }
 
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 51e33c2..2868707 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -95,6 +95,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   CStdString                   m_currentOutput;
   bool                         m_windowDirty;
   bool                         m_bIsInternalXrr;
+  bool                         m_newGlContext;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
index 8a8ff83..8707467 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GL.cpp
@@ -24,6 +24,7 @@
 #include "WinSystemX11GL.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
+#include "Application.h"
 
 CWinSystemX11GL::CWinSystemX11GL()
 {
@@ -246,17 +247,25 @@ bool CWinSystemX11GL::CreateNewWindow(const CStdString& name, bool fullScreen, R
 
 bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_newGlContext = false;
   CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
   CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
 bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
+  m_newGlContext = false;
   CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
   CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
-- 
1.8.4


From 56b93b9ce67f8deaba618d2dc158a269ac1b232a Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:06:25 +0200
Subject: [PATCH 39/94] X11: hook video reference clock in windowing

---
 xbmc/video/VideoReferenceClock.cpp | 71 +++++++++++++++++++++++++++-----------
 xbmc/video/VideoReferenceClock.h   | 13 ++++++-
 2 files changed, 63 insertions(+), 21 deletions(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 7eecd40..4071ff0 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -136,12 +136,23 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_RREventBase = 0;
   m_UseNvSettings = true;
   m_bIsATI = false;
 #endif
 }
 
+CVideoReferenceClock::~CVideoReferenceClock()
+{
+#if defined(HAS_GLX)
+  // some ATI voodoo, if we don't close the display, we crash on exit
+  if (m_Dpy)
+  {
+    XCloseDisplay(m_Dpy);
+    m_Dpy = NULL;
+  }
+#endif
+}
+
 void CVideoReferenceClock::Process()
 {
   bool SetupSuccess = false;
@@ -152,6 +163,10 @@ void CVideoReferenceClock::Process()
   m_D3dCallback.Reset();
   g_Windowing.Register(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+  g_Windowing.Register(this);
+  m_xrrEvent = false;
+#endif
 
   while(!m_bStop)
   {
@@ -212,6 +227,16 @@ void CVideoReferenceClock::Process()
     //clean up the vblank clock
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
     CleanupGLX();
+    if (m_xrrEvent)
+    {
+      m_releaseEvent.Set();
+      while (!m_bStop)
+      {
+        if (m_resetEvent.WaitMSec(100))
+          break;
+      }
+      m_xrrEvent = false;
+    }
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
     CleanupD3D();
 #elif defined(TARGET_DARWIN)
@@ -223,6 +248,9 @@ void CVideoReferenceClock::Process()
 #if defined(TARGET_WINDOWS) && defined(HAS_DX)
   g_Windowing.Unregister(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX)
+  g_Windowing.Unregister(this);
+#endif
 }
 
 bool CVideoReferenceClock::WaitStarted(int MSecs)
@@ -232,6 +260,24 @@ bool CVideoReferenceClock::WaitStarted(int MSecs)
 }
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
+
+void CVideoReferenceClock::OnLostDevice()
+{
+  if (!m_xrrEvent)
+  {
+    m_releaseEvent.Reset();
+    m_resetEvent.Reset();
+    m_xrrEvent = true;
+    m_releaseEvent.Wait();
+  }
+}
+
+void CVideoReferenceClock::OnResetDevice()
+{
+  m_xrrEvent = false;
+  m_resetEvent.Set();
+}
+
 bool CVideoReferenceClock::SetupGLX()
 {
   int singleBufferAttributes[] = {
@@ -383,10 +429,6 @@ bool CVideoReferenceClock::SetupGLX()
     return false;
   }
 
-  //set up receiving of RandR events, we'll get one when the refreshrate changes
-  XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, g_Windowing.GetWindow(), RRScreenChangeNotifyMask);
-
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
 
@@ -587,6 +629,9 @@ void CVideoReferenceClock::RunGLX()
 
   while(!m_bStop)
   {
+    if (m_xrrEvent)
+      return;
+
     //wait for the next vblank
     if (!m_bIsATI)
     {
@@ -650,7 +695,6 @@ void CVideoReferenceClock::RunGLX()
       UpdateClock((int)(VblankCount - PrevVblankCount), true);
       SingleLock.Leave();
       SendVblankSignal();
-      UpdateRefreshrate();
       IsReset = false;
     }
     else if (!m_bStop)
@@ -1187,23 +1231,10 @@ bool CVideoReferenceClock::UpdateRefreshrate(bool Forced /*= false*/)
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
 
-  //check for RandR events
-  bool   GotEvent = Forced || m_RefreshChanged == 2;
-  XEvent Event;
-  while (XCheckTypedEvent(m_Dpy, m_RREventBase + RRScreenChangeNotify, &Event))
-  {
-    if (Event.type == m_RREventBase + RRScreenChangeNotify)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Received RandR event %i", Event.type);
-      GotEvent = true;
-    }
-    XRRUpdateConfiguration(&Event);
-  }
-
   if (!Forced)
     m_RefreshChanged = 0;
 
-  if (!GotEvent) //refreshrate did not change
+  if (!Forced) //refreshrate did not change
     return false;
 
   //the refreshrate can be wrong on nvidia drivers, so read it from nvidia-settings when it's available
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index dd65a1b..afd71fc 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -30,6 +30,7 @@
   #include <X11/X.h>
   #include <X11/Xlib.h>
   #include <GL/glx.h>
+  #include "guilib/DispResource.h"
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
   #include <d3d9.h>
   #include "guilib/D3DResource.h"
@@ -56,9 +57,13 @@ class CD3DCallback : public ID3DResource
 #endif
 
 class CVideoReferenceClock : public CThread
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+                            ,public IDispResource
+#endif
 {
   public:
     CVideoReferenceClock();
+    virtual ~CVideoReferenceClock();
 
     int64_t GetTime(bool interpolated = true);
     int64_t GetFrequency();
@@ -75,6 +80,11 @@ class CVideoReferenceClock : public CThread
     void VblankHandler(int64_t nowtime, double fps);
 #endif
 
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+    virtual void OnLostDevice();
+    virtual void OnResetDevice();
+#endif
+
   private:
     void    Process();
     bool    UpdateRefreshrate(bool Forced = false);
@@ -121,7 +131,8 @@ class CVideoReferenceClock : public CThread
     GLXContext   m_Context;
     Pixmap       m_pixmap;
     GLXPixmap    m_glPixmap;
-    int          m_RREventBase;
+    bool         m_xrrEvent;
+    CEvent       m_releaseEvent, m_resetEvent;
 
     bool         m_UseNvSettings;
     bool         m_bIsATI;
-- 
1.8.4


From deedcea046c209e32e3215feceaa26066b462019 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 21 Jun 2012 17:26:51 +0200
Subject: [PATCH 40/94] X11: fix video calibrations

---
 xbmc/windowing/WinSystem.h          |  1 +
 xbmc/windowing/X11/WinSystemX11.cpp | 36 +++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 3 files changed, 37 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index 00a2d24..c0db210 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -103,6 +103,7 @@ class CWinSystemBase
   std::vector<RESOLUTION_WHR> ScreenResolutions(int screen, float refreshrate);
   std::vector<REFRESHRATE> RefreshRates(int screen, int width, int height, uint32_t dwFlags);
   REFRESHRATE DefaultRefreshRate(int screen, std::vector<REFRESHRATE> rates);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo) { return true; };
 
   // text input interface
   virtual void EnableTextInput(bool bEnable) {}
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 4588b28..72aae78 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -319,7 +319,7 @@ void CWinSystemX11::UpdateResolutions()
       res.strMode.Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
       res.strOutput    = out->name;
       res.strId        = mode.id;
-      res.iSubtitles   = (int)(0.95*mode.h);
+      res.iSubtitles   = (int)(0.965*mode.h);
       res.fRefreshRate = mode.hz;
       res.bFullScreen  = true;
 
@@ -332,8 +332,42 @@ void CWinSystemX11::UpdateResolutions()
       CDisplaySettings::Get().AddResolutionInfo(res);
     }
   }
+  CDisplaySettings::Get().ApplyCalibrations();
 #endif
+}
+
+bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
+{
+  XOutput *out = g_xrandr.GetOutput(m_currentOutput);
+
+  // keep calibrations done on a not connected output
+  if (!out->name.Equals(resInfo.strOutput))
+    return true;
+
+  // keep calibrations not updated with resolution data
+  if (resInfo.iWidth == 0)
+    return true;
+
+  float fPixRatio;
+  if (resInfo.iHeight>0 && resInfo.iWidth>0 && out->hmm>0 && out->wmm>0)
+    fPixRatio = ((float)out->wmm/(float)resInfo.iWidth) / (((float)out->hmm/(float)resInfo.iHeight));
+  else
+    fPixRatio = 1.0f;
 
+  if (resInfo.Overscan.left != 0)
+    return true;
+  if (resInfo.Overscan.top != 0)
+    return true;
+  if (resInfo.Overscan.right != resInfo.iWidth)
+    return true;
+  if (resInfo.Overscan.bottom != resInfo.iHeight)
+    return true;
+  if (resInfo.fPixelRatio != fPixRatio)
+    return true;
+  if (resInfo.iSubtitles != (int)(0.965*resInfo.iHeight))
+    return true;
+
+  return false;
 }
 
 void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 2868707..282bb9a 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -63,6 +63,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   virtual bool Show(bool raise = true);
   virtual void Register(IDispResource *resource);
   virtual void Unregister(IDispResource *resource);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo);
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
-- 
1.8.4


From 764545b5d53396fc58b1af676e890ec63e02b699 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:00:26 +0200
Subject: [PATCH 41/94] X11: deactivate screen saver on startup

---
 xbmc/windowing/X11/WinSystemX11.cpp | 29 +++++++++++++++++++++++++++++
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 30 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 72aae78..e1fd4e5 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -520,6 +520,33 @@ void CWinSystemX11::ResetOSScreensaver()
   }
 }
 
+void CWinSystemX11::EnableSystemScreenSaver(bool bEnable)
+{
+  if (!m_dpy)
+    return;
+
+  if (bEnable)
+    XForceScreenSaver(m_dpy, ScreenSaverActive);
+  else
+  {
+    Window root_return, child_return;
+    int root_x_return, root_y_return;
+    int win_x_return, win_y_return;
+    unsigned int mask_return;
+    bool isInWin = XQueryPointer(m_dpy, RootWindow(m_dpy, m_nScreen), &root_return, &child_return,
+                                 &root_x_return, &root_y_return,
+                                 &win_x_return, &win_y_return,
+                                 &mask_return);
+
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return+300, root_y_return+300);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, 0, 0);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return, root_y_return);
+    XSync(m_dpy, FALSE);
+  }
+}
+
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
   if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
@@ -763,6 +790,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   // create main window
   if (!m_glWindow)
   {
+    EnableSystemScreenSaver(false);
+
     GLint att[] =
     {
       GLX_RGBA,
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 282bb9a..32f90da 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -53,6 +53,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
+  virtual void EnableSystemScreenSaver(bool bEnable);
 
   virtual void NotifyAppActiveChange(bool bActivated);
   virtual void NotifyAppFocusChange(bool bGaining);
-- 
1.8.4


From 0eaed044f37af68bed8715ba7c381d113314baca Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:10:09 +0200
Subject: [PATCH 42/94] X11: change method of going full-screen

---
 xbmc/windowing/X11/WinSystemX11.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e1fd4e5..acd6497 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -37,6 +37,7 @@
 #include "utils/TimeUtils.h"
 #include "settings/Settings.h"
 #include "windowing/WindowingFactory.h"
+#include <X11/Xatom.h>
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
@@ -815,7 +816,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
-    swa.override_redirect = fullscreen ? True : False;
+    swa.override_redirect = False;
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
@@ -831,6 +832,12 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
                     InputOutput, vi->visual,
                     mask, &swa);
 
+    if (fullscreen)
+    {
+      Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
+      XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+    }
+
     // define invisible cursor
     Pixmap bitmapNoData;
     XColor black;
-- 
1.8.4


From bf244e2092fbdc36b9d1fa37f48fff042f2bd8cb Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Jun 2012 19:12:39 +0200
Subject: [PATCH 43/94] X11: reset key repeat and key modifier on focus lost
 and gain

---
 xbmc/windowing/WinEventsX11.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index d98f12f..743aca9 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -368,6 +368,8 @@ bool CWinEventsX11Imp::MessagePump()
         if (WinEvents->m_xic)
           XSetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = true;
+        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
+        WinEvents->m_keymodState = 0;
         if (serial == xevent.xfocus.serial)
           break;
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
@@ -379,6 +381,7 @@ bool CWinEventsX11Imp::MessagePump()
         if (WinEvents->m_xic)
           XUnsetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = false;
+        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
         serial = xevent.xfocus.serial;
         break;
-- 
1.8.4


From 2b59df8b190005cbdf4040525561309ebc92e466 Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 14:18:46 +0200
Subject: [PATCH 44/94] X11: replace custom utf8 to unicode with charset
 convertor (squash to x11 events)

---
 xbmc/windowing/WinEventsX11.cpp | 119 ++++------------------------------------
 xbmc/windowing/WinEventsX11.h   |   2 -
 2 files changed, 11 insertions(+), 110 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 743aca9..6b98e67 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -32,6 +32,7 @@
 #include "X11/keysymdef.h"
 #include "X11/XF86keysym.h"
 #include "utils/log.h"
+#include "utils/CharsetConverter.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
@@ -170,7 +171,6 @@ size_t CWinEventsX11::GetQueueSize()
   m_display = 0;
   m_window = 0;
   m_keybuf = 0;
-  m_utf16buf = 0;
 }
 
 CWinEventsX11Imp::~CWinEventsX11Imp()
@@ -181,12 +181,6 @@ size_t CWinEventsX11::GetQueueSize()
     m_keybuf = 0;
   }
 
-  if (m_utf16buf)
-  {
-    free(m_utf16buf);
-    m_utf16buf = 0;
-  }
-
   if (m_xic)
   {
     XUnsetICFocus(m_xic);
@@ -212,7 +206,6 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents->m_display = dpy;
   WinEvents->m_window = win;
   WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
-  WinEvents->m_utf16buf = (uint16_t*)malloc(32*sizeof(uint16_t));
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
@@ -442,8 +435,6 @@ bool CWinEventsX11Imp::MessagePump()
         }
 
         Status status;
-        int utf16size;
-        int utf16length;
         int len;
         len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
                                 WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
@@ -462,36 +453,29 @@ bool CWinEventsX11Imp::MessagePump()
           case XLookupChars:
           case XLookupBoth:
           {
-            if (len == 0)
-              break;
-            utf16size = len * sizeof(uint16_t);
-            if (utf16size > sizeof(WinEvents->m_utf16buf))
-            {
-              WinEvents->m_utf16buf = (uint16_t *)realloc(WinEvents->m_utf16buf,utf16size);
-              if (WinEvents->m_utf16buf == NULL)
-              {
-                break;
-              }
-            }
-            utf16length = Utf8ToUnicode(WinEvents->m_keybuf, len, WinEvents->m_utf16buf, utf16size);
-            if (utf16length < 0)
+            CStdString   data(WinEvents->m_keybuf, len);
+            CStdStringW keys;
+            g_charsetConverter.utf8ToW(data, keys, false);
+
+            if (keys.length() == 0)
             {
               break;
             }
-            for (unsigned int i = 0; i < utf16length - 1; i++)
+
+            for (unsigned int i = 0; i < keys.length() - 1; i++)
             {
               newEvent.key.keysym.sym = XBMCK_UNKNOWN;
-              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[i];
+              newEvent.key.keysym.unicode = keys[i];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
               ret |= ProcessKey(newEvent, 500);
             }
-            if (utf16length > 0)
+            if (keys.length() > 0)
             {
               newEvent.key.keysym.scancode = xevent.xkey.keycode;
               xkeysym = XLookupKeysym(&xevent.xkey, 0);
               newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
-              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[utf16length - 1];
+              newEvent.key.keysym.unicode = keys[keys.length() - 1];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
 
@@ -762,87 +746,6 @@ bool CWinEventsX11Imp::ProcessKeyRepeat()
   return false;
 }
 
-int CWinEventsX11Imp::Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength)
-{
-  // p moves over the output buffer.  max_ptr points to the next to the last slot of the buffer.
-  uint16_t *p = utf16;
-  uint16_t const *const maxPtr = utf16 + utf16MaxLength;
-
-  // end_of_input points to the last byte of input as opposed to the next to the last byte.
-  char const *const endOfInput = utf8 + utf8Length - 1;
-
-  while (utf8 <= endOfInput)
-  {
-    unsigned char const c = *utf8;
-    if (p >= maxPtr)
-    {
-      //No more output space.
-      return -1;
-    }
-    if (c < 0x80)
-    {
-      //One byte ASCII.
-      *p++ = c;
-      utf8 += 1;
-    }
-    else if (c < 0xC0)
-    {
-      // Follower byte without preceding leader bytes.
-      return -1;
-    }
-    // 11 bits
-    else if (c < 0xE0)
-    {
-      // Two byte sequence.  We need one follower byte.
-      if (endOfInput - utf8 < 1 || (((utf8[1] ^ 0x80)) & 0xC0))
-      {
-        return -1;
-      }
-      *p++ = (uint16_t)(((c & 0x1F) << 6) + (utf8[1] & 0x3F));
-      utf8 += 2;
-    }
-    // 16 bis
-    else if (c < 0xF0)
-    {
-      // Three byte sequence.  We need two follower byte.
-      if (endOfInput - utf8 < 2 || ((utf8[1] ^ 0x80) & 0xC0) || ((utf8[2] ^ 0x80) & 0xC0))
-      {
-        return -1;
-      }
-      *p++ = (uint16_t)(((c & 0xF) << 12) + ((utf8[1] & 0x3F) << 6) + (utf8[2] & 0x3F));
-      utf8 += 3;
-    }
-    // 21 bits
-    else if (c < 0xF8)
-    {
-      int plane;
-      // Four byte sequence.  We need three follower bytes.
-      if (endOfInput - utf8 < 3 || ((utf8[1] ^ 0x80) & 0xC0) ||
-          ((utf8[2] ^ 0x80) & 0xC0) || ((utf8[3] ^ 0x80) & 0xC0))
-      {
-        return -1;
-      }
-      uint32_t unicode = ((c & 0x7) << 18) + ((utf8[1] & 0x3F) << 12) +
-                          ((utf8[2] & 0x3F) << 6) + (utf8[3] & 0x3F);
-      utf8 += 4;
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-    }
-    // 26 bits
-    else if (c < 0xFC)
-    {
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-      utf8 += 5;
-    }
-    // 31 bit
-    else
-    {
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-      utf8 += 6;
-    }
-  }
-  return p - utf16;
-}
-
 XBMCKey CWinEventsX11Imp::LookupXbmcKeySym(KeySym keysym)
 {
   // try direct mapping first
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index a412f32..9a8a912 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -46,7 +46,6 @@ class CWinEventsX11Imp
   static size_t GetQueueSize();
 
 protected:
-  static int Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength);
   static XBMCKey LookupXbmcKeySym(KeySym keysym);
   static bool ProcessKey(XBMC_Event &event, int repeatDelay);
   static bool ProcessKeyRepeat();
@@ -56,7 +55,6 @@ class CWinEventsX11Imp
   Window m_window;
   Atom m_wmDeleteMessage;
   char *m_keybuf;
-  uint16_t *m_utf16buf;
   XIM m_xim;
   XIC m_xic;
   XBMC_Event m_lastKey;
-- 
1.8.4


From c03a11cf30f3a6698f68d430b0b0febe376be32b Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 14:23:54 +0200
Subject: [PATCH 45/94] X11: fixed invalid usage of sizeof() (squash into x11
 changes)

---
 xbmc/windowing/WinEventsX11.cpp | 11 +++++++----
 xbmc/windowing/WinEventsX11.h   |  1 +
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 6b98e67..a62521f 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -171,6 +171,7 @@ size_t CWinEventsX11::GetQueueSize()
   m_display = 0;
   m_window = 0;
   m_keybuf = 0;
+  m_keybuf_len = 0;
 }
 
 CWinEventsX11Imp::~CWinEventsX11Imp()
@@ -205,7 +206,8 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents = new CWinEventsX11Imp();
   WinEvents->m_display = dpy;
   WinEvents->m_window = win;
-  WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
+  WinEvents->m_keybuf_len = 32*sizeof(char);
+  WinEvents->m_keybuf = (char*)malloc(WinEvents->m_keybuf_len);
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
@@ -437,13 +439,14 @@ bool CWinEventsX11Imp::MessagePump()
         Status status;
         int len;
         len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
-                                WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                WinEvents->m_keybuf, WinEvents->m_keybuf_len,
                                 &xkeysym, &status);
         if (status == XBufferOverflow)
         {
-          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, len*sizeof(char));
+          WinEvents->m_keybuf_len = len;
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, WinEvents->m_keybuf_len);
           len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
-                                  WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                  WinEvents->m_keybuf, WinEvents->m_keybuf_len,
                                   &xkeysym, &status);
         }
         switch (status)
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 9a8a912..c69169c 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -55,6 +55,7 @@ class CWinEventsX11Imp
   Window m_window;
   Atom m_wmDeleteMessage;
   char *m_keybuf;
+  size_t m_keybuf_len;
   XIM m_xim;
   XIC m_xic;
   XBMC_Event m_lastKey;
-- 
1.8.4


From 9e221e90b1d0ed4e0e81727155680dea2b94780e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 9 Jun 2012 18:23:53 +0200
Subject: [PATCH 46/94] add missing keys to xbmc keytable

---
 xbmc/input/XBMC_keytable.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/input/XBMC_keytable.cpp b/xbmc/input/XBMC_keytable.cpp
index b430f55..246164b 100644
--- a/xbmc/input/XBMC_keytable.cpp
+++ b/xbmc/input/XBMC_keytable.cpp
@@ -179,6 +179,8 @@
 , { XBMCK_LAUNCH_APP2,            0,    0, XBMCVK_LAUNCH_APP2,         "launch_app2_pc_icon" }
 , { XBMCK_LAUNCH_FILE_BROWSER,    0,    0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser" }
 , { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
+, { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
+, { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
 
 // Function keys
 , { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
-- 
1.8.4


From 7237cbdd1c2b4ac29da8be37e81b6cb7adc2e916 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 16 Mar 2012 15:57:51 +0100
Subject: [PATCH 47/94] videorefclock: temp deactivate of nv settings

---
 xbmc/video/VideoReferenceClock.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 4071ff0..b9afc09 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -136,7 +136,7 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_UseNvSettings = true;
+  m_UseNvSettings = false;
   m_bIsATI = false;
 #endif
 }
-- 
1.8.4


From 798c8163713518df02dcec2f4787fd14493603bf Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 09:09:09 +0200
Subject: [PATCH 48/94] videorefclock: ask graphics context for refresh rate

---
 xbmc/video/VideoReferenceClock.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index b9afc09..2f6c7de 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -31,6 +31,7 @@
   #include <sstream>
   #include <X11/extensions/Xrandr.h>
   #include "windowing/WindowingFactory.h"
+  #include "guilib/GraphicContext.h"
   #define NVSETTINGSCMD "nvidia-settings -nt -q RefreshRate3"
 #elif defined(TARGET_DARWIN_OSX)
   #include <QuartzCore/CVDisplayLink.h>
@@ -1255,7 +1256,7 @@ bool CVideoReferenceClock::UpdateRefreshrate(bool Forced /*= false*/)
   }
 
   CSingleLock SingleLock(m_CritSection);
-  m_RefreshRate = GetRandRRate();
+  m_RefreshRate = MathUtils::round_int(g_graphicsContext.GetFPS());
 
   CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %i hertz", (int)m_RefreshRate);
 
-- 
1.8.4


From 40336d30b29ec112c2c61d38b5fa995a0d46c3f0 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 9 Jul 2012 14:00:18 +0200
Subject: [PATCH 49/94] X11: fix icon texture after
 cc5ed3c2474084ebc0373a3046410e6f766e03f4

---
 xbmc/windowing/X11/WinSystemX11.cpp | 43 ++++++++++++++++++++++---------------
 1 file changed, 26 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index acd6497..805eed7 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -873,22 +873,24 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     if (!fullscreen)
     {
       CreateIconPixmap();
-      XWMHints wm_hints;
-      XClassHint class_hints;
+      XWMHints *wm_hints;
       XTextProperty windowName, iconName;
       std::string titleString = "XBMC Media Center";
       char *title = (char*)titleString.c_str();
 
       XStringListToTextProperty(&title, 1, &windowName);
       XStringListToTextProperty(&title, 1, &iconName);
-      wm_hints.initial_state = NormalState;
-      wm_hints.input = True;
-      wm_hints.icon_pixmap = m_icon;
-      wm_hints.flags = StateHint | IconPixmapHint | InputHint;
 
+      wm_hints = XAllocWMHints();
+      wm_hints->initial_state = NormalState;
+      wm_hints->icon_pixmap = m_icon;
+      wm_hints->flags = StateHint | IconPixmapHint;
+
+      XSync(m_dpy,False);
       XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
-                            NULL, 0, NULL, &wm_hints,
+                            NULL, 0, NULL, wm_hints,
                             NULL);
+      XFree(wm_hints);
 
       // register interest in the delete window message
       Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
@@ -973,16 +975,21 @@ bool CWinSystemX11::CreateIconPixmap()
   gRatio = vis->green_mask / 255.0;
   bRatio = vis->blue_mask / 255.0;
 
-  CTexture iconTexture;
-  iconTexture.LoadFromFile("special://xbmc/media/icon.png");
-  buf = iconTexture.GetPixels();
+  CBaseTexture *iconTexture = CBaseTexture::LoadFromFile("special://xbmc/media/icon.png");
+
+  if (!iconTexture)
+    return false;
 
-  numBufBytes = iconTexture.GetWidth() * iconTexture.GetHeight() * 4;
+  buf = iconTexture->GetPixels();
+
+  numBufBytes = iconTexture->GetWidth() * iconTexture->GetHeight() * 4;
+  int wid = iconTexture->GetWidth();
+  int hi = iconTexture->GetHeight();
 
   if (depth>=24)
-    numNewBufBytes = (4 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+    numNewBufBytes = (4 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
   else
-    numNewBufBytes = (2 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+    numNewBufBytes = (2 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
 
   newBuf = (uint32_t*)malloc(numNewBufBytes);
   if (!newBuf)
@@ -991,11 +998,11 @@ bool CWinSystemX11::CreateIconPixmap()
     return false;
   }
 
-  for (i=0; i<iconTexture.GetHeight();++i)
+  for (i=0; i<iconTexture->GetHeight();++i)
   {
-    for (j=0; j<iconTexture.GetWidth();++j)
+    for (j=0; j<iconTexture->GetWidth();++j)
     {
-      unsigned int pos = i*iconTexture.GetPitch()+j*4;
+      unsigned int pos = i*iconTexture->GetPitch()+j*4;
       unsigned int r, g, b;
       r = (buf[pos+2] * rRatio);
       g = (buf[pos+1] * gRatio);
@@ -1008,7 +1015,7 @@ bool CWinSystemX11::CreateIconPixmap()
     }
   }
   img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
-                     iconTexture.GetWidth(), iconTexture.GetHeight(),
+                     iconTexture->GetWidth(), iconTexture->GetHeight(),
                      (depth>=24)?32:16, 0);
   if (!img)
   {
@@ -1046,6 +1053,8 @@ bool CWinSystemX11::CreateIconPixmap()
   XFreeGC(m_dpy, gc);
   XDestroyImage(img); // this also frees newBuf
 
+  delete iconTexture;
+
   return true;
 }
 
-- 
1.8.4


From a295172248fb2d3806d4c4c58a414558a52080df Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 10 Jul 2012 11:14:12 +0200
Subject: [PATCH 50/94] X11: check for window manager

---
 xbmc/windowing/X11/WinSystemX11.cpp | 74 ++++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 73 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 805eed7..b103248 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -815,8 +815,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
+    bool hasWM = HasWindowManager();
+
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
-    swa.override_redirect = False;
+    swa.override_redirect = hasWM ? False : True;
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
@@ -832,7 +834,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
                     InputOutput, vi->visual,
                     mask, &swa);
 
-    if (fullscreen)
+    if (fullscreen && hasWM)
     {
       Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
       XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
@@ -1058,4 +1060,72 @@ bool CWinSystemX11::CreateIconPixmap()
   return true;
 }
 
+bool CWinSystemX11::HasWindowManager()
+{
+  Window wm_check;
+  unsigned char *data;
+  int status, real_format;
+  Atom real_type, prop;
+  unsigned long items_read, items_left, i;
+  char req = 0;
+
+  prop = XInternAtom(m_dpy, "_NET_SUPPORTING_WM_CHECK", True);
+  if (prop == None)
+    return false;
+  status = XGetWindowProperty(m_dpy, DefaultRootWindow(m_dpy), prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+  if(status != Success || ! items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  wm_check = ((Window*)data)[0];
+  XFree(data);
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+
+  if(status != Success || !items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  if(wm_check != ((Window*)data)[0])
+  {
+    XFree(data);
+    return false;
+  }
+
+  XFree(data);
+
+  prop = XInternAtom(m_dpy, "_NET_WM_NAME", True);
+  if (prop == None)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+    return true;
+  }
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                        0L, (~0L), False, AnyPropertyType, &real_type, &real_format,
+                        &items_read, &items_left, &data);
+
+  if(status == Success && items_read)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: %s", data);
+  }
+  else
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+
+  if(status == Success)
+    XFree(data);
+
+  return true;
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 32f90da..28d9d03 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -103,6 +103,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
   bool CreateIconPixmap();
+  bool HasWindowManager();
 
   CStopWatch m_screensaverReset;
 };
-- 
1.8.4


From e8e3afe5fd99d284e3e3b2d272b3cf805541884e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 12 Jul 2012 11:11:47 +0200
Subject: [PATCH 51/94] X11: dont set window on xrandr if no mode available

---
 xbmc/windowing/X11/WinSystemX11.cpp | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index b103248..45741d7 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -664,16 +664,17 @@ void CWinSystemX11::NotifyXRREvent()
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
   m_windowDirty = true;
 
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+
   // if external event update resolutions
   if (!m_bIsInternalXrr)
   {
     UpdateResolutions();
   }
-  else if (!g_xrandr.Query(true))
-  {
-    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-    return;
-  }
   m_bIsInternalXrr = false;
 
   CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
-- 
1.8.4


From 6a7ae49b1715d001b3185d20b3712ef164049b02 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 26 Jul 2012 09:34:28 +0200
Subject: [PATCH 52/94] X11: fix crash after a resolution change on startup

---
 xbmc/windowing/X11/WinSystemX11.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 45741d7..a6cb67f 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -222,7 +222,8 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     OnLostDevice();
     m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
-    return true;
+    if (m_glWindow)
+      return true;
   }
 #endif
 
-- 
1.8.4


From 0825c709d1fd17bcb266792cf68be847c2796c4a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 15 Sep 2012 18:27:29 +0200
Subject: [PATCH 53/94] X11: lock graphics context in NotifyXRREvent

---
 xbmc/windowing/X11/WinSystemX11.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index a6cb67f..70b5f10 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -665,6 +665,8 @@ void CWinSystemX11::NotifyXRREvent()
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
   m_windowDirty = true;
 
+  CSingleLock lock(g_graphicsContext);
+
   if (!g_xrandr.Query(true))
   {
     CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-- 
1.8.4


From b7b1c19dd0910f48d0b43b20c18274f7abc03d36 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 23 Aug 2012 19:39:49 +0200
Subject: [PATCH 54/94] ffmpeg: add av_find_default_stream_index to interface

---
 lib/DllAvFormat.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/lib/DllAvFormat.h b/lib/DllAvFormat.h
index 0016c0b..3514856 100644
--- a/lib/DllAvFormat.h
+++ b/lib/DllAvFormat.h
@@ -106,6 +106,7 @@ class DllAvFormatInterface
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   virtual AVRational av_stream_get_r_frame_rate(const AVStream *s)=0;
 #endif
+  virtual int av_find_default_stream_index(AVFormatContext *s)=0;
 };
 
 #if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
@@ -166,6 +167,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   virtual AVRational av_stream_get_r_frame_rate(const AVStream *s) { return ::av_stream_get_r_frame_rate(s); }
 #endif
+  virtual int av_find_default_stream_index(AVFormatContext *s) { return ::av_find_default_stream_index(s); }
 
   // DLL faking.
   virtual bool ResolveExports() { return true; }
@@ -237,6 +239,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   DEFINE_METHOD1(AVRational, av_stream_get_r_frame_rate, (const AVStream *p1))
 #endif
+  DEFINE_METHOD1(int, av_find_default_stream_index, (AVFormatContext *p1))
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD_RENAME(av_register_all, av_register_all_dont_call)
     RESOLVE_METHOD_RENAME(avformat_network_init,   avformat_network_init_dont_call)
@@ -276,6 +279,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
     RESOLVE_METHOD(av_stream_get_r_frame_rate)
 #endif
+    RESOLVE_METHOD(av_find_default_stream_index)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavformat */
-- 
1.8.4


From e86f4098096c95c4bc7d455a05d92dfd5892cb5f Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 16:06:39 +0200
Subject: [PATCH 55/94] dvdplayer: observe pts counter overflow

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 198 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   4 +
 2 files changed, 201 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 8afeebe..cd02087 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -489,6 +489,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
 
   CreateStreams();
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -629,6 +632,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -768,6 +777,24 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -897,10 +924,20 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   int ret;
   {
     CSingleLock lock(m_critSection);
+
     ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -919,6 +956,165 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = m_dllAvUtil.av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = m_dllAvUtil.av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index aef5ab1..35abbdf 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -100,6 +100,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -158,5 +159,8 @@ class CDVDDemuxFFmpeg : public CDVDDemux
     AVPacket pkt;       // packet ffmpeg returned
     int      result;    // result from av_read_packet
   }m_pkt;
+
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 
-- 
1.8.4


From 317b2ca84d01f9ea3bd4fe92082f8f43942ea6b3 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 2 Oct 2012 13:02:10 +0200
Subject: [PATCH 56/94] dvdplayer: avoid short screen flicker caused by
 unnecessary reconfigure of renderer

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index c40d193..6419951 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1065,7 +1065,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 )
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
@@ -1121,7 +1121,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
     m_output.height          = pPicture->iHeight;
     m_output.dwidth          = pPicture->iDisplayWidth;
     m_output.dheight         = pPicture->iDisplayHeight;
-    m_output.framerate       = config_framerate;
+    m_output.framerate       = config_framerate == 0.0 ? g_graphicsContext.GetFPS() : config_framerate;
     m_output.color_format    = pPicture->format;
     m_output.extended_format = pPicture->extended_format;
     m_output.color_matrix    = pPicture->color_matrix;
-- 
1.8.4


From e6d397d6c00cd2e83c3bff1fe9c14e96a749d197 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Oct 2012 12:05:50 +0200
Subject: [PATCH 57/94] vdpau: advanced settings for auto deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 xbmc/settings/AdvancedSettings.cpp             | 4 ++++
 xbmc/settings/AdvancedSettings.h               | 2 ++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index f026c92..73c9b50 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1959,10 +1959,10 @@ EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 619490d..8f6981a 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -165,6 +165,8 @@ void CAdvancedSettings::Initialize()
   m_videoAllowMpeg4VAAPI = false;  
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -602,6 +604,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetBoolean(pElement,"allowmpeg4vaapi",m_videoAllowMpeg4VAAPI);    
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index d46ee0b..8f031ba 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -160,6 +160,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
-- 
1.8.4


From 36c84909aa9c49933c6f25026ccde1e08bf33c4a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 2 Nov 2012 13:20:03 +0100
Subject: [PATCH 58/94] player: fix rewind

---
 xbmc/cores/dvdplayer/DVDMessage.h       |  5 ++++-
 xbmc/cores/dvdplayer/DVDPlayer.cpp      | 30 +++++++++++++++++++-----------
 xbmc/cores/dvdplayer/DVDPlayer.h        |  7 ++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp |  4 +++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  1 +
 5 files changed, 31 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
index 2ea8b8f..e8274f9 100644
--- a/xbmc/cores/dvdplayer/DVDMessage.h
+++ b/xbmc/cores/dvdplayer/DVDMessage.h
@@ -220,7 +220,7 @@ class CDVDMsgPlayerSetState : public CDVDMsg
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -228,6 +228,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -235,6 +236,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -242,6 +244,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 437276b..2c9fdf1 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1549,11 +1549,13 @@ void CDVDPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo.GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1572,7 +1574,7 @@ void CDVDPlayer::HandlePlaySpeed()
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2060,7 +2062,7 @@ void CDVDPlayer::HandleMessages()
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2199,9 +2201,10 @@ void CDVDPlayer::HandleMessages()
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2217,7 +2220,8 @@ void CDVDPlayer::HandleMessages()
         // do a seek after rewind, clock is not in sync with current pts
         if (m_playSpeed < 0 && speed >= 0)
         {
-          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
@@ -3174,7 +3178,7 @@ bool CDVDPlayer::CloseTeletextStream(bool bWaitForBuffers)
   return true;
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate)
@@ -3186,19 +3190,23 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3242,7 +3250,7 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 1f4b2e8..090d4a2 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -305,7 +305,7 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -354,8 +354,9 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 6419951..f10aef6 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1474,7 +1474,7 @@ double CDVDPlayerVideo::GetCurrentPts()
 
   if( m_stalled )
     iRenderPts = DVD_NOPTS_VALUE;
-  else
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
     iRenderPts = iRenderPts - max(0.0, iSleepTime);
 
   return iRenderPts;
@@ -1574,6 +1574,8 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iSkippedDeint = 0;
   int    iBufferLevel;
 
+  m_droppingStats.m_lastPts = pts;
+
   // get decoder stats
   if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
     iDecoderPts = pts;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 59c7f09..65dea76 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -50,6 +50,7 @@ class CDroppingStats
   double m_totalGain;
   double m_lastDecoderPts;
   double m_lastRenderPts;
+  double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;
 };
-- 
1.8.4


From b12ad5cbebd595aadec1d5463aa9ed78e027f513 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 23 Nov 2012 17:41:12 +0100
Subject: [PATCH 59/94] xrandr: fix query for multiple screens

---
 xbmc/windowing/X11/XRandR.cpp | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 9e181f2..ce0a02b 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -57,12 +57,14 @@ bool CXRandR::Query(bool force)
 
   m_outputs.clear();
   // query all screens
+  // we are happy if at least one screen returns results
+  bool success = false;
   for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
   {
-    if(!Query(force, screennum))
-      return false;
+    if(Query(force, screennum))
+      success = true;
   }
-  return true;
+  return success;
 }
 
 bool CXRandR::Query(bool force, int screennum)
@@ -70,7 +72,7 @@ bool CXRandR::Query(bool force, int screennum)
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
-  cmd.append("-q --screen %d", screennum);
+  cmd.AppendFormat(" -q --screen %d", screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
-- 
1.8.4


From 5738609db3c76b6f0f1e08d4587c558c192085a7 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Dec 2012 15:46:55 +0100
Subject: [PATCH 60/94] X11: add debug log to print out refresh after xrr event

---
 xbmc/windowing/X11/WinSystemX11.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 70b5f10..64d5730 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -684,6 +684,12 @@ void CWinSystemX11::NotifyXRREvent()
   XOutput *out = g_xrandr.GetOutput(currentOutput);
   XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
 
+  if (out)
+    CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
+             , out->name.c_str(), mode.id.c_str(), mode.hz);
+  else
+    CLog::Log(LOGWARNING, "%s - output name not set", __FUNCTION__);
+
   RESOLUTION_INFO res;
   unsigned int i;
   bool found(false);
-- 
1.8.4


From 6d414cefe277209fad9078bfc58f0eabd737ce86 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 11 Dec 2012 11:08:13 +0100
Subject: [PATCH 61/94] X11: dont call XCloseDisplay on shutdown, it crashes
 when powered doen by cec on ATI

---
 xbmc/windowing/X11/WinSystemX11.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 64d5730..edc81c8 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -111,7 +111,8 @@ bool CWinSystemX11::DestroyWindowSystem()
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
     // i have seen core dumps on ATI if the display is not closed here
-    XCloseDisplay(m_dpy);
+    // crashes when shutting down via cec
+//    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
-- 
1.8.4


From 7395971e9da11654485c1f12f5ec0203188424d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gr=C3=A9gory=20Coutant?= <gregory.coutant@gmail.com>
Date: Wed, 12 Dec 2012 19:49:47 +0100
Subject: [PATCH 62/94] x11: support for multiple x screens

---
 xbmc/windowing/X11/XRandR.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index ce0a02b..aa27d2b 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -92,7 +92,7 @@ bool CXRandR::Query(bool force, int screennum)
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != screennum)
+  if (atoi(pRootElement->Attribute("id")) != screennum)
   {
     // TODO ERROR
     return false;
-- 
1.8.4


From e4234031bf7f253c9ed3aa09766098c04166ad39 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 24 Dec 2012 16:02:42 +0100
Subject: [PATCH 63/94] pvr: increase changes counter of stream on stream
 change, cosmetics after dd307930d39d92f145a01a16600cd00e01ec39be

---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
index b96d520..df89f6f 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
@@ -339,9 +339,7 @@ void CDVDDemuxPVRClient::RequestStreams()
       if (stm)
       {
         st = dynamic_cast<CDemuxStreamAudioPVRClient*>(stm);
-        if (!st
-            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
-            || (st->iChannels != props.stream[i].iChannels))
+        if (!st || (st->codec != (AVCodecID)props.stream[i].iCodecId))
           DisposeStream(i);
       }
       if (!m_streams[i])
@@ -358,6 +356,7 @@ void CDVDDemuxPVRClient::RequestStreams()
       st->iBitsPerSample  = props.stream[i].iBitsPerSample;
       m_streams[i] = st;
       st->m_parser_split = true;
+      st->changes++;
     }
     else if (props.stream[i].iCodecType == XBMC_CODEC_TYPE_VIDEO)
     {
-- 
1.8.4


From 97f8f501c0997ea0e6c8acac8c2fa2de58f1480a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 17 Jan 2013 16:03:22 +0100
Subject: [PATCH 64/94] X11: add keymapping for XF86XK_Sleep

---
 xbmc/windowing/WinEventsX11.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index a62521f..263cb5a 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -143,6 +143,7 @@
 , {XK_Break, XBMCK_BREAK}
 , {XK_Menu, XBMCK_MENU}
 , {XF86XK_PowerOff, XBMCK_POWER}
+, {XF86XK_Sleep, XBMCK_SLEEP}
 , {XK_EcuSign, XBMCK_EURO}
 , {XK_Undo, XBMCK_UNDO}
   /* Media keys */
-- 
1.8.4


From 4d9abc55c7e467fbcad18c44b0be1fe14808b335 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 21 Jan 2013 09:00:19 +0100
Subject: [PATCH 65/94] X11: remove toggle full screen after resume

---
 xbmc/powermanagement/PowerManager.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 2033574..c79bbc1 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -268,11 +268,6 @@ void CPowerManager::OnWake()
 #if defined(TARGET_WINDOWS)
     ShowWindow(g_hWnd,SW_RESTORE);
     SetForegroundWindow(g_hWnd);
-#elif !defined(TARGET_DARWIN_OSX)
-    // Hack to reclaim focus, thus rehiding system mouse pointer.
-    // Surely there's a better way?
-    g_graphicsContext.ToggleFullScreenRoot();
-    g_graphicsContext.ToggleFullScreenRoot();
 #endif
   }
   g_application.ResetScreenSaver();
-- 
1.8.4


From b31709094afcf5fdf223163d35488b21bac71298 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 23 Jan 2013 17:03:02 +0100
Subject: [PATCH 66/94] xrandr: set screen on mode change command

---
 xbmc/windowing/X11/XRandR.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index aa27d2b..67bf6ca 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -246,7 +246,7 @@ bool CXRandR::SetMode(XOutput output, XMode mode)
   m_currentMode = modeFound.id;
   char cmd[255];
   if (getenv("XBMC_BIN_HOME"))
-    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.name.c_str(), modeFound.id.c_str());
+    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --screen %d --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.screen, outputFound.name.c_str(), modeFound.id.c_str());
   else
     return false;
   CLog::Log(LOGINFO, "XRANDR: %s", cmd);
-- 
1.8.4


From acbf6280ffdeb86802c7393724b17f14e2018ef6 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 23 Jan 2013 17:03:39 +0100
Subject: [PATCH 67/94] X11: recreate glx context when output changes

---
 xbmc/windowing/X11/WinSystemX11.cpp | 6 +++---
 xbmc/windowing/X11/WinSystemX11.h   | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index edc81c8..c6aa51a 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -408,11 +408,11 @@ bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
   return true;
 }
 
-bool CWinSystemX11::RefreshGlxContext()
+bool CWinSystemX11::RefreshGlxContext(bool force)
 {
   bool retVal = false;
 
-  if (m_glContext)
+  if (m_glContext && !force)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
@@ -929,7 +929,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     }
 
     CDirtyRegionList dr;
-    RefreshGlxContext();
+    RefreshGlxContext(!m_currentOutput.Equals(output));
     XSync(m_dpy, FALSE);
     g_graphicsContext.Clear(0);
     g_graphicsContext.Flip(dr);
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 28d9d03..5a21b00 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -76,7 +76,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   void NotifyMouseCoverage(bool covered);
 
 protected:
-  bool RefreshGlxContext();
+  bool RefreshGlxContext(bool force);
   void CheckDisplayEvents();
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
-- 
1.8.4


From 114b99916a740e1bfc6b785d9087358a4037f186 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 14 Dec 2012 14:19:15 +0100
Subject: [PATCH 68/94] pvr: do not show selection dialog for a single menu
 hook

---
 xbmc/pvr/addons/PVRClients.cpp | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index 5aaf881..4c64877 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -729,6 +729,7 @@ void CPVRClients::ProcessMenuHooks(int iClientID, PVR_MENUHOOK_CAT cat, const CF
   {
     hooks = client->GetMenuHooks();
     std::vector<int> hookIDs;
+    int selection = 0;
 
     CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
     pDialog->Reset();
@@ -739,9 +740,11 @@ void CPVRClients::ProcessMenuHooks(int iClientID, PVR_MENUHOOK_CAT cat, const CF
         pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
         hookIDs.push_back(i);
       }
-    pDialog->DoModal();
-
-    int selection = pDialog->GetSelectedLabel();
+    if (hookIDs.size() > 1)
+    {
+      pDialog->DoModal();
+      selection = pDialog->GetSelectedLabel();
+    }
     if (selection >= 0)
       client->CallMenuHook(hooks->at(hookIDs.at(selection)), item);
   }
-- 
1.8.4


From ff3584b94dc11925e9e4b5674b71f789d0b13596 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 3 Feb 2013 08:17:16 +0100
Subject: [PATCH 69/94] X11: use default screen parameters if no output
 connected

---
 xbmc/windowing/X11/WinSystemX11.cpp | 55 ++++++++++++++++++++++---------------
 1 file changed, 33 insertions(+), 22 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index c6aa51a..f481ea4 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -206,25 +206,27 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
  
   XMode   currmode = g_xrandr.GetCurrentMode(out.name);
-
-  // flip h/w when rotated
-  if (m_bIsRotated)
+  if (!currmode.name.empty())
   {
-    int w = mode.w;
-    mode.w = mode.h;
-    mode.h = w;
-  }
+    // flip h/w when rotated
+    if (m_bIsRotated)
+    {
+      int w = mode.w;
+      mode.w = mode.h;
+      mode.h = w;
+    }
 
-  // only call xrandr if mode changes
-  if (currmode.w != mode.w || currmode.h != mode.h ||
-      currmode.hz != mode.hz || currmode.id != mode.id)
-  {
-    CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
-    OnLostDevice();
-    m_bIsInternalXrr = true;
-    g_xrandr.SetMode(out, mode);
-    if (m_glWindow)
-      return true;
+    // only call xrandr if mode changes
+    if (currmode.w != mode.w || currmode.h != mode.h ||
+        currmode.hz != mode.hz || currmode.id != mode.id)
+    {
+      CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
+      OnLostDevice();
+      m_bIsInternalXrr = true;
+      g_xrandr.SetMode(out, mode);
+      if (m_glWindow)
+        return true;
+    }
   }
 #endif
 
@@ -271,9 +273,10 @@ void CWinSystemX11::UpdateResolutions()
   else
 #endif
   {
-    int x11screen = m_nScreen;
-    int w = DisplayWidth(m_dpy, x11screen);
-    int h = DisplayHeight(m_dpy, x11screen);
+    CSettings::Get().SetString("videoscreen.monitor", "Default");
+    m_nScreen = DefaultScreen(m_dpy);
+    int w = DisplayWidth(m_dpy, m_nScreen);
+    int h = DisplayHeight(m_dpy, m_nScreen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
@@ -818,11 +821,19 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     Colormap cmap;
     XSetWindowAttributes swa;
     XVisualInfo *vi;
+    int x0 = 0;
+    int y0 = 0;
 
     XOutput *out = g_xrandr.GetOutput(output);
     if (!out)
       out = g_xrandr.GetOutput(m_currentOutput);
-    m_nScreen = out->screen;
+    if (out)
+    {
+      m_nScreen = out->screen;
+      x0 = out->x;
+      y0 = out->y;
+    }
+
     vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
@@ -841,7 +852,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
     m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
-                    out->x, out->y, width, height, 0, vi->depth,
+                    x0, y0, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
-- 
1.8.4


From dfbe5c7902208bafa11fb46bb64e11062d006153 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 23 Mar 2013 15:13:32 +0100
Subject: [PATCH 70/94] X11: create parent window

---
 xbmc/windowing/X11/WinSystemX11.cpp | 69 +++++++++++++++++++++++--------------
 xbmc/windowing/X11/WinSystemX11.h   |  2 +-
 2 files changed, 44 insertions(+), 27 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index f481ea4..901b440 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -54,6 +54,7 @@
   m_glContext = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
+  m_mainWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
   m_bIgnoreNextFocusMessage = false;
@@ -131,7 +132,7 @@ bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RES
 
 bool CWinSystemX11::DestroyWindow()
 {
-  if (!m_glWindow)
+  if (!m_mainWindow)
     return true;
 
   if (m_glContext)
@@ -142,19 +143,21 @@ bool CWinSystemX11::DestroyWindow()
 
   if (m_invisibleCursor)
   {
-    XUndefineCursor(m_dpy, m_glWindow);
+    XUndefineCursor(m_dpy, m_mainWindow);
     XFreeCursor(m_dpy, m_invisibleCursor);
     m_invisibleCursor = 0;
   }
 
   CWinEventsX11Imp::Quit();
 
-  XUnmapWindow(m_dpy, m_glWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy,TRUE);
   XUngrabKeyboard(m_dpy, CurrentTime);
   XUngrabPointer(m_dpy, CurrentTime);
   XDestroyWindow(m_dpy, m_glWindow);
+  XDestroyWindow(m_dpy, m_mainWindow);
   m_glWindow = 0;
+  m_mainWindow = 0;
 
   if (m_icon)
     XFreePixmap(m_dpy, m_icon);
@@ -224,7 +227,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
       OnLostDevice();
       m_bIsInternalXrr = true;
       g_xrandr.SetMode(out, mode);
-      if (m_glWindow)
+      if (m_mainWindow)
         return true;
     }
   }
@@ -502,9 +505,9 @@ bool CWinSystemX11::RefreshGlxContext(bool force)
 void CWinSystemX11::ShowOSMouse(bool show)
 {
   if (show)
-    XUndefineCursor(m_dpy,m_glWindow);
+    XUndefineCursor(m_dpy,m_mainWindow);
   else if (m_invisibleCursor)
-    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -587,10 +590,10 @@ void CWinSystemX11::NotifyMouseCoverage(bool covered)
     int result = -1;
     while (result != GrabSuccess && result != AlreadyGrabbed)
     {
-      result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+      result = XGrabPointer(m_dpy, m_mainWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
       XbmcThreads::ThreadSleep(100);
     }
-    XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+    XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
   }
   else
   {
@@ -608,7 +611,7 @@ bool CWinSystemX11::Minimize()
     g_graphicsContext.ToggleFullScreenRoot();
   }
 
-  XIconifyWindow(m_dpy, m_glWindow, m_nScreen);
+  XIconifyWindow(m_dpy, m_mainWindow, m_nScreen);
 
   m_minimized = true;
   return true;
@@ -619,13 +622,13 @@ bool CWinSystemX11::Restore()
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_glWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_glWindow);
+  XMapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -775,7 +778,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   bool mouseActive = false;
   float mouseX, mouseY;
 
-  if (m_glWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
+  if (m_mainWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
   {
     mouseActive = g_Mouse.IsActive();
     if (mouseActive)
@@ -784,7 +787,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       int root_x_return, root_y_return;
       int win_x_return, win_y_return;
       unsigned int mask_return;
-      bool isInWin = XQueryPointer(m_dpy, m_glWindow, &root_return, &child_return,
+      bool isInWin = XQueryPointer(m_dpy, m_mainWindow, &root_return, &child_return,
                                    &root_x_return, &root_y_return,
                                    &win_x_return, &win_y_return,
                                    &mask_return);
@@ -803,7 +806,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   }
 
   // create main window
-  if (!m_glWindow)
+  if (!m_mainWindow)
   {
     EnableSystemScreenSaver(false);
 
@@ -844,22 +847,31 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
-    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
                      ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
                      PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
                      EnterWindowMask | LeaveWindowMask | ExposureMask;
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
-    m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+    m_mainWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
                     x0, y0, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
+    swa.override_redirect = False;
+    swa.border_pixel = 0;
+    swa.event_mask = 0;
+    mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWColormap;
+
+    m_glWindow = XCreateWindow(m_dpy, m_mainWindow,
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
     if (fullscreen && hasWM)
     {
       Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
-      XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+      XChangeProperty(m_dpy, m_mainWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
     }
 
     // define invisible cursor
@@ -868,14 +880,14 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     static char noData[] = { 0,0,0,0,0,0,0,0 };
     black.red = black.green = black.blue = 0;
 
-    bitmapNoData = XCreateBitmapFromData(m_dpy, m_glWindow, noData, 8, 8);
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_mainWindow, noData, 8, 8);
     m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
                                             &black, &black, 0, 0);
     XFreePixmap(m_dpy, bitmapNoData);
-    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 
     //init X11 events
-    CWinEventsX11Imp::Init(m_dpy, m_glWindow);
+    CWinEventsX11Imp::Init(m_dpy, m_mainWindow);
 
     changeWindow = true;
     changeSize = true;
@@ -888,13 +900,17 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
 
   if (changeSize || changeWindow)
   {
+    XResizeWindow(m_dpy, m_mainWindow, width, height);
+  }
+
+  if ((width != m_nWidth) || (height != m_nHeight) || changeWindow)
+  {
     XResizeWindow(m_dpy, m_glWindow, width, height);
   }
 
   if (changeWindow)
   {
     m_icon = None;
-    if (!fullscreen)
     {
       CreateIconPixmap();
       XWMHints *wm_hints;
@@ -911,21 +927,22 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       wm_hints->flags = StateHint | IconPixmapHint;
 
       XSync(m_dpy,False);
-      XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
+      XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
                             NULL, 0, NULL, wm_hints,
                             NULL);
       XFree(wm_hints);
 
       // register interest in the delete window message
       Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
-      XSetWMProtocols(m_dpy, m_glWindow, &wmDeleteMessage, 1);
+      XSetWMProtocols(m_dpy, m_mainWindow, &wmDeleteMessage, 1);
     }
     XMapRaised(m_dpy, m_glWindow);
+    XMapRaised(m_dpy, m_mainWindow);
     XSync(m_dpy,TRUE);
 
     if (changeWindow && mouseActive)
     {
-      XWarpPointer(m_dpy, None, m_glWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+      XWarpPointer(m_dpy, None, m_mainWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
     }
 
     if (fullscreen)
@@ -933,10 +950,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       int result = -1;
       while (result != GrabSuccess && result != AlreadyGrabbed)
       {
-        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+        result = XGrabPointer(m_dpy, m_mainWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
         XbmcThreads::ThreadSleep(100);
       }
-      XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+      XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
     }
 
     CDirtyRegionList dr;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 5a21b00..b866d52 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -81,7 +81,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
 
-  Window       m_glWindow;
+  Window       m_glWindow, m_mainWindow;
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
-- 
1.8.4


From 44f22446106846791e1ac491edc92849d897af80 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 24 Mar 2013 12:30:12 +0100
Subject: [PATCH 71/94] X11: use system key repeat rate instead of hardcoded
 one, taken from 58fd64b194e38b73b5f3132744bab35e994e7441

---
 xbmc/windowing/WinEventsX11.cpp | 58 +++++++++++++----------------------------
 xbmc/windowing/WinEventsX11.h   |  5 +---
 2 files changed, 19 insertions(+), 44 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 263cb5a..09f56ff 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -213,7 +213,6 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
   WinEvents->m_xrrEventPending = false;
-  memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
 
   // open input method
   char *old_locale = NULL, *old_modifiers = NULL;
@@ -328,20 +327,6 @@ bool CWinEventsX11Imp::MessagePump()
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
 
-    //  ignore events generated by auto-repeat
-    if (xevent.type == KeyRelease && XPending(WinEvents->m_display))
-    {
-      XEvent peekevent;
-      XPeekEvent(WinEvents->m_display, &peekevent);
-      if ((peekevent.type == KeyPress) &&
-          (peekevent.xkey.keycode == xevent.xkey.keycode) &&
-          ((peekevent.xkey.time - xevent.xkey.time) < 2))
-      {
-        XNextEvent(WinEvents->m_display, &peekevent);
-        continue;
-      }
-    }
-
     if (XFilterEvent(&xevent, None))
       continue;
 
@@ -364,7 +349,6 @@ bool CWinEventsX11Imp::MessagePump()
         if (WinEvents->m_xic)
           XSetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = true;
-        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         WinEvents->m_keymodState = 0;
         if (serial == xevent.xfocus.serial)
           break;
@@ -377,7 +361,6 @@ bool CWinEventsX11Imp::MessagePump()
         if (WinEvents->m_xic)
           XUnsetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = false;
-        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
         serial = xevent.xfocus.serial;
         break;
@@ -433,7 +416,7 @@ bool CWinEventsX11Imp::MessagePump()
           {
             newEvent.key.keysym.unicode = keybuf[0];
           }
-          ret |= ProcessKey(newEvent, 500);
+          ret |= ProcessKey(newEvent);
           break;
         }
 
@@ -472,7 +455,7 @@ bool CWinEventsX11Imp::MessagePump()
               newEvent.key.keysym.unicode = keys[i];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
-              ret |= ProcessKey(newEvent, 500);
+              ret |= ProcessKey(newEvent);
             }
             if (keys.length() > 0)
             {
@@ -483,7 +466,7 @@ bool CWinEventsX11Imp::MessagePump()
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
 
-              ret |= ProcessKey(newEvent, 500);
+              ret |= ProcessKey(newEvent);
             }
             break;
           }
@@ -494,7 +477,7 @@ bool CWinEventsX11Imp::MessagePump()
             newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
             newEvent.key.state = xevent.xkey.state;
             newEvent.key.type = xevent.xkey.type;
-            ret |= ProcessKey(newEvent, 500);
+            ret |= ProcessKey(newEvent);
             break;
           }
 
@@ -504,6 +487,18 @@ bool CWinEventsX11Imp::MessagePump()
 
       case KeyRelease:
       {
+        // if we have a queued press directly after, this is a repeat
+        if( XEventsQueued( WinEvents->m_display, QueuedAfterReading ) )
+        {
+          XEvent next_event;
+          XPeekEvent( WinEvents->m_display, &next_event );
+          if(next_event.type == KeyPress
+            && next_event.xkey.window == xevent.xkey.window
+            && next_event.xkey.keycode == xevent.xkey.keycode
+            && (next_event.xkey.time - xevent.xkey.time < 2) )
+            continue;
+        }
+
         XBMC_Event newEvent;
         KeySym xkeysym;
         memset(&newEvent, 0, sizeof(newEvent));
@@ -513,7 +508,7 @@ bool CWinEventsX11Imp::MessagePump()
         newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
         newEvent.key.state = xevent.xkey.state;
         newEvent.key.type = xevent.xkey.type;
-        ret |= ProcessKey(newEvent, 0);
+        ret |= ProcessKey(newEvent);
         break;
       }
 
@@ -589,8 +584,6 @@ bool CWinEventsX11Imp::MessagePump()
 
   }// while
 
-  ret |= ProcessKeyRepeat();
-
 #if defined(HAS_XRANDR)
   if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
   {
@@ -635,7 +628,7 @@ size_t CWinEventsX11Imp::GetQueueSize()
   return ret;
 }
 
-bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event, int repeatDelay)
+bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event)
 {
   if (event.type == XBMC_KEYDOWN)
   {
@@ -673,8 +666,6 @@ bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event, int repeatDelay)
         break;
     }
     event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
-    memcpy(&(WinEvents->m_lastKey), &event, sizeof(event));
-    WinEvents->m_repeatKeyTimeout.Set(repeatDelay);
 
     bool ret = ProcessShortcuts(event);
     if (ret)
@@ -715,7 +706,6 @@ bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event, int repeatDelay)
         break;
     }
     event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
-    memset(&(WinEvents->m_lastKey), 0, sizeof(event));
   }
 
   return g_application.OnEvent(event);
@@ -738,18 +728,6 @@ bool CWinEventsX11Imp::ProcessShortcuts(XBMC_Event& event)
   return false;
 }
 
-bool CWinEventsX11Imp::ProcessKeyRepeat()
-{
-  if (WinEvents && (WinEvents->m_lastKey.type == XBMC_KEYDOWN))
-  {
-    if (WinEvents->m_repeatKeyTimeout.IsTimePast())
-    {
-      return ProcessKey(WinEvents->m_lastKey, 10);
-    }
-  }
-  return false;
-}
-
 XBMCKey CWinEventsX11Imp::LookupXbmcKeySym(KeySym keysym)
 {
   // try direct mapping first
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index c69169c..6429291 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -47,8 +47,7 @@ class CWinEventsX11Imp
 
 protected:
   static XBMCKey LookupXbmcKeySym(KeySym keysym);
-  static bool ProcessKey(XBMC_Event &event, int repeatDelay);
-  static bool ProcessKeyRepeat();
+  static bool ProcessKey(XBMC_Event &event);
   static bool ProcessShortcuts(XBMC_Event& event);
   static CWinEventsX11Imp *WinEvents;
   Display *m_display;
@@ -58,8 +57,6 @@ class CWinEventsX11Imp
   size_t m_keybuf_len;
   XIM m_xim;
   XIC m_xic;
-  XBMC_Event m_lastKey;
-  XbmcThreads::EndTime m_repeatKeyTimeout;
   std::map<uint32_t,uint32_t> m_symLookupTable;
   int m_keymodState;
   bool m_structureChanged;
-- 
1.8.4


From 2b21eda7d79ec97334aace0113b7c7e50151af1c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 24 Mar 2013 16:04:48 +0100
Subject: [PATCH 72/94] linux: use CLOCK_MONOTONIC_RAW as this is not subject
 to NTP

---
 xbmc/threads/SystemClock.cpp | 2 +-
 xbmc/utils/TimeUtils.cpp     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/threads/SystemClock.cpp b/xbmc/threads/SystemClock.cpp
index 657a154..35e3abf 100644
--- a/xbmc/threads/SystemClock.cpp
+++ b/xbmc/threads/SystemClock.cpp
@@ -43,7 +43,7 @@
     now_time = (uint64_t)timeGetTime();
 #else
     struct timespec ts = {};
-    clock_gettime(CLOCK_MONOTONIC, &ts);
+    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
     now_time = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
 #endif
     if (!start_time_set)
diff --git a/xbmc/utils/TimeUtils.cpp b/xbmc/utils/TimeUtils.cpp
index c06b8c5..4390d2e 100644
--- a/xbmc/utils/TimeUtils.cpp
+++ b/xbmc/utils/TimeUtils.cpp
@@ -43,7 +43,7 @@ int64_t CurrentHostCounter(void)
   return( (int64_t)PerformanceCount.QuadPart );
 #else
   struct timespec now;
-  clock_gettime(CLOCK_MONOTONIC, &now);
+  clock_gettime(CLOCK_MONOTONIC_RAW, &now);
   return( ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec );
 #endif
 }
-- 
1.8.4


From 05f85dba031559f6b12bfb21f4e62c5379c9a25b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 15:18:53 +0100
Subject: [PATCH 73/94] OMXPlayer: some caching fixes for pvr

---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 56099fe..fc1d725 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -2465,7 +2465,8 @@ void COMXPlayer::HandleMessages()
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
 
         m_playSpeed = speed;
-        m_caching = CACHESTATE_DONE;
+        if (m_caching != CACHESTATE_PVR && m_playSpeed != DVD_PLAYSPEED_NORMAL)
+          m_caching = CACHESTATE_DONE;
         m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
         m_av_clock.OMXPause();
-- 
1.8.4


From f5ab8b4d4c0efcbe30ef84f61da4f9fe72ec4a9d Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 74/94] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a016050..980dd18 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2226,10 +2226,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();
-- 
1.8.4


From b2e0d2c1f92826eed6b78a20f838bf3e29f09669 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 13 Apr 2013 08:32:06 +0200
Subject: [PATCH 75/94] X11: fix mouse coverage

---
 xbmc/windowing/X11/WinSystemX11.cpp | 11 ++++++++---
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 901b440..7987cc2 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -582,10 +582,10 @@ void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
 
 void CWinSystemX11::NotifyMouseCoverage(bool covered)
 {
-  if (!m_bFullScreen)
+  if (!m_bFullScreen || !m_mainWindow)
     return;
 
-  if (covered)
+  if (covered && !m_bIsGrabbed)
   {
     int result = -1;
     while (result != GrabSuccess && result != AlreadyGrabbed)
@@ -594,11 +594,13 @@ void CWinSystemX11::NotifyMouseCoverage(bool covered)
       XbmcThreads::ThreadSleep(100);
     }
     XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+    m_bIsGrabbed = true;
   }
-  else
+  else if (!covered && m_bIsGrabbed)
   {
     XUngrabKeyboard(m_dpy, CurrentTime);
     XUngrabPointer(m_dpy, CurrentTime);
+    m_bIsGrabbed = false;
   }
 }
 
@@ -954,7 +956,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
         XbmcThreads::ThreadSleep(100);
       }
       XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+      m_bIsGrabbed = true;
     }
+    else
+      m_bIsGrabbed = false;
 
     CDirtyRegionList dr;
     RefreshGlxContext(!m_currentOutput.Equals(output));
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index b866d52..3f1b5f8 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -90,6 +90,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
+  bool         m_bIsGrabbed;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-- 
1.8.4


From b67642e4b50c721bc6a9bbcacef45e587928fa9f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 8 May 2013 13:14:58 +0200
Subject: [PATCH 76/94] X11: fix incorrectly used screen num in desktop
 resolution

---
 xbmc/windowing/X11/WinSystemX11.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 7987cc2..b13f1a5 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -267,9 +267,9 @@ void CWinSystemX11::UpdateResolutions()
     XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.w, mode.h, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
     else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.h, mode.w, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
   }
@@ -304,6 +304,7 @@ void CWinSystemX11::UpdateResolutions()
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
                 mode.id.c_str(), mode.name.c_str(), mode.hz, mode.w, mode.h);
       RESOLUTION_INFO res;
+      res.iScreen = 0; // not used by X11
       res.iWidth  = mode.w;
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
-- 
1.8.4


From 4c88f1a2156120ac1b8f5c8aba9202ad76c27221 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 9 May 2013 12:07:09 +0200
Subject: [PATCH 77/94] X11: do not overwrite user selected monitor with
 fallback

---
 xbmc/windowing/X11/WinSystemX11.cpp | 31 ++++++++++++++-----------------
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index b13f1a5..0915f20 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -171,7 +171,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
-  if (!SetWindow(newWidth, newHeight, false, CSettings::Get().GetString("videoscreen.monitor")))
+  if (!SetWindow(newWidth, newHeight, false, m_userOutput))
   {
     return false;
   }
@@ -179,7 +179,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
-  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  m_currentOutput = m_userOutput;
 
   return false;
 }
@@ -233,13 +233,13 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
 #endif
 
-  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, m_userOutput))
     return false;
 
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
-  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  m_currentOutput = m_userOutput;
 
   return true;
 }
@@ -249,34 +249,32 @@ void CWinSystemX11::UpdateResolutions()
   CWinSystemBase::UpdateResolutions();
 
 #if defined(HAS_XRANDR)
-  CStdString currentMonitor;
   int numScreens = XScreenCount(m_dpy);
   g_xrandr.SetNumScreens(numScreens);
   if(g_xrandr.Query(true))
   {
-    currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+    m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
     // check if the monitor is connected
-    XOutput *out = g_xrandr.GetOutput(currentMonitor);
+    XOutput *out = g_xrandr.GetOutput(m_userOutput);
     if (!out)
     {
       // choose first output
-      currentMonitor = g_xrandr.GetModes()[0].name;
-      out = g_xrandr.GetOutput(currentMonitor);
-      CSettings::Get().SetString("videoscreen.monitor", currentMonitor);
+      m_userOutput = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(m_userOutput);
     }
-    XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
+    XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
     else
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = m_userOutput;
   }
   else
 #endif
   {
-    CSettings::Get().SetString("videoscreen.monitor", "Default");
+    m_userOutput = "No Output";
     m_nScreen = DefaultScreen(m_dpy);
     int w = DisplayWidth(m_dpy, m_nScreen);
     int h = DisplayHeight(m_dpy, m_nScreen);
@@ -290,7 +288,7 @@ void CWinSystemX11::UpdateResolutions()
 
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
 
-  XOutput *out = g_xrandr.GetOutput(currentMonitor);
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
   string modename = "";
 
   if (out != NULL)
@@ -690,9 +688,8 @@ void CWinSystemX11::NotifyXRREvent()
   }
   m_bIsInternalXrr = false;
 
-  CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
-  XOutput *out = g_xrandr.GetOutput(currentOutput);
-  XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(m_userOutput);
 
   if (out)
     CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 3f1b5f8..ed70d9c 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -96,6 +96,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
   CStdString                   m_currentOutput;
+  CStdString                   m_userOutput;
   bool                         m_windowDirty;
   bool                         m_bIsInternalXrr;
   bool                         m_newGlContext;
-- 
1.8.4


From bec06cd01c4d3b1ac30e1df579f6fc28d7ba2b49 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 12 May 2013 10:50:30 +0200
Subject: [PATCH 78/94] xrandr: add turn on/off to wrapper

---
 xbmc/windowing/X11/XRandR.cpp | 78 +++++++++++++++++++++++++++++++++++++++----
 xbmc/windowing/X11/XRandR.h   |  6 ++--
 2 files changed, 75 insertions(+), 9 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 67bf6ca..4e480bf 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -28,6 +28,7 @@
 #include "PlatformInclude.h"
 #include "utils/XBMCTinyXML.h"
 #include "../xbmc/utils/log.h"
+#include "threads/SystemClock.h"
 
 #if defined(TARGET_FREEBSD)
 #include <sys/types.h>
@@ -44,7 +45,7 @@
     Query();
 }
 
-bool CXRandR::Query(bool force)
+bool CXRandR::Query(bool force, bool ignoreoff)
 {
   if (!force)
     if (m_bInit)
@@ -61,13 +62,13 @@ bool CXRandR::Query(bool force)
   bool success = false;
   for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
   {
-    if(Query(force, screennum))
+    if(Query(force, screennum, ignoreoff))
       success = true;
   }
   return success;
 }
 
-bool CXRandR::Query(bool force, int screennum)
+bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
 {
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
@@ -136,11 +137,9 @@ bool CXRandR::Query(bool force, int screennum)
       xmode.isCurrent = (strcasecmp(mode->Attribute("current"), "true") == 0);
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
-      {
         hascurrent = true;
-      }
     }
-    if (hascurrent)
+    if (hascurrent || !ignoreoff)
       m_outputs.push_back(xoutput);
     else
       CLog::Log(LOGWARNING, "CXRandR::Query - output %s has no current mode, assuming disconnected", xoutput.name.c_str());
@@ -148,6 +147,71 @@ bool CXRandR::Query(bool force, int screennum)
   return m_outputs.size() > 0;
 }
 
+bool CXRandR::TurnOffOutput(CStdString name)
+{
+  CStdString cmd;
+  cmd  = getenv("XBMC_BIN_HOME");
+  cmd += "/xbmc-xrandr";
+  cmd.AppendFormat(" --output %s --off", name.c_str());
+
+  int status = system(cmd.c_str());
+  if (status == -1)
+    return false;
+
+  if (WEXITSTATUS(status) != 0)
+    return false;
+
+  return true;
+}
+
+bool CXRandR::TurnOnOutput(CStdString name)
+{
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
+  XMode mode = GetCurrentMode(output->name);
+  if (mode.isCurrent)
+    return true;
+
+  // get preferred mode
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
+  {
+    if (m_outputs[j].name == output->name)
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          mode = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
+  }
+
+  if (!mode.isPreferred)
+    return false;
+
+  if (!SetMode(*output, mode))
+    return false;
+
+  XbmcThreads::EndTime timeout(5000);
+  while (!timeout.IsTimePast())
+  {
+    if (!Query(true))
+      return false;
+
+    output = GetOutput(name);
+    if (output && output->h > 0)
+      return true;
+
+    Sleep(200);
+  }
+
+  return false;
+}
+
 std::vector<XOutput> CXRandR::GetModes(void)
 {
   Query();
@@ -161,7 +225,7 @@ void CXRandR::SaveState()
 
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
-  if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
+  if ((output.name == "" && mode.id == ""))
     return true;
 
   Query();
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index d37838a..059062f 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -94,8 +94,8 @@ class CXRandR
 {
 public:
   CXRandR(bool query=false);
-  bool Query(bool force=false);
-  bool Query(bool force, int screennum);
+  bool Query(bool force=false, bool ignoreoff=true);
+  bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
   XMode   GetCurrentMode(CStdString outputName);
   XOutput *GetOutput(CStdString outputName);
@@ -104,6 +104,8 @@ class CXRandR
   void SaveState();
   void SetNumScreens(unsigned int num);
   bool IsOutputConnected(CStdString name);
+  bool TurnOffOutput(CStdString name);
+  bool TurnOnOutput(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
-- 
1.8.4


From 123286882dc36f7e331313c768315ecf3bb29f14 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 19 May 2013 12:55:35 +0200
Subject: [PATCH 79/94] xrandr: add GetPreferredMode to wrapper

---
 xbmc/windowing/X11/XRandR.cpp | 23 +++++++++++++++++++++++
 xbmc/windowing/X11/XRandR.h   |  1 +
 2 files changed, 24 insertions(+)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 4e480bf..4809821 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -347,6 +347,29 @@ XMode CXRandR::GetCurrentMode(CStdString outputName)
   return result;
 }
 
+XMode CXRandR::GetPreferredMode(CStdString outputName)
+{
+  Query();
+  XMode result;
+
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
+  {
+    if (m_outputs[j].name == outputName || outputName == "")
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          result = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
+  }
+
+  return result;
+}
+
 void CXRandR::LoadCustomModeLinesToAllOutputs(void)
 {
   Query();
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 059062f..ab7cc63 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -98,6 +98,7 @@ class CXRandR
   bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
   XMode   GetCurrentMode(CStdString outputName);
+  XMode   GetPreferredMode(CStdString outputName);
   XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
-- 
1.8.4


From 889fa4e42bb227d1a8973ccefab0bb94f660f952 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 11 May 2013 17:12:12 +0200
Subject: [PATCH 80/94] X11: multi-head improvement - poll for desired output
 if we do not get an xrr event

---
 language/English/strings.po         |  9 +++-
 system/settings/settings.xml        |  6 +++
 xbmc/settings/DisplaySettings.cpp   |  4 ++
 xbmc/windowing/WinEventsX11.cpp     |  6 +++
 xbmc/windowing/WinEventsX11.h       |  1 +
 xbmc/windowing/X11/WinSystemX11.cpp | 83 +++++++++++++++++++++++++++++++++----
 xbmc/windowing/X11/WinSystemX11.h   |  2 +-
 xbmc/windowing/X11/XRandR.cpp       |  6 ++-
 8 files changed, 105 insertions(+), 12 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 291932d..2e84253 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6440,7 +6440,7 @@ msgctxt "#14071"
 msgid "Allow file renaming and deletion"
 msgstr ""
 
-#empty strings from id 14072 to 14073
+#empty strings from id 14073 to 14073
 
 msgctxt "#14074"
 msgid "Set timezone"
@@ -6572,7 +6572,12 @@ msgctxt "#14100"
 msgid "Stop ripping CD"
 msgstr ""
 
-#empty strings from id 14101 to 15014
+#: xbmc/settings/settings.xml
+msgctxt "#14101"
+msgid "Swtich off other Monitor"
+msgstr ""
+
+#empty strings from id 14102 to 15014
 
 #: xbmc/dialogs/GUIDialogFavourites.cpp
 msgctxt "#15015"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index e1176d6..4852107 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1874,6 +1874,11 @@
           </constraints>
           <control type="spinner" format="string" delayed="true" />
         </setting>
+        <setting id="videoscreen.monitorsingle" type="boolean" label="14101" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>false</default>
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -1925,6 +1930,7 @@
           </dependencies>
         </setting>
         <setting id="videoscreen.blankdisplays" type="boolean" label="13130" help="36355">
+          <visible>!HAS_GLX</visible>
           <level>1</level>
           <default>false</default>
           <dependencies>
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 1a85651..46895d2 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -265,6 +265,10 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
         m_resolutionChangeAborted = false;
     }
   }
+  else if (settingId == "videoscreen.monitorsingle")
+  {
+    g_Windowing.UpdateResolutions();
+  }
 
   return true;
 }
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 09f56ff..908c8b6 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -213,6 +213,7 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
   WinEvents->m_xrrEventPending = false;
+  WinEvents->m_xrrPollTimer.Set(3000);
 
   // open input method
   char *old_locale = NULL, *old_modifiers = NULL;
@@ -591,6 +592,11 @@ bool CWinEventsX11Imp::MessagePump()
     g_Windowing.NotifyXRREvent();
     WinEvents->m_xrrEventPending = false;
   }
+  else if (!g_application.m_pPlayer->IsPlaying() && WinEvents && WinEvents->m_xrrPollTimer.IsTimePast())
+  {
+    g_Windowing.NotifyXRREvent(true);
+    WinEvents->m_xrrPollTimer.Set(3000);
+  }
 #endif
 
 #ifdef HAS_SDL_JOYSTICK
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 6429291..91a604f 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -62,5 +62,6 @@ class CWinEventsX11Imp
   bool m_structureChanged;
   int m_RREventBase;
   XbmcThreads::EndTime m_xrrFailSafeTimer;
+  XbmcThreads::EndTime m_xrrPollTimer;
   bool m_xrrEventPending;
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 0915f20..cbb56bf 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -251,18 +251,62 @@ void CWinSystemX11::UpdateResolutions()
 #if defined(HAS_XRANDR)
   int numScreens = XScreenCount(m_dpy);
   g_xrandr.SetNumScreens(numScreens);
-  if(g_xrandr.Query(true))
+
+  bool switchOnOff = CSettings::Get().GetBool("videoscreen.monitorsingle");
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.Equals("Default"))
+    switchOnOff = false;
+
+  if(g_xrandr.Query(true, !switchOnOff))
   {
-    m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
     // check if the monitor is connected
-    XOutput *out = g_xrandr.GetOutput(m_userOutput);
+    // might take a while when connected to a receiver
+    XbmcThreads::EndTime timeout(3000);
+    XOutput *out = NULL;
+    while (!m_userOutput.Equals("Default") && !timeout.IsTimePast())
+    {
+      out = g_xrandr.GetOutput(m_userOutput);
+      if (out)
+      {
+        XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+        if (mode.isCurrent || switchOnOff)
+          break;
+        else
+        {
+          out = NULL;
+          break;
+        }
+      }
+
+      Sleep(500);
+      if (!g_xrandr.Query(true, !switchOnOff))
+        break;
+    }
     if (!out)
     {
-      // choose first output
       m_userOutput = g_xrandr.GetModes()[0].name;
       out = g_xrandr.GetOutput(m_userOutput);
     }
+
+    // switch on output
+    if(switchOnOff)
+      g_xrandr.TurnOnOutput(m_userOutput);
+
+    // switch off other outputs if desired
+    if (switchOnOff)
+    {
+      std::vector<XOutput> outputs = g_xrandr.GetModes();
+      for (int i=0; i<outputs.size(); i++)
+      {
+        if (outputs[i].name.Equals(m_userOutput))
+          continue;
+        g_xrandr.TurnOffOutput(outputs[i].name);
+      }
+    }
+
     XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+    if (mode.id.empty())
+      mode = g_xrandr.GetPreferredMode(m_userOutput);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
@@ -381,7 +425,9 @@ bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
 void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 {
   vector<XOutput> outs;
+  g_xrandr.Query(true);
   outs = g_xrandr.GetModes();
+  outputs->push_back("Default");
   for(unsigned int i=0; i<outs.size(); ++i)
   {
     outputs->push_back(outs[i].name);
@@ -668,14 +714,34 @@ void CWinSystemX11::CheckDisplayEvents()
 #endif
 }
 
-void CWinSystemX11::NotifyXRREvent()
+void CWinSystemX11::NotifyXRREvent(bool poll)
 {
-  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  // we may not get an event if desired monitor becomes available
+  // hence we need to poll
+  if (poll)
+  {
+    CStdString output = CSettings::Get().GetString("videoscreen.monitor");
+    if (output.Equals(m_currentOutput) || m_userOutput.Equals("Default"))
+      return;
+
+    int numScreens = XScreenCount(m_dpy);
+    g_xrandr.SetNumScreens(numScreens);
+    g_xrandr.Query(true);
+    if (!g_xrandr.IsOutputConnected(output))
+      return;
+
+    // if output is turned off by user, respect it
+    XMode mode = g_xrandr.GetCurrentMode(output);
+    if (!mode.isCurrent)
+      return;
+  }
+
+  CLog::Log(LOGDEBUG, "%s - notify display reset event, poll: %d", __FUNCTION__, poll);
   m_windowDirty = true;
 
   CSingleLock lock(g_graphicsContext);
 
-  if (!g_xrandr.Query(true))
+  if (!g_xrandr.Query(!poll))
   {
     CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
     return;
@@ -702,7 +768,8 @@ void CWinSystemX11::NotifyXRREvent()
   bool found(false);
   for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
   {
-    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
+    res = CDisplaySettings::Get().GetResolutionInfo(i);
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId.Equals(mode.id))
     {
       found = true;
       break;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index ed70d9c..f0d22bb 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -70,7 +70,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  void NotifyXRREvent();
+  void NotifyXRREvent(bool poll = false);
   void GetConnectedOutputs(std::vector<CStdString> *outputs);
   bool IsCurrentOutput(CStdString output);
   void NotifyMouseCoverage(bool covered);
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 4809821..1ad26b2 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -149,10 +149,14 @@ bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
 
 bool CXRandR::TurnOffOutput(CStdString name)
 {
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
-  cmd.AppendFormat(" --output %s --off", name.c_str());
+  cmd.AppendFormat(" --screen %d --output %s --off", output->screen, name.c_str());
 
   int status = system(cmd.c_str());
   if (status == -1)
-- 
1.8.4


From d2817ab2f9ec608bd7446fa0b3eed9ea3e389fc2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 15 May 2013 09:14:34 +0200
Subject: [PATCH 81/94] X11: ignore mouse move event form other windows

---
 xbmc/windowing/WinEventsX11.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 908c8b6..938ad26 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -328,7 +328,7 @@ bool CWinEventsX11Imp::MessagePump()
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
 
-    if (XFilterEvent(&xevent, None))
+    if (XFilterEvent(&xevent, WinEvents->m_window))
       continue;
 
     switch (xevent.type)
@@ -529,6 +529,8 @@ bool CWinEventsX11Imp::MessagePump()
 
       case MotionNotify:
       {
+        if (xevent.xmotion.window != WinEvents->m_window)
+          break;
         XBMC_Event newEvent;
         memset(&newEvent, 0, sizeof(newEvent));
         newEvent.type = XBMC_MOUSEMOTION;
-- 
1.8.4


From 69045b17b4be1fcc9ab5f07f974064156bfa387c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Jun 2013 16:20:29 +0200
Subject: [PATCH 82/94] renderer: allow some lateness within vblank interval

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 12 ++++++++++--
 xbmc/cores/VideoRenderers/RenderManager.h   |  1 +
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index c0a6409..8539e0f 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -394,6 +394,8 @@ void CXBMCRenderManager::FrameFinish()
   if(g_graphicsContext.IsFullScreenVideo())
     WaitPresentTime(m.timestamp);
 
+  m_clock_framefinish = GetPresentTime();
+
   { CSingleLock lock(m_presentlock);
 
     if(m_presentstep == PRESENT_FRAME)
@@ -1044,6 +1046,12 @@ void CXBMCRenderManager::PrepareNextRender()
 
   double clocktime = GetPresentTime();
   double frametime = 1.0 / GetMaximumFPS();
+  double correction = 0.0;
+  int fps = g_VideoReferenceClock.GetRefreshRate();
+  if((fps > 0) && g_graphicsContext.IsFullScreenVideo() && (clocktime != m_clock_framefinish))
+  {
+    correction = frametime;
+  }
 
   /* see if any future queued frames are already due */
   std::deque<int>::reverse_iterator curr, prev;
@@ -1052,8 +1060,8 @@ void CXBMCRenderManager::PrepareNextRender()
   ++prev;
   while (prev != m_queued.rend())
   {
-    if(clocktime > m_Queue[*prev].timestamp                 /* previous frame is late */
-    && clocktime > m_Queue[*curr].timestamp - frametime)    /* selected frame is close to it's display time */
+    if(clocktime > m_Queue[*prev].timestamp + correction                 /* previous frame is late */
+    && clocktime > m_Queue[*curr].timestamp - frametime + correction)    /* selected frame is close to it's display time */
       break;
     ++curr;
     ++prev;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 949c652b..d84ff6c 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -252,6 +252,7 @@ class CXBMCRenderManager
   XbmcThreads::ConditionVariable  m_presentevent;
   CCriticalSection m_presentlock;
   CEvent     m_flushEvent;
+  double     m_clock_framefinish;
 
 
   OVERLAY::CRenderer m_overlays;
-- 
1.8.4


From c6738ded4737ef2c4d2beeb0f2b3109921452a01 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 16 Jun 2013 13:22:58 +0200
Subject: [PATCH 83/94] X11: another fix for mouse coverage

---
 xbmc/windowing/WinEventsX11.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 938ad26..e4ca56d 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -515,14 +515,16 @@ bool CWinEventsX11Imp::MessagePump()
 
       case EnterNotify:
       {
-        g_Windowing.NotifyMouseCoverage(true);
+        if (xevent.xcrossing.mode ==  NotifyNormal)
+          g_Windowing.NotifyMouseCoverage(true);
         break;
       }
 
       // lose mouse coverage
       case LeaveNotify:
       {
-        g_Windowing.NotifyMouseCoverage(false);
+        if (xevent.xcrossing.mode ==  NotifyNormal)
+          g_Windowing.NotifyMouseCoverage(false);
         g_Mouse.SetActive(false);
         break;
       }
-- 
1.8.4


From a279e20ac527a5361d0ce03754de3d07bf23bd75 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 5 Jul 2013 12:14:00 +0200
Subject: [PATCH 84/94] X11: set windows class name

---
 xbmc/windowing/X11/WinSystemX11.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index cbb56bf..e74f2b0 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -981,8 +981,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     {
       CreateIconPixmap();
       XWMHints *wm_hints;
+      XClassHint *class_hints;
       XTextProperty windowName, iconName;
       std::string titleString = "XBMC Media Center";
+      std::string classString = "xbmc.bin";
       char *title = (char*)titleString.c_str();
 
       XStringListToTextProperty(&title, 1, &windowName);
@@ -993,10 +995,15 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       wm_hints->icon_pixmap = m_icon;
       wm_hints->flags = StateHint | IconPixmapHint;
 
+      class_hints = XAllocClassHint();
+      class_hints->res_class = (char*)classString.c_str();
+      class_hints->res_name = (char*)classString.c_str();
+
       XSync(m_dpy,False);
       XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
                             NULL, 0, NULL, wm_hints,
-                            NULL);
+                            class_hints);
+      XFree(class_hints);
       XFree(wm_hints);
 
       // register interest in the delete window message
-- 
1.8.4


From 5832f25877d457974bd21a4f51631cd04b1b2612 Mon Sep 17 00:00:00 2001
From: spiff <spiff@xbmc.org>
Date: Tue, 16 Jul 2013 14:34:04 +0200
Subject: [PATCH 85/94] fixed: typo

---
 language/English/strings.po | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index 2e84253..f28c8f4 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6574,7 +6574,7 @@ msgstr ""
 
 #: xbmc/settings/settings.xml
 msgctxt "#14101"
-msgid "Swtich off other Monitor"
+msgid "Switch off other Monitor"
 msgstr ""
 
 #empty strings from id 14102 to 15014
-- 
1.8.4


From bb852857f121f7c9c3e3d6cd8c4e631ce6769ebe Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 25 Jul 2013 17:18:13 +0200
Subject: [PATCH 86/94] ActiveAE: slightly reduce buffer size

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 0837b7c..4d644ff 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -30,8 +30,8 @@
 #include "settings/AdvancedSettings.h"
 #include "windowing/WindowingFactory.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)
 {
-- 
1.8.4


From 402e67de7ac962cd55c5b74b48ddcf6b294b5c06 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 4 Aug 2013 10:11:16 +0200
Subject: [PATCH 87/94] Revert "vdpau: comment some features that will be added
 later"

This reverts commit e00b4f65864d623ab4d2e9e5c06db138e661f1cf.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 73c9b50..1ac0978 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1084,8 +1084,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2283,8 +2282,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2295,8 +2293,7 @@ void CMixer::InitCycle()
   EINTERLACEMETHOD method = GetDeinterlacingMethod();
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2318,8 +2315,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }
-- 
1.8.4


From 8da2974a4cd01e9ef9a953fc830eb5ded528f063 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 9 Aug 2013 18:01:40 +0200
Subject: [PATCH 88/94] X11: fix keysyms

---
 xbmc/windowing/WinEventsX11.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index e4ca56d..b20130c 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -461,7 +461,7 @@ bool CWinEventsX11Imp::MessagePump()
             if (keys.length() > 0)
             {
               newEvent.key.keysym.scancode = xevent.xkey.keycode;
-              xkeysym = XLookupKeysym(&xevent.xkey, 0);
+              XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
               newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
               newEvent.key.keysym.unicode = keys[keys.length() - 1];
               newEvent.key.state = xevent.xkey.state;
-- 
1.8.4


From 2cdb5ef6a3fa248618d2a0aabd540692e15806b1 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 9 Aug 2013 18:42:36 +0200
Subject: [PATCH 89/94] X11: fix keysym for non-IM

---
 xbmc/windowing/WinEventsX11.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index b20130c..a38890c 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -408,7 +408,7 @@ bool CWinEventsX11Imp::MessagePump()
         {
           static XComposeStatus state;
           char keybuf[32];
-          xkeysym = XLookupKeysym(&xevent.xkey, 0);
+          XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
           newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
           newEvent.key.keysym.scancode = xevent.xkey.keycode;
           newEvent.key.state = xevent.xkey.state;
-- 
1.8.4


From e7df97fcc3deb43d8af31148910ffc9dad715207 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 10 Aug 2013 11:18:16 +0200
Subject: [PATCH 90/94] add some missing multi media keys

---
 system/keymaps/keyboard.xml  | 3 +++
 xbmc/input/XBMC_keytable.cpp | 4 ++++
 xbmc/input/XBMC_vkeys.h      | 3 +++
 3 files changed, 10 insertions(+)

diff --git a/system/keymaps/keyboard.xml b/system/keymaps/keyboard.xml
index 7db7973..9e9c411 100644
--- a/system/keymaps/keyboard.xml
+++ b/system/keymaps/keyboard.xml
@@ -119,6 +119,9 @@
       <prev_track>SkipPrevious</prev_track>
       <stop>Stop</stop>
       <play_pause>Pause</play_pause>
+      <fastforward>FastForward</fastforward>
+      <rewind>Rewind</rewind>
+      <record/>
       <launch_mail></launch_mail>
       <launch_media_select>XBMC.ActivateWindow(MyMusic)</launch_media_select>
       <launch_app1_pc_icon>ActivateWindow(MyPrograms)</launch_app1_pc_icon>
diff --git a/xbmc/input/XBMC_keytable.cpp b/xbmc/input/XBMC_keytable.cpp
index 246164b..9be22c9 100644
--- a/xbmc/input/XBMC_keytable.cpp
+++ b/xbmc/input/XBMC_keytable.cpp
@@ -181,6 +181,10 @@
 , { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
 , { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
 , { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
+, { XBMCK_REWIND,                 0,    0, XBMCVK_MEDIA_REWIND,        "rewind" }
+, { XBMCK_FASTFORWARD,            0,    0, XBMCVK_MEDIA_FASTFORWARD,   "fastforward" }
+, { XBMCK_RECORD,                 0,    0, XBMCVK_MEDIA_RECORD,        "record" }
+
 
 // Function keys
 , { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
diff --git a/xbmc/input/XBMC_vkeys.h b/xbmc/input/XBMC_vkeys.h
index ee6bb69..364b45a 100644
--- a/xbmc/input/XBMC_vkeys.h
+++ b/xbmc/input/XBMC_vkeys.h
@@ -188,6 +188,9 @@
   XBMCVK_LAUNCH_APP2         = 0xC1,
   XBMCVK_LAUNCH_FILE_BROWSER = 0xC2,
   XBMCVK_LAUNCH_MEDIA_CENTER = 0xC3,
+  XBMCVK_MEDIA_RECORD        = 0xC4,
+  XBMCVK_MEDIA_REWIND        = 0xC5,
+  XBMCVK_MEDIA_FASTFORWARD   = 0xC6,
 
   XBMCVK_LCONTROL       = 0xD0,
   XBMCVK_RCONTROL       = 0xD1,
-- 
1.8.4


From 31876c03527f64d86eafdea64b249753668aecec Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 10 Aug 2013 15:53:45 +0200
Subject: [PATCH 91/94] X11: squash multi

---
 xbmc/windowing/X11/WinSystemX11.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e74f2b0..480efb3 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -436,7 +436,7 @@ void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 
 bool CWinSystemX11::IsCurrentOutput(CStdString output)
 {
-  return m_currentOutput.Equals(output);
+  return output.Equals("Default") || m_currentOutput.Equals(output);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
-- 
1.8.4


From 18ea3370bd51e8087d10d43473aa9fd3810f7cd6 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 3 Sep 2013 20:46:17 +0200
Subject: [PATCH 92/94] X11: do not poll default monitor

---
 xbmc/windowing/X11/WinSystemX11.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 480efb3..dd04357 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -721,7 +721,7 @@ void CWinSystemX11::NotifyXRREvent(bool poll)
   if (poll)
   {
     CStdString output = CSettings::Get().GetString("videoscreen.monitor");
-    if (output.Equals(m_currentOutput) || m_userOutput.Equals("Default"))
+    if (output.Equals(m_currentOutput) || output.Equals("Default"))
       return;
 
     int numScreens = XScreenCount(m_dpy);
-- 
1.8.4


From 223d19ccd2ba02c9bbfc4ef87b0c839a0a4337b3 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 29 Oct 2013 20:57:28 +0100
Subject: [PATCH 93/94] X11: fix broken monitor switching

---
 system/settings/settings.xml      |  1 -
 xbmc/settings/DisplaySettings.cpp | 40 ++++++++++++++++++++++++++-------------
 2 files changed, 27 insertions(+), 14 deletions(-)

diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 4852107..e7a8ebc 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1918,7 +1918,6 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.resolution" />
-            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="spinner" format="string" delayed="true" />
         </setting>
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 46895d2..c495bb0 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -219,19 +219,13 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
 
   const std::string &settingId = setting->GetId();
   if (settingId == "videoscreen.resolution" ||
-      settingId == "videoscreen.screen" ||
-      settingId == "videoscreen.monitor")
+      settingId == "videoscreen.screen")
   {
     RESOLUTION newRes = RES_DESKTOP;
     if (settingId == "videoscreen.resolution")
       newRes = (RESOLUTION)((CSettingInt*)setting)->GetValue();
     else if (settingId == "videoscreen.screen")
       newRes = GetResolutionForScreen();
-    else if (settingId == "videoscreen.monitor")
-    {
-      g_Windowing.UpdateResolutions();
-      newRes = GetResolutionForScreen();
-    }
 
     string screenmode = GetStringFromResolution(newRes);
     CSettings::Get().SetString("videoscreen.screenmode", screenmode);
@@ -242,11 +236,7 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
     RESOLUTION newRes = GetResolutionFromString(((CSettingString*)setting)->GetValue());
 
     SetCurrentResolution(newRes, false);
-    bool outputChanged = false;
-#if defined(HAS_GLX)
-    outputChanged = !g_Windowing.IsCurrentOutput(CSettings::Get().GetString("videoscreen.monitor"));
-#endif
-    g_graphicsContext.SetVideoResolution(newRes, outputChanged);
+    g_graphicsContext.SetVideoResolution(newRes);
 
     // check if the old or the new resolution was/is windowed
     // in which case we don't show any prompt to the user
@@ -265,6 +255,28 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
         m_resolutionChangeAborted = false;
     }
   }
+  else if (settingId == "videoscreen.monitor")
+  {
+    g_Windowing.UpdateResolutions();
+    RESOLUTION newRes = GetResolutionForScreen();
+
+    SetCurrentResolution(newRes, false);
+    g_graphicsContext.SetVideoResolution(newRes, true);
+
+    if (!m_resolutionChangeAborted)
+    {
+      bool cancelled = false;
+      if (!CGUIDialogYesNo::ShowAndGetInput(13110, 13111, 20022, 20022, -1, -1, cancelled, 10000))
+      {
+        m_resolutionChangeAborted = true;
+        return false;
+      }
+    }
+    else
+      m_resolutionChangeAborted = false;
+
+    return true;
+  }
   else if (settingId == "videoscreen.monitorsingle")
   {
     g_Windowing.UpdateResolutions();
@@ -688,9 +700,11 @@ void CDisplaySettings::SettingOptionsMonitorsFiller(const CSetting *setting, std
 #if defined(HAS_GLX)
   std::vector<CStdString> monitors;
   g_Windowing.GetConnectedOutputs(&monitors);
+  std::string currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
   for (unsigned int i=0; i<monitors.size(); ++i)
   {
-    if(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
+    if(currentMonitor.compare("Default") != 0 &&
+       CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
     {
       current = monitors[i];
     }
-- 
1.8.4


From 56b2805fb0e7596ecebf9aed5486344e29bd593f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 29 Oct 2013 20:57:59 +0100
Subject: [PATCH 94/94] X11: remove polling for connected outputs, use xrr
 events

---
 xbmc/windowing/WinEventsX11.cpp     | 44 +++++++++++----------
 xbmc/windowing/WinEventsX11.h       |  1 -
 xbmc/windowing/X11/WinSystemX11.cpp | 76 ++++++++++++++-----------------------
 xbmc/windowing/X11/WinSystemX11.h   |  8 ++--
 4 files changed, 58 insertions(+), 71 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index a38890c..fe91a2b 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -213,7 +213,6 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
   WinEvents->m_xrrEventPending = false;
-  WinEvents->m_xrrPollTimer.Set(3000);
 
   // open input method
   char *old_locale = NULL, *old_modifiers = NULL;
@@ -280,7 +279,11 @@ bool CWinEventsX11Imp::Init(Display *dpy, Window win)
 #if defined(HAS_XRANDR)
   int iReturn;
   XRRQueryExtension(WinEvents->m_display, &WinEvents->m_RREventBase, &iReturn);
-  XRRSelectInput(WinEvents->m_display, WinEvents->m_window, RRScreenChangeNotifyMask);
+  int numScreens = XScreenCount(WinEvents->m_display);
+  for (int i = 0; i < numScreens; i++)
+  {
+    XRRSelectInput(WinEvents->m_display, RootWindow(WinEvents->m_display, i), RRScreenChangeNotifyMask | RRCrtcChangeNotifyMask | RROutputChangeNotifyMask | RROutputPropertyNotifyMask);
+  }
 #endif
 
   return true;
@@ -328,6 +331,26 @@ bool CWinEventsX11Imp::MessagePump()
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
 
+#if defined(HAS_XRANDR)
+    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
+    {
+      XRRUpdateConfiguration(&xevent);
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+    else if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRNotify))
+    {
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+#endif
+
     if (XFilterEvent(&xevent, WinEvents->m_window))
       continue;
 
@@ -575,18 +598,6 @@ bool CWinEventsX11Imp::MessagePump()
         break;
       }
     }// switch event.type
-
-#if defined(HAS_XRANDR)
-    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
-    {
-      XRRUpdateConfiguration(&xevent);
-      if (xevent.xgeneric.serial != serial)
-        g_Windowing.NotifyXRREvent();
-      WinEvents->m_xrrEventPending = false;
-      serial = xevent.xgeneric.serial;
-    }
-#endif
-
   }// while
 
 #if defined(HAS_XRANDR)
@@ -596,11 +607,6 @@ bool CWinEventsX11Imp::MessagePump()
     g_Windowing.NotifyXRREvent();
     WinEvents->m_xrrEventPending = false;
   }
-  else if (!g_application.m_pPlayer->IsPlaying() && WinEvents && WinEvents->m_xrrPollTimer.IsTimePast())
-  {
-    g_Windowing.NotifyXRREvent(true);
-    WinEvents->m_xrrPollTimer.Set(3000);
-  }
 #endif
 
 #ifdef HAS_SDL_JOYSTICK
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 91a604f..6429291 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -62,6 +62,5 @@ class CWinEventsX11Imp
   bool m_structureChanged;
   int m_RREventBase;
   XbmcThreads::EndTime m_xrrFailSafeTimer;
-  XbmcThreads::EndTime m_xrrPollTimer;
   bool m_xrrEventPending;
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index dd04357..b67f291 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -167,8 +167,21 @@ bool CWinSystemX11::DestroyWindow()
 
 bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.compare("Default") == 0)
+  {
+    std::vector<XOutput> outputs = g_xrandr.GetModes();
+    if (outputs.size() > 0)
+    {
+      m_userOutput = outputs[0].name;
+    }
+  }
+
+  m_userOutput = g_xrandr.GetModes()[0].name;
+
   if(m_nWidth  == newWidth
-  && m_nHeight == newHeight)
+  && m_nHeight == newHeight
+  && m_userOutput.compare(m_currentOutput) == 0)
     return true;
 
   if (!SetWindow(newWidth, newHeight, false, m_userOutput))
@@ -254,33 +267,23 @@ void CWinSystemX11::UpdateResolutions()
 
   bool switchOnOff = CSettings::Get().GetBool("videoscreen.monitorsingle");
   m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
-  if (m_userOutput.Equals("Default"))
+  if (m_userOutput.compare("Default") == 0)
     switchOnOff = false;
 
   if(g_xrandr.Query(true, !switchOnOff))
   {
-    // check if the monitor is connected
-    // might take a while when connected to a receiver
-    XbmcThreads::EndTime timeout(3000);
     XOutput *out = NULL;
-    while (!m_userOutput.Equals("Default") && !timeout.IsTimePast())
+    if (m_userOutput.compare("Default") != 0)
     {
       out = g_xrandr.GetOutput(m_userOutput);
       if (out)
       {
         XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
-        if (mode.isCurrent || switchOnOff)
-          break;
-        else
+        if (!mode.isCurrent && !switchOnOff)
         {
           out = NULL;
-          break;
         }
       }
-
-      Sleep(500);
-      if (!g_xrandr.Query(true, !switchOnOff))
-        break;
     }
     if (!out)
     {
@@ -288,17 +291,16 @@ void CWinSystemX11::UpdateResolutions()
       out = g_xrandr.GetOutput(m_userOutput);
     }
 
-    // switch on output
-    if(switchOnOff)
-      g_xrandr.TurnOnOutput(m_userOutput);
-
-    // switch off other outputs if desired
     if (switchOnOff)
     {
+      // switch on output
+      g_xrandr.TurnOnOutput(m_userOutput);
+
+      // switch off other outputs
       std::vector<XOutput> outputs = g_xrandr.GetModes();
       for (int i=0; i<outputs.size(); i++)
       {
-        if (outputs[i].name.Equals(m_userOutput))
+        if (outputs[i].name.Equals(m_userOutput.c_str()))
           continue;
         g_xrandr.TurnOffOutput(outputs[i].name);
       }
@@ -436,7 +438,7 @@ void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 
 bool CWinSystemX11::IsCurrentOutput(CStdString output)
 {
-  return output.Equals("Default") || m_currentOutput.Equals(output);
+  return (output.Equals("Default")) || (m_currentOutput.compare(output) == 0);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
@@ -714,34 +716,14 @@ void CWinSystemX11::CheckDisplayEvents()
 #endif
 }
 
-void CWinSystemX11::NotifyXRREvent(bool poll)
+void CWinSystemX11::NotifyXRREvent()
 {
-  // we may not get an event if desired monitor becomes available
-  // hence we need to poll
-  if (poll)
-  {
-    CStdString output = CSettings::Get().GetString("videoscreen.monitor");
-    if (output.Equals(m_currentOutput) || output.Equals("Default"))
-      return;
-
-    int numScreens = XScreenCount(m_dpy);
-    g_xrandr.SetNumScreens(numScreens);
-    g_xrandr.Query(true);
-    if (!g_xrandr.IsOutputConnected(output))
-      return;
-
-    // if output is turned off by user, respect it
-    XMode mode = g_xrandr.GetCurrentMode(output);
-    if (!mode.isCurrent)
-      return;
-  }
-
-  CLog::Log(LOGDEBUG, "%s - notify display reset event, poll: %d", __FUNCTION__, poll);
+  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
   m_windowDirty = true;
 
   CSingleLock lock(g_graphicsContext);
 
-  if (!g_xrandr.Query(!poll))
+  if (!g_xrandr.Query(true))
   {
     CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
     return;
@@ -838,14 +820,14 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStdString &output)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output)
 {
   bool changeWindow = false;
   bool changeSize = false;
   bool mouseActive = false;
   float mouseX, mouseY;
 
-  if (m_mainWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
+  if (m_mainWindow && ((m_bFullScreen != fullscreen) || m_currentOutput.compare(output) != 0 || m_windowDirty))
   {
     mouseActive = g_Mouse.IsActive();
     if (mouseActive)
@@ -1034,7 +1016,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       m_bIsGrabbed = false;
 
     CDirtyRegionList dr;
-    RefreshGlxContext(!m_currentOutput.Equals(output));
+    RefreshGlxContext(m_currentOutput.compare(output) != 0);
     XSync(m_dpy, FALSE);
     g_graphicsContext.Clear(0);
     g_graphicsContext.Flip(dr);
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index f0d22bb..03bccc9 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -70,7 +70,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  void NotifyXRREvent(bool poll = false);
+  void NotifyXRREvent();
   void GetConnectedOutputs(std::vector<CStdString> *outputs);
   bool IsCurrentOutput(CStdString output);
   void NotifyMouseCoverage(bool covered);
@@ -79,7 +79,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   bool RefreshGlxContext(bool force);
   void CheckDisplayEvents();
   void OnLostDevice();
-  bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
+  bool SetWindow(int width, int height, bool fullscreen, const std::string &output);
 
   Window       m_glWindow, m_mainWindow;
   GLXContext   m_glContext;
@@ -95,8 +95,8 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
-  CStdString                   m_currentOutput;
-  CStdString                   m_userOutput;
+  std::string                  m_currentOutput;
+  std::string                  m_userOutput;
   bool                         m_windowDirty;
   bool                         m_bIsInternalXrr;
   bool                         m_newGlContext;
-- 
1.8.4

