From 0219ba57c0d3bc07a2c3360976dc7755f5a2e81a Mon Sep 17 00:00:00 2001
From: Chia-I Wu <olvaffe@gmail.com>
Date: Wed, 2 Sep 2009 10:58:31 +0800
Subject: [PATCH 07/14] mesa/es: Add OpenGL ES overlay.

This is primitive support for OpenGL ES.  It uses a subset of mesa
sources and builds libesX.a, libesXgallium.a, and libesXapi.a, where X
is 1 for OpenGL ES 1.x, 2 for OpenGL ES 2.x.  Those static libraries
serve the same purpose as libmesa.a, libmesagallium.a, and libglapi.a do
for OpenGL.

This is based on the work of opengl-es branch.
---
 src/mesa/es/Makefile                      |  104 +
 src/mesa/es/main/APIspec.txt              | 2939 +++++++++++++++++++++++++++++
 src/mesa/es/main/apiutil.py               | 1117 +++++++++++
 src/mesa/es/main/es1_special              |   11 +
 src/mesa/es/main/es2_special              |    5 +
 src/mesa/es/main/es_generator.py          |  775 ++++++++
 src/mesa/es/main/get_gen.py               |  785 ++++++++
 src/mesa/es/main/mfeatures.h              |  106 ++
 src/mesa/es/main/pixel.c                  |   96 +
 src/mesa/es/main/specials_es1.c           |  118 ++
 src/mesa/es/main/specials_es2.c           |   80 +
 src/mesa/es/main/st_cpaltex.c             |  254 +++
 src/mesa/es/main/st_fbo.c                 |   41 +
 src/mesa/es/main/st_query_matrix.c        |  198 ++
 src/mesa/es/main/stubs.c                  |  167 ++
 src/mesa/es/sources.mak                   |  170 ++
 src/mesa/es/state_tracker/st_cb_drawtex.c |  292 +++
 src/mesa/es/state_tracker/st_cb_drawtex.h |   28 +
 18 files changed, 7286 insertions(+), 0 deletions(-)
 create mode 100644 src/mesa/es/Makefile
 create mode 100644 src/mesa/es/main/APIspec.txt
 create mode 100644 src/mesa/es/main/apiutil.py
 create mode 100644 src/mesa/es/main/es1_special
 create mode 100644 src/mesa/es/main/es2_special
 create mode 100644 src/mesa/es/main/es_generator.py
 create mode 100644 src/mesa/es/main/get_gen.py
 create mode 100644 src/mesa/es/main/mfeatures.h
 create mode 100644 src/mesa/es/main/pixel.c
 create mode 100644 src/mesa/es/main/specials_es1.c
 create mode 100644 src/mesa/es/main/specials_es2.c
 create mode 100644 src/mesa/es/main/st_cpaltex.c
 create mode 100644 src/mesa/es/main/st_fbo.c
 create mode 100644 src/mesa/es/main/st_query_matrix.c
 create mode 100644 src/mesa/es/main/stubs.c
 create mode 100644 src/mesa/es/sources.mak
 create mode 100644 src/mesa/es/state_tracker/st_cb_drawtex.c
 create mode 100644 src/mesa/es/state_tracker/st_cb_drawtex.h

diff --git a/src/mesa/es/Makefile b/src/mesa/es/Makefile
new file mode 100644
index 0000000..d4d7421
--- /dev/null
+++ b/src/mesa/es/Makefile
@@ -0,0 +1,104 @@
+# src/mesa/es/Makefile
+#
+TOP := ../../..
+MESA := ..
+
+include $(TOP)/configs/current
+include sources.mak
+
+ES1_LIBS := libes1.a libes1gallium.a libes1api.a
+ES2_LIBS := libes2.a libes2gallium.a libes2api.a
+
+# Default rule: create ES1 and ES2 libs
+.PHONY: default
+default: subdirs $(ES1_LIBS) $(ES2_LIBS)
+
+# force the inclusion of es's mfeatures.h
+LOCAL_CFLAGS := -include main/mfeatures.h -D__GL_EXPORTS -UIN_DRI_DRIVER
+
+# rebuild when these files are changed
+ES1_GLAPI_DEPS := glapi/headers-es1/glapi/dispatch.h
+ES2_GLAPI_DEPS := glapi/headers-es2/glapi/dispatch.h
+
+ES1_OBJ_DIR := objs-es1
+ES2_OBJ_DIR := objs-es2
+
+# adjust output dir
+ES1_OBJECTS := $(addprefix $(ES1_OBJ_DIR)/, $(ES1_OBJECTS))
+ES1_GALLIUM_OBJECTS := $(addprefix $(ES1_OBJ_DIR)/, $(ES1_GALLIUM_OBJECTS))
+ES1_API_OBJECTS := $(addprefix $(ES1_OBJ_DIR)/, $(ES1_API_OBJECTS))
+ALL_ES1_OBJECTS := $(addprefix $(ES1_OBJ_DIR)/, $(ALL_ES1_OBJECTS))
+
+ES2_OBJECTS := $(addprefix $(ES2_OBJ_DIR)/, $(ES2_OBJECTS))
+ES2_GALLIUM_OBJECTS := $(addprefix $(ES2_OBJ_DIR)/, $(ES2_GALLIUM_OBJECTS))
+ES2_API_OBJECTS := $(addprefix $(ES2_OBJ_DIR)/, $(ES2_API_OBJECTS))
+ALL_ES2_OBJECTS := $(addprefix $(ES2_OBJ_DIR)/, $(ALL_ES2_OBJECTS))
+
+# specify prerequisites
+$(foreach obj,$(ALL_LOCAL_OBJECTS), \
+	$(eval $(ES1_OBJ_DIR)/$(obj): $(obj:.o=.c) $(ES1_GLAPI_DEPS)) \
+	$(eval $(ES2_OBJ_DIR)/$(obj): $(obj:.o=.c) $(ES2_GLAPI_DEPS)))
+$(foreach obj,$(ALL_MESA_OBJECTS), \
+	$(eval $(ES1_OBJ_DIR)/$(obj): $(MESA)/$(obj:.o=.c) $(ES1_GLAPI_DEPS)) \
+	$(eval $(ES2_OBJ_DIR)/$(obj): $(MESA)/$(obj:.o=.c) $(ES2_GLAPI_DEPS)))
+
+$(ALL_ES1_OBJECTS):
+	@mkdir -p $(dir $@)
+	$(CC) -c $(CFLAGS) $(LOCAL_CFLAGS) $(ES1_INCLUDES) $< -o $@
+
+$(ALL_ES2_OBJECTS):
+	@mkdir -p $(dir $@)
+	$(CC) -c $(CFLAGS) $(LOCAL_CFLAGS) $(ES2_INCLUDES) $< -o $@
+
+libes1.a: $(ES1_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es1 -static $(ES1_OBJECTS)
+
+libes2.a: $(ES2_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es2 -static $(ES1_OBJECTS)
+
+libes1gallium.a: $(ES1_GALLIUM_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es1gallium -static $(ES1_GALLIUM_OBJECTS)
+
+libes2gallium.a: $(ES2_GALLIUM_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es2gallium -static $(ES2_GALLIUM_OBJECTS)
+
+libes1api.a: $(ES1_API_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es1api -static $(ES1_API_OBJECTS)
+
+libes2api.a: $(ES2_API_OBJECTS)
+	@echo "Making $@"
+	@$(TOP)/bin/mklib -o es2api -static $(ES2_API_OBJECTS)
+
+GENERATED_SOURCES :=		\
+	main/api_exec_es1.c	\
+	main/api_exec_es2.c	\
+	main/get_es1.c		\
+	main/get_es2.c
+
+main/api_exec_es1.c: main/APIspec.txt main/es_generator.py main/apiutil.py main/es1_special
+	$(PYTHON2) $(PYTHON_FLAGS) main/es_generator.py -S main/APIspec.txt -V GLES1.1 > $@
+
+main/api_exec_es2.c: main/APIspec.txt main/es_generator.py main/apiutil.py main/es2_special
+	$(PYTHON2) $(PYTHON_FLAGS) main/es_generator.py -S main/APIspec.txt -V GLES2.0 > $@
+
+main/get_es1.c: main/get_gen.py
+	$(PYTHON2) $(PYTHON_FLAGS) $< 1 > $@
+
+main/get_es2.c: main/get_gen.py
+	$(PYTHON2) $(PYTHON_FLAGS) $< 2 > $@
+
+subdirs:
+	make -C glapi
+
+.PHONY: clean
+clean:
+	-rm -f $(ES1_LIBS) $(ES2_LIBS)
+	-rm -rf $(ES1_OBJ_DIR) $(ES2_OBJ_DIR)
+	-rm -f $(GENERATED_SOURCES)
+	-rm -f *~
+	-make -C glapi clean
diff --git a/src/mesa/es/main/APIspec.txt b/src/mesa/es/main/APIspec.txt
new file mode 100644
index 0000000..5974048
--- /dev/null
+++ b/src/mesa/es/main/APIspec.txt
@@ -0,0 +1,2939 @@
+## Adapted from Mesa and Chromium.
+# Python scripts read this file and generate various C files.
+
+# Possible lines:
+#  name     Name of the function (without "gl" prefix).  Required.
+#
+#  return   Datatype of returned value, or void.  Required.
+#
+#  param    Zero or more of these lines may be present.  Each describes a
+#           function parameter.  Two fields follow: parameter name and the
+#           parameter type (which may be several tokens like "const GLvoid *").
+#
+#  vector   Used to indicate the size of constant arrays referenced by
+#	    the given parameter.  (If the number of elements in the
+#	    array is dependent on another parameter, use "dependentvector"
+#	    (below) instead.) 
+#           Two fields follow:  the parameter name (previously defined by a
+#           'param' line) and a number indicating how may elements are
+#           referenced by the vector.  If the number is unknown, don't use
+#           a vector line.  Example for glGetClipPlane:
+#                vector  equation  4
+#
+#  dependentvector  Used to indicate how many elements are referenced by 
+#           pointer params, if the number depends on the value of another
+#           parameter.  It is followed by the parameter name of the vector
+#           parameter (previously defined by a 'param' line, one of the
+#           potential sizes of the array, the name of the controlling
+#           parameter, and a list (one or more) of parameter values of the
+#           controlling parameter that are associated with the given size.
+#           There will always be more than one line of this type (or otherwise
+#           you could have used the "vector" specifier above).
+#	    As a convenience, each parameter value named in a
+#           "dependentvector" specifier will also be considered as a
+#           "paramprop" specifier.
+#           Example for glLightfv:
+#	         dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_SPECULAR GL_POSITION
+#	         dependentvector params 3 pname GL_SPOT_DIRECTION
+#	         dependentvector params 1 pname GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+#
+#  category May be 1.x to indicate that the function belongs to OpenGL
+#           version 1.x.  Or may be the name of an extension such as
+#           GL_ARB_multitexture.  Or may be GLES1.x to indicate
+#	    that the function belongs to GLES version 1.x.  Required.
+#           May have more than one token to indicate that a function
+#	    belongs to more than one category.
+#
+#  alias    Names the Mesa function _mesa_<alias> that will be called.
+#           Mostly used when the function was originally defined and
+#           introduced into Mesa as an extension function (i.e. <func>ARB);
+#           even though the function loses the extension as it is adopted
+#           into the core, the Mesa support remains named the same
+#           (for compatibility).
+#
+#  aliasprefix  May be used to change the default Mesa support functional
+#          prefix on a per-function basis.  By default, it's "_mesa_";
+#          but this allows it to be changed (e.g. to "_vbo_" for many
+#          of the core functions).
+#
+#  props    An optional list of properties for this function.  Possible
+#           properties include:
+#             get       - the function is a state-getter
+#
+# convertalias
+#
+# convertparams
+#
+# checkparam
+#
+# checkdependentparam
+
+name		Color4f
+aliasprefix	_vbo_
+return		void
+param		red		GLfloat
+param		green		GLfloat
+param		blue		GLfloat
+param		alpha		GLfloat
+category	1.0 GLES1.1
+
+name		Color4ub
+return		void
+param		red		GLubyte
+param		green		GLubyte
+param		blue		GLubyte
+param		alpha		GLubyte
+aliasprefix	_vbo_
+convertalias	Color4f
+convertparams   GLfloat red green blue alpha
+category	1.0 GLES1.1
+
+name		Color4x
+return		void
+param		red		GLfixed
+param		green		GLfixed
+param		blue		GLfixed
+param		alpha		GLfixed
+aliasprefix	_vbo_
+convertalias	Color4f
+convertparams   GLfloat red green blue alpha
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		ClipPlane
+return		void
+param		plane		GLenum
+checkparam	plane		GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+param		equation	const GLdouble *
+vector		equation	4
+category	1.0
+
+name		ClipPlanef
+return		void
+param		plane		GLenum
+checkparam	plane		GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+param		equation	const GLfloat *
+vector		equation	4
+convertalias	ClipPlane
+convertparams	GLdouble        equation
+category	GLES1.1 GLES1.1:OES_single_precision
+
+name		ClipPlanex
+return		void
+param		plane		GLenum
+checkparam	plane		GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+param		equation	const GLfixed *
+vector		equation	4
+convertalias	ClipPlane
+convertparams	GLdouble        equation
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		CullFace
+return		void
+param		mode		GLenum
+checkparam	mode		GL_FRONT GL_BACK GL_FRONT_AND_BACK
+category	1.0 GLES1.1 GLES2.0
+
+name		Fogf
+return		void
+param		pname		GLenum
+checkparam      pname GL_FOG_MODE GL_FOG_DENSITY GL_FOG_START GL_FOG_END 
+param		param		GLfloat
+checkdependentparam pname GL_FOG_MODE param GL_EXP GL_EXP2 GL_LINEAR
+category	1.0 GLES1.1
+
+name		Fogfv
+return		void
+param		pname		GLenum
+param		params		const GLfloat *
+paramvec	params		GL_LINEAR
+dependentvector	params 4 pname GL_FOG_COLOR
+dependentvector params 1 pname GL_FOG_DENSITY GL_FOG_START GL_FOG_END 
+dependentvector params 1 pname GL_FOG_MODE
+checkdependentparam pname GL_FOG_MODE params GL_EXP GL_EXP2 GL_LINEAR
+category	1.0 GLES1.1
+
+name		Fogx
+return		void
+param		pname		GLenum
+checkparam      pname GL_FOG_MODE GL_FOG_DENSITY GL_FOG_START GL_FOG_END 
+param		param		GLfixed
+checkdependentparam pname GL_FOG_MODE param GL_EXP GL_EXP2 GL_LINEAR
+convertalias	Fogf
+convertparams	GLfloat         param
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Fogxv
+return		void
+param		pname		GLenum
+param		params		const GLfixed *
+dependentvector	params 4 pname GL_FOG_COLOR
+dependentvector params 1 pname GL_FOG_DENSITY GL_FOG_START GL_FOG_END 
+dependentvector params 1 pname GL_FOG_MODE
+checkdependentparam pname GL_FOG_MODE params GL_EXP GL_EXP2 GL_LINEAR
+convertalias	Fogfv
+convertparams	GLfloat     params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		FrontFace
+return		void
+param		mode		GLenum
+checkparam	mode		GL_CW GL_CCW
+category	1.0 GLES1.1 GLES2.0
+
+name		Hint
+return		void
+param		target		GLenum
+param		mode		GLenum
+checkparam	target		GLES1.1:GL_FOG_HINT GLES1.1:GL_LINE_SMOOTH_HINT GLES1.1:GL_PERSPECTIVE_CORRECTION_HINT GLES1.1:GL_POINT_SMOOTH_HINT 
+checkparam      target          GL_GENERATE_MIPMAP_HINT
+checkparam	mode		GL_FASTEST GL_NICEST GL_DONT_CARE
+# OES_standard_derivatives
+checkparam      target          GLES2.0:GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES
+category	GLES1.1 GLES2.0
+
+name		Lightf
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+checkparam	pname		GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+param		param		GLfloat
+category	1.0 GLES1.1
+
+name		Lightfv
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+param		params		const GLfloat *
+paramvec	params		0.0 1.0 1.0 0.0
+dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_SPECULAR GL_POSITION
+dependentvector params 3 pname GL_SPOT_DIRECTION
+dependentvector params 1 pname GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+category	1.0 1.1 GLES1.1
+
+name		Lightx
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+checkparam	pname		GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+param		param		GLfixed
+convertalias	Lightf
+convertparams	GLfloat         param
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Lightxv
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+param		params		const GLfixed *
+dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_SPECULAR GL_POSITION
+dependentvector params 3 pname GL_SPOT_DIRECTION
+dependentvector params 1 pname GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+convertalias	Lightfv
+convertparams	GLfloat         params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		LightModelf
+return		void
+param		pname		GLenum
+checkparam      pname           GL_LIGHT_MODEL_TWO_SIDE
+param		param		GLfloat
+checkdependentparam pname GL_LIGHT_MODEL_TWO_SIDE param GL_TRUE GL_FALSE
+category	1.0 GLES1.1
+
+name		LightModelfv
+return		void
+param		pname		GLenum
+param		params		const GLfloat *
+dependentvector	params 4 pname GL_LIGHT_MODEL_AMBIENT
+dependentvector	params 1 pname GL_LIGHT_MODEL_TWO_SIDE
+category	1.0 GLES1.1
+
+name		LightModelx
+return		void
+param		pname		GLenum
+checkparam	pname		GL_LIGHT_MODEL_TWO_SIDE
+param		param		GLfixed
+checkdependentparam pname GL_LIGHT_MODEL_TWO_SIDE param GL_TRUE GL_FALSE
+convertalias	LightModelf
+convertparams	GLfloat         param
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		LightModelxv
+return		void
+param		pname		GLenum
+param		params		const GLfixed *
+dependentvector	params 4 pname GL_LIGHT_MODEL_AMBIENT
+dependentvector	params 1 pname GL_LIGHT_MODEL_TWO_SIDE
+checkdependentparam pname GL_LIGHT_MODEL_TWO_SIDE params GL_TRUE GL_FALSE
+convertalias	LightModelfv
+convertparams	GLfloat         params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		LineWidth
+return		void
+param		width		GLfloat
+category	1.0 GLES1.1 GLES2.0
+
+name		LineWidthx
+return		void
+param		width		GLfixed
+convertalias	LineWidth
+convertparams	GLfloat         width
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Materialf
+aliasprefix	_vbo_
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT_AND_BACK
+param		pname		GLenum
+checkparam	pname		GL_SHININESS
+param		param		GLfloat
+category	1.0 GLES1.1
+
+name		Materialfv
+aliasprefix	_vbo_
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT_AND_BACK
+param		pname		GLenum
+param		params		const GLfloat *
+paramvec	params		0.8 0.8 0.5 0.1
+dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_AMBIENT_AND_DIFFUSE GL_SPECULAR GL_EMISSION
+dependentvector params 1 pname GL_SHININESS
+category	1.0 GLES1.1
+
+name		Materialx
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT_AND_BACK
+param		pname		GLenum
+checkparam	pname		GL_SHININESS
+param		param		GLfixed
+aliasprefix	_vbo_
+convertalias	Materialf
+convertparams	GLfloat         param
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Materialxv
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT_AND_BACK
+param		pname		GLenum
+param		params		const GLfixed *
+dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_AMBIENT_AND_DIFFUSE GL_SPECULAR GL_EMISSION
+dependentvector params 1 pname GL_SHININESS
+aliasprefix	_vbo_
+convertalias	Materialfv
+convertparams	GLfloat         params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		PointSize
+return		void
+param		size		GLfloat
+category	1.0 GLES1.1
+
+name		PointSizex
+return		void
+param		size		GLfixed
+convertalias	PointSize
+convertparams	GLfloat         size
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		PointSizePointer
+return		void
+param		type		GLenum
+checkparam	type		GL_FIXED GL_FLOAT
+param		stride		GLsizei
+param		pointer		const GLvoid *
+props		setclient
+# OES_vertex_half_float - not in glext.h
+#checkparam	type		GL_HALF_FLOAT_OES
+category	GLES1.1:OES_point_size_array
+
+name		Scissor
+return		void
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+category	1.0 GLES1.1 GLES2.0
+
+name		ShadeModel
+return		void
+param		mode		GLenum
+checkparam	mode		GL_FLAT GL_SMOOTH
+category	1.0 GLES1.1
+
+name		TexParameterf
+return		void
+param		target		GLenum
+checkparam      target          GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		param		GLfloat
+checkdependentparam pname GL_TEXTURE_WRAP_S param GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T param GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER param GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER param GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP param GLES1.1:GL_TRUE GLES1.1:GL_FALSE
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S param GLES1.1:GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T param GLES1.1:GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+checkparam      pname           GL_TEXTURE_MAX_ANISOTROPY_EXT
+# OES_texture_3D
+checkdependentparam pname GL_TEXTURE_WRAP_R_OES param GLES2.0:GL_CLAMP_TO_EDGE GLES2.0:GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+category	GLES1.1 GLES2.0
+
+name		TexParameterfv
+return		void
+param		target		GLenum 
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		params		const GLfloat *
+dependentvector	params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GLES1.1:GL_GENERATE_MIPMAP
+checkdependentparam pname GL_TEXTURE_WRAP_S params GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T params GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER params GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER params GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP params GLES1.1:GL_TRUE GLES1.1:GL_FALSE
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S params GLES1.1:GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T params GLES1.1:GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+dependentvector	params 1 pname  GL_TEXTURE_MAX_ANISOTROPY_EXT
+# OES_texture_3D
+checkdependentparam pname GL_TEXTURE_WRAP_R_OES params GLES2.0:GL_CLAMP_TO_EDGE GLES2.0:GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+# OES_draw_texture - not in gl2ext.h yet, not supported in Mesa yet
+#dependentvector	params 4 pname GLES1.1:GL_TEXTURE_CROP_RECT_OES
+category	GLES1.1 GLES2.0
+
+name		TexParameteri
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		param		GLint
+checkdependentparam pname GL_TEXTURE_WRAP_S param GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T param GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER param GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER param GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP param GLES1.1:GL_TRUE GLES1.1:GL_FALSE
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S param GLES1.1:GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T param GLES1.1:GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+checkparam      pname           GL_TEXTURE_MAX_ANISOTROPY_EXT
+# OES_texture_3D
+checkdependentparam pname GL_TEXTURE_WRAP_R_OES param GLES2.0:GL_CLAMP_TO_EDGE GLES2.0:GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+category	GLES1.1 GLES2.0
+
+name		TexParameteriv
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		params		const GLint *
+dependentvector	params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GLES1.1:GL_GENERATE_MIPMAP
+checkdependentparam pname GL_TEXTURE_WRAP_S params GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T params GL_CLAMP_TO_EDGE GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER params GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER params GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP params GLES1.1:GL_TRUE GLES1.1:GL_FALSE
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S params GLES1.1:GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T params GLES1.1:GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+dependentvector params 1 pname  GL_TEXTURE_MAX_ANISOTROPY_EXT
+# OES_texture_3D
+checkdependentparam pname GL_TEXTURE_WRAP_R_OES params GLES2.0:GL_CLAMP_TO_EDGE GLES2.0:GL_REPEAT GLES2.0:GL_MIRRORED_REPEAT
+# OES_draw_texture - not in gl2ext.h yet
+dependentvector	params 4 pname GLES1.1:GL_TEXTURE_CROP_RECT_OES
+category	GLES1.1 GLES2.0
+
+name		TexParameterx
+return		void
+param		target		GLenum
+checkparam      target          GL_TEXTURE_2D
+param		pname		GLenum
+param		param		GLfixed
+checkdependentparam pname GL_TEXTURE_WRAP_S param GL_CLAMP_TO_EDGE GL_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T param GL_CLAMP_TO_EDGE GL_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER param GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER param GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP param GL_TRUE GL_FALSE
+convertalias	TexParameterf
+convertparams   GLfloat         param
+# OES_texture_cube_map
+checkparam      target          GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S param GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T param GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+checkparam pname GL_TEXTURE_MAX_ANISOTROPY_EXT
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+
+# Same is true for this function.
+name		TexParameterxv
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GL_TEXTURE_CUBE_MAP_OES
+param		pname		GLenum
+param		params		const GLfixed *
+vector          params          1
+dependentvector	params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GL_GENERATE_MIPMAP
+checkdependentparam pname GL_TEXTURE_WRAP_S params GL_CLAMP_TO_EDGE GL_REPEAT
+checkdependentparam pname GL_TEXTURE_WRAP_T params GL_CLAMP_TO_EDGE GL_REPEAT
+checkdependentparam pname GL_TEXTURE_MIN_FILTER params GL_NEAREST GL_LINEAR GL_NEAREST_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_NEAREST GL_LINEAR_MIPMAP_LINEAR
+checkdependentparam pname GL_TEXTURE_MAG_FILTER params GL_NEAREST GL_LINEAR
+checkdependentparam pname GL_GENERATE_MIPMAP params GL_TRUE GL_FALSE
+convertalias	TexParameterfv
+convertparams   GLfloat         params
+# OES_draw_texture - not supported in Mesa  yet
+dependentvector	params 4 pname GL_TEXTURE_CROP_RECT_OES
+# OES_texture_cube_map
+checkparam      target          GL_TEXTURE_CUBE_MAP_OES
+# OES_texture_mirrored_repeat
+checkdependentparam pname GL_TEXTURE_WRAP_S params GL_MIRRORED_REPEAT_OES
+checkdependentparam pname GL_TEXTURE_WRAP_T params GL_MIRRORED_REPEAT_OES
+# EXT_texture_filter_anisotropic
+dependentvector params 1 pname GL_TEXTURE_MAX_ANISOTROPY_EXT
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+# TexImage2D has *different* versions for GLES1 and GLES2, strangely,
+# with different types for "internalFormat".  There's also a few
+# tokens with different spellings.
+name		TexImage2D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D
+param		level		GLint
+param		internalFormat	GLint
+param		width		GLsizei
+param		height		GLsizei
+param		border		GLint
+param		format		GLenum
+param		type		GLenum
+param		pixels		const GLvoid *
+checkparam      internalFormat /GL_INVALID_VALUE GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+checkparam      border         /GL_INVALID_VALUE 0
+# OES_texture_cube_map
+checkparam	target		GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+## OES_packed_depth_stencil - only appears in GLES2 header files?
+#checkdependentparam format GL_DEPTH_STENCIL_OES internalFormat GL_UNSIGNED_INT_24_8_OES
+category	1.0 GLES1.1 
+
+name		TexImage2D
+return		void
+param		target		GLenum
+param		level		GLint
+# it is compiled with OpenGL header
+#param		internalFormat	GLenum
+param		internalFormat	GLint
+param		width		GLsizei
+param		height		GLsizei
+param		border		GLint
+param		format		GLenum
+param		type		GLenum
+param		pixels		const GLvoid *
+checkparam	target		GL_TEXTURE_2D GL_TEXTURE_CUBE_MAP_POSITIVE_X GL_TEXTURE_CUBE_MAP_POSITIVE_Y GL_TEXTURE_CUBE_MAP_POSITIVE_Z GL_TEXTURE_CUBE_MAP_NEGATIVE_X GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+checkparam      internalFormat /GL_INVALID_VALUE GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+checkparam      border         /GL_INVALID_VALUE 0
+checkdependentparam format GL_ALPHA type GL_UNSIGNED_BYTE
+checkdependentparam format GL_RGB type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_5_6_5
+checkdependentparam format GL_RGBA type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_4_4_4_4 GL_UNSIGNED_SHORT_5_5_5_1
+checkdependentparam format GL_LUMINANCE type GL_UNSIGNED_BYTE
+checkdependentparam format GL_LUMINANCE_ALPHA type GL_UNSIGNED_BYTE
+# OES_texture_float
+checkdependentparam format GL_ALPHA type GL_FLOAT
+checkdependentparam format GL_RGB type GL_FLOAT
+checkdependentparam format GL_RGBA type GL_FLOAT
+checkdependentparam format GL_LUMINANCE type GL_FLOAT
+checkdependentparam format GL_LUMINANCE_ALPHA type GL_FLOAT
+# OES_texture_half_float
+checkdependentparam format GL_ALPHA type GL_HALF_FLOAT_OES
+checkdependentparam format GL_RGB type GL_HALF_FLOAT_OES
+checkdependentparam format GL_RGBA type GL_HALF_FLOAT_OES
+checkdependentparam format GL_LUMINANCE type GL_HALF_FLOAT_OES
+checkdependentparam format GL_LUMINANCE_ALPHA type GL_HALF_FLOAT_OES
+# EXT_texture_type_2_10_10_10_REV
+checkdependentparam format GL_RGBA type GL_UNSIGNED_INT_2_10_10_10_REV_EXT
+# OES_depth_texture
+checkdependentparam format GL_DEPTH_COMPONENT type GL_UNSIGNED_SHORT GL_UNSIGNED_INT
+checkparam     internalFormat  GL_DEPTH_COMPONENT
+category	GLES2.0
+
+name		TexEnvf
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		param		GLfloat
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE param GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_RGB_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+# OES_texture_env_crossbar
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+# OES_point_sprite
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES param GL_TRUE GL_FALSE
+category	1.0 GLES1.1
+
+name		TexEnvfv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		const GLfloat *
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES params GL_TRUE GL_FALSE
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_TEXTURE_ENV_COLOR GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE params GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_RGB_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_COORD_REPLACE_OES GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+dependentvector params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+# OES_texture_env_crossbar
+dependentvector params 1 pname GL_SRC0_RGB GL_SRC1_RGB GL_SRC2_RGB GL_SRC0_ALPHA GL_SRC1_ALPHA GL_SRC2_ALPHA
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.0 GLES1.1
+
+name		TexEnvi
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		param		GLint
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES param GL_TRUE GL_FALSE
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE param GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_RGB_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+# OES_texture_env_crossbar
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.0 GLES1.1
+
+name		TexEnviv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		const GLint *
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES params GL_TRUE GL_FALSE
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_TEXTURE_ENV_COLOR GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE params GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_RGB_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_COORD_REPLACE_OES GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+dependentvector params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+# OES_texture_env_crossbar
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.0 GLES1.1
+
+name		TexEnvx
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		param		GLfixed
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES param GL_TRUE GL_FALSE
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE param GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA param GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_RGB_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE param /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB param GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA param GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+convertalias	TexEnvf
+convertparams	GLfloat     param
+# OES_texture_env_crossbar
+checkdependentparam pname GL_SRC0_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA param GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.0 GLES1.1 GLES1.1:OES_fixed_point
+
+name		TexEnvxv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		const GLfixed *
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam pname GL_COORD_REPLACE_OES params GL_TRUE GL_FALSE
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_TEXTURE_ENV_COLOR GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+checkdependentparam pname GL_TEXTURE_ENV_MODE params GL_REPLACE GL_MODULATE GL_DECAL GL_BLEND GL_ADD GL_COMBINE
+checkdependentparam pname GL_COMBINE_RGB params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT GL_DOT3_RGB GL_DOT3_RGBA
+checkdependentparam pname GL_COMBINE_ALPHA params GL_REPLACE GL_MODULATE GL_ADD GL_ADD_SIGNED GL_INTERPOLATE GL_SUBTRACT
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND0_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND1_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_RGB params GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE GL_CONSTANT GL_PRIMARY_COLOR GL_PREVIOUS
+checkdependentparam pname GL_OPERAND2_ALPHA params GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA
+checkdependentparam pname GL_RGB_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+checkdependentparam pname GL_ALPHA_SCALE params /GL_INVALID_VALUE 1.0 2.0 4.0
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_COORD_REPLACE_OES GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+dependentvector params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+convertalias	TexEnvfv
+convertparams	GLfloat     params
+# OES_texture_env_crossbar
+dependentvector params 1 pname GL_SRC0_RGB GL_SRC1_RGB GL_SRC2_RGB GL_SRC0_ALPHA GL_SRC1_ALPHA GL_SRC2_ALPHA
+checkdependentparam pname GL_SRC0_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_RGB params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC0_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC1_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+checkdependentparam pname GL_SRC2_ALPHA params GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		TexGenx
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		param		GLfixed
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES param GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+convertalias    TexGenf
+convertparams   GLfloat         param
+category	GLES1.1:OES_texture_cube_map
+
+name		TexGenxv
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		params		const GLfixed *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES params GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+convertalias    TexGenfv
+convertparams   GLfloat         params
+category	GLES1.1:OES_texture_cube_map
+
+name		TexGenf
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+checkparam      pname           GL_TEXTURE_GEN_MODE_OES
+param		param		GLfloat
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES param GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		TexGenfv
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		params		const GLfloat *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES params GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		TexGeni
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+checkparam      pname           GL_TEXTURE_GEN_MODE_OES
+param		param		GLint
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES param GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		TexGeniv
+return		void
+param		coord		GLenum
+checkparam      coord           GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+checkparam      pname           GL_TEXTURE_GEN_MODE_OES
+param		params		const GLint *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+checkdependentparam pname GL_TEXTURE_GEN_MODE_OES params GL_NORMAL_MAP_OES GL_REFLECTION_MAP_OES
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		Clear
+return		void
+param		mask		GLbitfield
+checkparam      mask   /GL_INVALID_VALUE 0 (GL_COLOR_BUFFER_BIT) (GL_DEPTH_BUFFER_BIT) (GL_STENCIL_BUFFER_BIT) (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT) (GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT) (GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT) (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)
+category	1.0 GLES1.1 GLES2.0
+
+name		ClearColor
+return		void
+param		red		GLclampf
+param		green		GLclampf
+param		blue		GLclampf
+param		alpha		GLclampf
+category	1.0 GLES1.1 GLES2.0
+
+name		ClearColorx
+return		void
+param		red		GLclampx
+param		green		GLclampx
+param		blue		GLclampx
+param		alpha		GLclampx
+convertalias	ClearColor
+convertparams   GLclampf        red green blue alpha
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		ClearStencil
+return		void
+param		s		GLint
+category	1.0 GLES1.1 GLES2.0
+
+name		ClearDepthf
+return		void
+param		depth		GLclampf
+convertalias	ClearDepth
+convertparams	GLclampd        depth
+category	GLES1.1 GLES1.1:OES_single_precision GLES2.0
+
+name		ClearDepthx
+return		void
+param		depth		GLclampx
+convertalias	ClearDepth
+convertparams	GLclampd        depth
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		StencilMask
+return		void
+param		mask		GLuint
+category	1.0 GLES1.1 GLES2.0
+
+name		StencilMaskSeparate
+return		void
+param           face            GLenum
+param		mask		GLuint
+checkparam      face            GL_FRONT GL_BACK GL_FRONT_AND_BACK
+category	GLES2.0
+
+name		ColorMask
+return		void
+param		red		GLboolean
+param		green		GLboolean
+param		blue		GLboolean
+param		alpha		GLboolean
+category	1.0 GLES1.1 GLES2.0
+
+name		DepthMask
+return		void
+param		flag		GLboolean
+category	1.0 GLES1.1 GLES2.0
+
+# Two versions, as GLES2 has a vastly different set of enable/disable capabilities
+name		Disable
+return		void
+param		cap		GLenum
+checkparam      cap             GL_VERTEX_ARRAY GL_NORMAL_ARRAY GL_COLOR_ARRAY GL_TEXTURE_COORD_ARRAY GL_NORMALIZE GL_RESCALE_NORMAL GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5 GL_FOG GL_LIGHTING GL_COLOR_MATERIAL GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7 GL_POINT_SMOOTH GL_LINE_SMOOTH GL_CULL_FACE GL_POLYGON_OFFSET_FILL GL_MULTISAMPLE GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_ALPHA_TO_ONE GL_SAMPLE_COVERAGE GL_TEXTURE_2D GL_SCISSOR_TEST GL_ALPHA_TEST GL_STENCIL_TEST GL_DEPTH_TEST GL_BLEND GL_DITHER GL_COLOR_LOGIC_OP
+# OES_matrix_palette
+checkparam      cap             GL_MATRIX_INDEX_ARRAY_OES GL_WEIGHT_ARRAY_OES
+# OES_point_size_array
+checkparam      cap             GL_POINT_SIZE_ARRAY_OES
+# OES_point_sprite
+checkparam      cap             GL_POINT_SPRITE_OES
+# OES_texture_cube_map
+checkparam      cap             GL_TEXTURE_CUBE_MAP_OES GL_TEXTURE_GEN_STR_OES
+category	GLES1.1
+
+name		Disable
+return		void
+param		cap		GLenum
+checkparam      cap             GL_CULL_FACE GL_SCISSOR_TEST GL_POLYGON_OFFSET_FILL GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_COVERAGE GL_STENCIL_TEST GL_DEPTH_TEST GL_DITHER GL_BLEND
+category	GLES2.0
+
+# Two versions, as GLES2 has a vastly different set of enable/disable capabilities
+name		Enable
+return		void
+param		cap		GLenum
+checkparam      cap             GL_VERTEX_ARRAY GL_NORMAL_ARRAY GL_COLOR_ARRAY GL_TEXTURE_COORD_ARRAY GL_NORMALIZE GL_RESCALE_NORMAL GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5 GL_FOG GL_LIGHTING GL_COLOR_MATERIAL GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7 GL_POINT_SMOOTH GL_LINE_SMOOTH GL_CULL_FACE GL_POLYGON_OFFSET_FILL GL_MULTISAMPLE GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_ALPHA_TO_ONE GL_SAMPLE_COVERAGE GL_TEXTURE_2D GL_SCISSOR_TEST GL_ALPHA_TEST GL_STENCIL_TEST GL_DEPTH_TEST GL_BLEND GL_DITHER GL_COLOR_LOGIC_OP
+# OES_matrix_palette
+checkparam      cap             GL_MATRIX_INDEX_ARRAY_OES GL_WEIGHT_ARRAY_OES
+# OES_point_size_array
+checkparam      cap             GL_POINT_SIZE_ARRAY_OES
+# OES_point_sprite
+checkparam      cap             GL_POINT_SPRITE_OES
+# OES_texture_cube_map
+checkparam      cap             GL_TEXTURE_CUBE_MAP_OES GL_TEXTURE_GEN_STR_OES
+category	GLES1.1
+
+name		Enable
+return		void
+param		cap		GLenum
+checkparam      cap             GL_CULL_FACE GL_SCISSOR_TEST GL_POLYGON_OFFSET_FILL GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_COVERAGE GL_STENCIL_TEST GL_DEPTH_TEST GL_DITHER GL_BLEND
+category	GLES2.0
+
+name		Finish
+return		void
+category	1.0 GLES1.1 GLES2.0
+
+name		Flush
+return		void
+category	1.0 GLES1.1 GLES2.0
+
+name		AlphaFunc
+return		void
+param		func		GLenum
+checkparam	func		GL_NEVER GL_LESS GL_EQUAL GL_LEQUAL GL_GREATER GL_NOTEQUAL GL_GEQUAL GL_ALWAYS
+param		ref		GLclampf
+category	1.0 GLES1.1
+
+name		AlphaFuncx
+return		void
+param		func		GLenum
+checkparam	func		GL_NEVER GL_LESS GL_EQUAL GL_LEQUAL GL_GREATER GL_NOTEQUAL GL_GEQUAL GL_ALWAYS
+param		ref		GLclampx
+convertalias	AlphaFunc
+convertparams	GLclampf        ref
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		BlendFunc
+return		void
+param		sfactor		GLenum
+checkparam	sfactor		GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_DST_COLOR GL_ONE_MINUS_DST_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_COLOR GL_DST_ALPHA GL_ONE_MINUS_DST_COLOR GL_ONE_MINUS_DST_ALPHA GL_SRC_ALPHA_SATURATE
+checkparam      sfactor         GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+param		dfactor		GLenum
+checkparam	dfactor		GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_COLOR GL_DST_ALPHA GL_ONE_MINUS_DST_COLOR GL_ONE_MINUS_DST_ALPHA
+checkparam      dfactor         GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+category	1.0 GLES1.1 GLES2.0
+
+name		LogicOp
+return		void
+param		opcode		GLenum
+checkparam	opcode		GL_CLEAR GL_SET GL_COPY GL_COPY_INVERTED GL_NOOP GL_INVERT GL_AND GL_NAND GL_OR GL_NOR GL_XOR GL_EQUIV GL_AND_REVERSE GL_AND_INVERTED GL_OR_REVERSE GL_OR_INVERTED
+category	1.0 GLES1.1
+
+name		StencilFunc
+return		void
+param		func		GLenum
+param		ref		GLint
+param		mask		GLuint
+checkparam	func		GL_NEVER GL_LESS GL_LEQUAL GL_GREATER GL_GEQUAL GL_EQUAL GL_NOTEQUAL GL_ALWAYS
+category	1.0 GLES1.1 GLES2.0
+
+name            StencilFuncSeparate
+return          void
+param           face            GLenum
+param           func            GLenum
+param           ref             GLint
+param           mask            GLuint
+checkparam      face            GL_FRONT GL_BACK GL_FRONT_AND_BACK
+checkparam	func		GL_NEVER GL_LESS GL_LEQUAL GL_GREATER GL_GEQUAL GL_EQUAL GL_NOTEQUAL GL_ALWAYS
+category        GLES2.0
+
+name		StencilOp
+return		void
+param		fail		GLenum
+param		zfail		GLenum
+param		zpass		GLenum
+checkparam	fail		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GLES2.0:GL_INCR_WRAP GLES2.0:GL_DECR_WRAP
+checkparam	zfail		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GLES2.0:GL_INCR_WRAP GLES2.0:GL_DECR_WRAP
+checkparam	zpass		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GLES2.0:GL_INCR_WRAP GLES2.0:GL_DECR_WRAP
+# OES_stencil_wrap
+checkparam      fail            GLES1.1:GL_INCR_WRAP_OES GLES1.1:GL_DECR_WRAP_OES
+checkparam      zfail           GLES1.1:GL_INCR_WRAP_OES GLES1.1:GL_DECR_WRAP_OES
+checkparam      zpass           GLES1.1:GL_INCR_WRAP_OES GLES1.1:GL_DECR_WRAP_OES
+category	GLES1.1 GLES2.0
+
+name		StencilOpSeparate
+return		void
+param           face            GLenum
+param		fail		GLenum
+param		zfail		GLenum
+param		zpass		GLenum
+checkparam      face            GL_FRONT GL_BACK GL_FRONT_AND_BACK
+checkparam	fail		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GL_INCR_WRAP GL_DECR_WRAP
+checkparam	zfail		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GL_INCR_WRAP GL_DECR_WRAP
+checkparam	zpass		GL_KEEP GL_ZERO GL_REPLACE GL_INCR GL_DECR GL_INVERT GL_INCR_WRAP GL_DECR_WRAP
+category	GLES2.0
+
+name		DepthFunc
+return		void
+param		func		GLenum
+checkparam	func		GL_NEVER GL_LESS GL_EQUAL GL_LEQUAL GL_GREATER GL_NOTEQUAL GL_GEQUAL GL_ALWAYS
+category	1.0 GLES1.1 GLES2.0
+
+name		PixelStorei
+return		void
+param		pname		GLenum
+checkparam	pname		GL_PACK_ALIGNMENT GL_UNPACK_ALIGNMENT
+param		param		GLint
+checkparam      param /GL_INVALID_VALUE 1 2 4 8
+category	1.0 GLES1.1 GLES2.0
+
+name		ReadPixels
+return		void
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		format		GLenum
+param		type		GLenum
+param		pixels		GLvoid *
+# Technically, only two combinations are actually allowed:
+# GL_RGBA/GL_UNSIGNED_BYTE, and some implementation-specific internal 
+# preferred combination.  I don't know what that is, so I'm allowing
+# any valid combination for now; the underlying support should fail
+# when necessary.
+checkdependentparam format GL_RGBA type GL_UNSIGNED_BYTE
+checkdependentparam format GL_RGBA type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_4_4_4_4  GL_UNSIGNED_SHORT_5_5_5_1
+checkdependentparam format GL_RGB type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_5_6_5
+checkdependentparam format GL_LUMINANCE_ALPHA format GL_UNSIGNED_BYTE
+checkdependentparam format GL_LUMINANCE format GL_UNSIGNED_BYTE
+checkdependentparam format GL_ALPHA format GL_UNSIGNED_BYTE
+props		get 
+category	1.0 GLES1.1 GLES2.0
+
+# Note: glGetBooleanv param checking done inside Mesa
+name		GetBooleanv
+return		void
+param		pname		GLenum
+param		params		GLboolean *
+props		get
+category	GLES1.1 GLES2.0
+
+name		GetClipPlanef
+return		void
+param		plane		GLenum
+checkparam	plane		GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+param		equation	GLfloat *
+paramvec	equation	0.0 0.0 0.0 0.0
+vector		equation	4
+convertalias	GetClipPlane
+convertparams	GLdouble        equation
+props		get
+category	GLES1.1 GLES1.1:OES_single_precision
+
+name		GetClipPlanex
+return		void
+param		plane		GLenum
+checkparam	plane		GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+param		equation	GLfixed *
+paramvec	equation	0.0 0.0 0.0 0.0
+vector		equation	4
+convertalias	GetClipPlane
+convertparams	GLdouble        equation
+props		get
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		GetError
+return		GLenum
+props		get
+category	1.0 GLES1.1 GLES2.0
+
+# Note: glGetFloatv param checking done inside Mesa
+name		GetFloatv
+return		void
+param		pname		GLenum
+param		params		GLfloat *
+props		get
+category	GLES1.1 GLES2.0
+
+name		GetFixedv
+return		void
+param		pname		GLenum
+param		params		GLfixed *
+convertalias	GetFloatv
+convertparams	GLfloat         params
+props		get
+dependentvector params 1 pname GL_CLIENT_ACTIVE_TEXTURE GL_VERTEX_ARRAY GL_VERTEX_ARRAY_SIZE GL_VERTEX_ARRAY_TYPE GL_VERTEX_ARRAY_STRIDE GL_NORMAL_ARRAY GL_NORMAL_ARRAY_TYPE GL_NORMAL_ARRAY_STRIDE GL_COLOR_ARRAY GL_COLOR_ARRAY_SIZE GL_COLOR_ARRAY_TYPE 
+dependentvector params 1 pname GL_TEXTURE_COORD_ARRAY GL_TEXTURE_COORD_ARRAY_SIZE GL_TEXTURE_COORD_ARRAY_TYPE GL_TEXTURE_COORD_ARRAY_STRIDE GL_POINT_SIZE_ARRAY_OES GL_POINT_SIZE_ARRAY_STRIDE_OES GL_ARRAY_BUFFER_BINDING GL_VERTEX_ARRAY_BUFFER_BINDING GL_NORMAL_ARRAY_BUFFER_BINDING GL_COLOR_ARRAY_BUFFER_BINDING GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES GL_ELEMENT_ARRAY_BUFFER_BINDING
+dependentvector params 1 pname GL_MODELVIEW_STACK_DEPTH GL_PROJECTION_STACK_DEPTH GL_TEXTURE_STACK_DEPTH GL_MATRIX_MODE GL_NORMALIZE GL_RESCALE_NORMAL GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5
+dependentvector params 1 pname GL_FOG_DENSITY GL_FOG_START GL_FOG_END GL_FOG_MODE GL_FOG GL_SHADE_MODEL
+dependentvector params 1 pname GL_LIGHTING GL_COLOR_MATERIAL GL_LIGHT_MODEL_TWO_SIDE
+dependentvector params 1 pname GL_POINT_SIZE GL_POINT_SMOOTH GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE GL_POINT_SPRITE_OES GL_LINE_WIDTH  GL_LINE_SMOOTH GL_CULL_FACE GL_CULL_FACE_MODE GL_FRONT_FACE GL_POLYGON_OFFSET_FACTOR GL_POLYGON_OFFSET_UNITS GL_POLYGON_OFFSET_FILL 
+dependentvector params 1 pname GL_MULTISAMPLE GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_ALPHA_TO_ONE GL_SAMPLE_COVERAGE GL_SAMPLE_COVERAGE_VALUE
+dependentvector params 1 pname GL_TEXTURE_2D GL_TEXTURE_BINDING_2D 
+dependentvector params 1 pname GL_ACTIVE_TEXTURE
+dependentvector params 1 pname GL_SCISSOR_TEST GL_ALPHA_TEST_FUNC GL_ALPHA_TEST_REF GL_STENCIL_TEST GL_STENCIL_FUNC GL_STENCIL_VALUE_MASK GL_STENCIL_REF GL_STENCIL_FAIL GL_STENCIL_PASS_DEPTH_FAIL GL_STENCIL_PASS_DEPTH_PASS GL_DEPTH_TEST GL_DEPTH_FUNC GL_BLEND GL_BLEND_SRC GL_BLEND_DST GL_DITHER GL_COLOR_LOGIC_OP GL_LOGIC_OP_MODE
+dependentvector params 1 pname GL_DEPTH_WRITEMASK GL_STENCIL_WRITEMASK GL_DEPTH_CLEAR_VALUE GL_STENCIL_CLEAR_VALUE
+dependentvector params 1 pname GL_UNPACK_ALIGNMENT GL_PACK_ALIGNMENT
+dependentvector params 1 pname GL_PERSPECTIVE_CORRECTION_HINT GL_POINT_SMOOTH_HINT GL_LINE_SMOOTH_HINT GL_FOG_HINT GL_GENERATE_MIPMAP_HINT
+dependentvector params 1 pname GL_MAX_LIGHTS GL_MAX_CLIP_PLANES GL_MAX_MODELVIEW_STACK_DEPTH GL_MAX_PROJECTION_STACK_DEPTH GL_MAX_TEXTURE_STACK_DEPTH GL_SUBPIXEL_BITS GL_MAX_TEXTURE_SIZE GL_MAX_TEXTURE_UNITS GL_SAMPLE_BUFFERS GL_SAMPLES GL_NUM_COMPRESSED_TEXTURE_FORMATS GL_RED_BITS GL_GREEN_BITS GL_BLUE_BITS GL_ALPHA_BITS GL_DEPTH_BITS GL_STENCIL_BITS
+dependentvector params 2 pname GL_MAX_VIEWPORT_DIMS GL_ALIASED_POINT_SIZE_RANGE GL_SMOOTH_POINT_SIZE_RANGE GL_ALIASED_LINE_WIDTH_RANGE GL_SMOOTH_LINE_WIDTH_RANGE
+dependentvector params 2 pname GL_DEPTH_RANGE
+dependentvector params 3 pname GL_CURRENT_NORMAL
+dependentvector params 3 pname GL_POINT_DISTANCE_ATTENUATION
+dependentvector params 4 pname GL_CURRENT_COLOR GL_CURRENT_TEXTURE_COORDS
+dependentvector params 4 pname GL_SCISSOR_BOX
+dependentvector params 4 pname GL_COLOR_WRITEMASK GL_COLOR_CLEAR_VALUE
+dependentvector params 4 pname GL_LIGHT_MODEL_AMBIENT
+dependentvector params 4 pname GL_VIEWPORT
+dependentvector params 4 pname GL_FOG_COLOR
+dependentvector params 16 pname GL_MODELVIEW_MATRIX GL_PROJECTION_MATRIX GL_TEXTURE_MATRIX 
+dependentvector params _get_size(GL_NUM_COMPRESSED_TEXTURE_FORMATS) pname GL_COMPRESSED_TEXTURE_FORMATS 
+# OES_blend_subtract
+dependentvector params 1 pname GL_BLEND_SRC_RGB_OES GL_BLEND_DST_RGB_OES GL_BLEND_SRC_ALPHA_OES GL_BLEND_DST_ALPHA_OES
+# OES_blend_equation_separate
+dependentvector params 1 pname GL_BLEND_EQUATION_RGB_OES GL_BLEND_EQUATION_ALPHA_OES
+# OES_framebuffer_object
+dependentvector params 1 pname GL_FRAMEBUFFER_BINDING_OES GL_RENDERBUFFER_BINDING_OES GL_MAX_RENDERBUFFER_SIZE_OES
+# OES_matrix_get
+dependentvector params 16 pname GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES
+# OES_matrix_palette
+dependentvector params 1 pname GL_MAX_PALETTE_MATRICES_OES GL_MAX_VERTEX_UNITS_OES GL_CURRENT_PALETTE_MATRIX_OES
+dependentvector params 1 pname GL_MATRIX_INDEX_ARRAY_SIZE_OES GL_MATRIX_INDEX_ARRAY_TYPE_OES GL_MATRIX_INDEX_ARRAY_STRIDE_OES GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES GL_WEIGHT_ARRAY_SIZE_OES GL_WEIGHT_ARRAY_TYPE_OES GL_WEIGHT_ARRAY_STRIDE_OES GL_WEIGHT_ARRAY_BUFFER_BINDING_OES
+# OES_point_size_array
+dependentvector params 1 pname GL_POINT_SIZE_ARRAY_TYPE_OES GL_POINT_SIZE_ARRAY_STRIDE_OES GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES
+# OES_read_format
+dependentvector params 1 pname GL_IMPLEMENTATION_COLOR_READ_TYPE_OES GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES
+# OES_texture_cube_map
+dependentvector params 1 pname GL_TEXTURE_CUBE_MAP_OES GL_TEXTURE_BINDING_CUBE_MAP_OES GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES
+# EXT_texture_filter_anisotropic
+dependentvector params 1 pname GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT
+# These values return booleans or GLenums, and should not have their
+# value converted when used with glGetFixed()
+dependentnovalueconvert params pname GL_VERTEX_ARRAY GL_VERTEX_ARRAY_TYPE GL_NORMAL_ARRAY GL_NORMAL_ARRAY_TYPE GL_COLOR_ARRAY GL_COLOR_ARRAY_TYPE GL_TEXTURE_COORD_ARRAY GL_TEXTURE_COORD_ARRAY_TYPE GL_POINT_SIZE_ARRAY_OES GL_MATRIX_MODE GL_NORMALIZE GL_RESCALE_NORMAL GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5 GL_FOG_MODE GL_FOG GL_SHADE_MODEL GL_LIGHTING GL_COLOR_MATERIAL GL_LIGHT_MODEL_TWO_SIDE GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7 GL_POINT_SMOOTH GL_POINT_SPRITE_OES GL_LINE_SMOOTH GL_CULL_FACE GL_CULL_FACE_MODE GL_FRONT_FACE GL_POLYGON_OFFSET_FILL GL_MULTISAMPLE GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_ALPHA_TO_ONE GL_SAMPLE_COVERAGE GL_TEXTURE_2D GL_ACTIVE_TEXTURE GL_SCISSOR_TEST GL_ALPHA_TEST GL_ALPHA_TEST_FUNC GL_STENCIL_TEST GL_STENCIL_FUNC GL_STENCIL_FAIL GL_STENCIL_PASS_DEPTH_FAIL GL_STENCIL_PASS_DEPTH_PASS GL_DEPTH_TEST GL_DEPTH_FUNC GL_BLEND GL_BLEND_SRC GL_BLEND_DST GL_DITHER GL_COLOR_LOGIC_OP GL_LOGIC_OP_MODE GL_DEPTH_WRITEMASK GL_PERSPECTIVE_CORRECTION_HINT GL_POINT_SMOOTH_HINT GL_LINE_SMOOTH_HINT GL_FOG_HINT GL_GENERATE_MIPMAP_HINT GL_COMPRESSED_TEXTURE_FORMATS GL_IMPLEMENTATION_COLOR_READ_TYPE_OES GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES GL_BLEND_SRC_RGB_OES GL_BLEND_DST_RGB_OES GL_BLEND_SRC_ALPHA_OES GL_BLEND_DST_ALPHA_OES GL_BLEND_EQUATION_RGB_OES GL_BLEND_EQUATION_ALPHA_OES GL_MATRIX_INDEX_ARRAY_TYPE_OES GL_WEIGHT_ARRAY_TYPE_OES GL_POINT_SIZE_ARRAY_TYPE_OES GL_TEXTURE_CUBE_MAP_OES 
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+# Note: glGetIntegerv param checking done inside Mesa
+name		GetIntegerv
+return		void
+param		pname		GLenum
+param		params		GLint *
+props		get
+category	GLES1.1 GLES2.0
+
+
+# This does *not* specify dependent vectors because everything is just
+# passed down to Mesa - no copy or conversion is done.
+name		GetLightfv
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+checkparam	pname		GL_AMBIENT GL_DIFFUSE GL_SPECULAR GL_POSITION GL_SPOT_DIRECTION GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATION
+param		params		GLfloat *
+props		get
+category	1.0 GLES1.1
+
+name		GetLightxv
+return		void
+param		light		GLenum
+checkparam	light		GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7
+param		pname		GLenum
+param		params		GLfixed *
+dependentvector	params 4 pname GL_AMBIENT GL_DIFFUSE GL_SPECULAR GL_POSITION
+dependentvector params 3 pname GL_SPOT_DIRECTION 
+dependentvector params 1 pname GL_SPOT_EXPONENT GL_SPOT_CUTOFF GL_CONSTANT_ATTENUATION GL_QUADRATIC_ATTENUATION 
+convertalias	GetLightfv
+convertparams	GLfloat         params
+props		get
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		GetMaterialfv
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT GL_BACK
+param		pname		GLenum
+checkparam	pname		GL_AMBIENT GL_DIFFUSE GL_AMBIENT_AND_DIFFUSE GL_SPECULAR GL_EMISSION GL_SHININESS
+param		params		GLfloat *
+props		get
+category	1.0 GLES1.1
+
+name		GetMaterialiv
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT GL_BACK
+param		pname		GLenum
+checkparam	pname		GL_AMBIENT GL_DIFFUSE GL_AMBIENT_AND_DIFFUSE GL_SPECULAR GL_EMISSION GL_SHININESS
+param		params		GLint *
+category	1.0
+props		get
+
+name		GetMaterialxv
+return		void
+param		face		GLenum
+checkparam	face		GL_FRONT GL_BACK
+param		pname		GLenum
+param		params		GLfixed *
+props		get
+dependentvector params 1 pname GL_SHININESS 
+dependentvector params 4 pname GL_AMBIENT GL_DIFFUSE GL_AMBIENT_AND_DIFFUSE GL_SPECULAR GL_EMISSION
+convertalias	GetMaterialfv
+convertparams	GLfloat         params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		GetString
+return		const GLubyte *
+param		name		GLenum
+checkparam	name		GL_VENDOR GL_RENDERER GL_VERSION GL_EXTENSIONS
+props		get
+category	1.0 GLES1.1 GLES2.0
+
+name		GetTexEnvfv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		GLfloat *
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_TEXTURE_ENV_COLOR GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector	params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+dependentvector	params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_SRC1_RGB GL_SRC2_RGB GL_SRC0_ALPHA GL_SRC1_ALPHA GL_SRC2_ALPHA GL_OPERAND0_RGB GL_OPERAND1_RGB GL_OPERAND2_RGB GL_OPERAND0_ALPHA GL_OPERAND1_ALPHA GL_OPERAND2_ALPHA GL_COORD_REPLACE_OES
+dependentnovalueconvert params pname GL_COORD_REPLACE_OES GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+props		get
+category	1.0 GLES1.1
+
+name		GetTexEnviv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		GLint *
+props		get
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+category	1.0 GLES1.1
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector	params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+dependentvector	params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_SRC1_RGB GL_SRC2_RGB GL_SRC0_ALPHA GL_SRC1_ALPHA GL_SRC2_ALPHA GL_OPERAND0_RGB GL_OPERAND1_RGB GL_OPERAND2_RGB GL_OPERAND0_ALPHA GL_OPERAND1_ALPHA GL_OPERAND2_ALPHA GL_COORD_REPLACE_OES
+dependentnovalueconvert params pname GL_COORD_REPLACE_OES GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+
+name		GetTexEnvxv
+return		void
+param		target		GLenum
+param		pname		GLenum
+param		params		GLfixed *
+checkdependentparam target GL_POINT_SPRITE_OES pname GL_COORD_REPLACE_OES
+checkdependentparam target GL_TEXTURE_ENV pname GL_TEXTURE_ENV_MODE GL_TEXTURE_ENV_COLOR GL_COMBINE_RGB GL_COMBINE_ALPHA GL_RGB_SCALE GL_ALPHA_SCALE GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+dependentvector	params 4 pname GL_TEXTURE_ENV_COLOR
+dependentvector	params 1 pname GL_RGB_SCALE GL_ALPHA_SCALE
+dependentvector	params 1 pname GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_SRC1_RGB GL_SRC2_RGB GL_SRC0_ALPHA GL_SRC1_ALPHA GL_SRC2_ALPHA GL_OPERAND0_RGB GL_OPERAND1_RGB GL_OPERAND2_RGB GL_OPERAND0_ALPHA GL_OPERAND1_ALPHA GL_OPERAND2_ALPHA GL_COORD_REPLACE_OES
+dependentnovalueconvert params pname GL_COORD_REPLACE_OES GL_TEXTURE_ENV_MODE GL_COMBINE_RGB GL_COMBINE_ALPHA GL_SRC0_RGB GL_OPERAND0_RGB GL_SRC0_ALPHA GL_OPERAND0_ALPHA GL_SRC1_RGB GL_OPERAND1_RGB GL_SRC1_ALPHA GL_OPERAND1_ALPHA GL_SRC2_RGB GL_OPERAND2_RGB GL_SRC2_ALPHA GL_OPERAND2_ALPHA
+convertalias	GetTexEnvfv
+convertparams	GLfloat         params
+props		get
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		GetTexGenfv
+return		void
+param		coord		GLenum
+checkparam	coord		GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		params		GLfloat *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+props		get
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		GetTexGenxv
+return		void
+param		coord		GLenum
+checkparam	coord		GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		params		GLfixed *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+convertalias    GetTexGenfv
+convertparams	GLfloat         params
+dependentnovalueconvert params pname GL_TEXTURE_GEN_MODE_OES 
+props		get
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		GetTexGeniv
+return		void
+param		coord		GLenum
+checkparam	coord		GL_TEXTURE_GEN_STR_OES
+param		pname		GLenum
+param		params		GLint *
+dependentvector params 1 pname GL_TEXTURE_GEN_MODE_OES
+props		get
+category	1.0 GLES1.1:OES_texture_cube_map
+
+name		GetTexParameterfv
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		params		GLfloat *
+dependentvector params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GLES1.1:GL_GENERATE_MIPMAP
+props		get
+# OES_draw_texture - not in gl2ext.h yet
+dependentvector	params 4 pname  GLES1.1:GL_TEXTURE_CROP_RECT_OES
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+category	GLES1.1 GLES2.0
+
+name		GetTexParameteriv
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		pname		GLenum
+param		params		GLint *
+dependentvector params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GLES1.1:GL_GENERATE_MIPMAP
+props		get
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+# OES_draw_texture - not in gl2ext.h yet, not supported in Mesa yet
+dependentvector	params 4 pname GLES1.1:GL_TEXTURE_CROP_RECT_OES
+# OES_texture_3D
+checkparam      target          GLES2.0:GL_TEXTURE_3D_OES
+category	GLES1.1 GLES2.0
+
+name		GetTexParameterxv
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D
+param		pname		GLenum
+param		params		GLfixed *
+dependentvector params 1 pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GL_GENERATE_MIPMAP
+convertalias	GetTexParameterfv
+convertparams	GLfloat         params
+dependentnovalueconvert params pname GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GL_GENERATE_MIPMAP
+props		get
+# OES_texture_cube_map
+checkparam      target          GL_TEXTURE_CUBE_MAP_OES
+# OES_draw_texture - not supported in Mesa yet
+#dependentvector	params 4 pname GL_TEXTURE_CROP_RECT_OES
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+# GLES1.1 and GLES2.0 have different capabilities
+name		IsEnabled
+return		GLboolean
+param		cap		GLenum
+props           get
+checkparam      cap             GL_VERTEX_ARRAY GL_NORMAL_ARRAY GL_COLOR_ARRAY GL_TEXTURE_COORD_ARRAY GL_NORMALIZE GL_RESCALE_NORMAL GL_CLIP_PLANE0 GL_CLIP_PLANE1 GL_CLIP_PLANE2 GL_CLIP_PLANE3 GL_CLIP_PLANE4 GL_CLIP_PLANE5 GL_FOG GL_LIGHTING GL_COLOR_MATERIAL GL_LIGHT0 GL_LIGHT1 GL_LIGHT2 GL_LIGHT3 GL_LIGHT4 GL_LIGHT5 GL_LIGHT6 GL_LIGHT7 GL_POINT_SMOOTH GL_LINE_SMOOTH GL_CULL_FACE GL_POLYGON_OFFSET_FILL GL_MULTISAMPLE GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_ALPHA_TO_ONE GL_SAMPLE_COVERAGE GL_TEXTURE_2D GL_SCISSOR_TEST GL_ALPHA_TEST GL_STENCIL_TEST GL_DEPTH_TEST GL_BLEND GL_DITHER GL_COLOR_LOGIC_OP
+# OES_matrix_palette
+checkparam      cap             GL_MATRIX_INDEX_ARRAY_OES GL_WEIGHT_ARRAY_OES
+# OES_point_size_array
+checkparam      cap             GL_POINT_SIZE_ARRAY_OES
+# OES_point_sprite
+checkparam      cap             GL_POINT_SPRITE_OES
+# OES_texture_cube_map
+checkparam      cap             GL_TEXTURE_CUBE_MAP_OES GL_TEXTURE_GEN_STR_OES
+category	GLES1.1
+
+name		IsEnabled
+return		GLboolean
+param		cap		GLenum
+checkparam      cap             GL_CULL_FACE GL_SCISSOR_TEST GL_POLYGON_OFFSET_FILL GL_SAMPLE_ALPHA_TO_COVERAGE GL_SAMPLE_COVERAGE GL_STENCIL_TEST GL_DEPTH_TEST GL_DITHER GL_BLEND
+props		get
+category	GLES2.0
+
+
+name		DepthRangef
+return		void
+param		zNear		GLclampf
+param		zFar		GLclampf
+convertalias	DepthRange
+convertparams	GLclampd        zNear zFar
+category	GLES1.1 GLES1.1:OES_single_precision GLES2.0
+
+name		DepthRangex
+return		void
+param		zNear		GLclampx
+param		zFar		GLclampx
+convertalias	DepthRange
+convertparams	GLclampd        zNear zFar
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Frustumf
+return		void
+param		left		GLfloat
+param		right		GLfloat
+param		bottom		GLfloat
+param		top		GLfloat
+param		zNear		GLfloat
+param		zFar		GLfloat
+convertalias	Frustum
+convertparams	GLdouble        left right bottom top zNear zFar
+category	GLES1.1 GLES1.1:OES_single_precision
+
+name		Frustumx
+return		void
+param		left		GLfixed
+param		right		GLfixed
+param		bottom		GLfixed
+param		top		GLfixed
+param		zNear		GLfixed
+param		zFar		GLfixed
+convertalias	Frustum
+convertparams	GLdouble        left right bottom top zNear zFar
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		LoadIdentity
+return		void
+category	1.0 GLES1.1
+
+name		LoadMatrixf
+return		void
+param		m		const GLfloat *
+vector		m		16
+category	1.0 GLES1.1
+
+name		LoadMatrixx
+return		void
+param		m		const GLfixed *
+vector		m		16
+convertalias	LoadMatrixf
+convertparams	GLfloat         m
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		MatrixMode
+return		void
+param		mode		GLenum
+checkparam	mode		GL_MODELVIEW GL_PROJECTION GL_TEXTURE
+# OES_matrix_palette
+checkparam      mode            GL_MATRIX_PALETTE_OES
+category	1.0 GLES1.1
+
+name		MultMatrixf
+return		void
+param		m		const GLfloat *
+vector		m		16
+category	1.0 GLES1.1
+
+name		MultMatrixx
+return		void
+param		m		const GLfixed *
+vector		m		16
+convertalias	MultMatrixf
+convertparams	GLfloat         m
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Orthof
+return		void
+param		left		GLfloat
+param		right		GLfloat
+param		bottom		GLfloat
+param		top		GLfloat
+param		zNear		GLfloat
+param		zFar		GLfloat
+convertalias	Ortho
+convertparams	GLdouble        left right bottom top zNear zFar
+category	GLES1.1 GLES1.1:OES_single_precision
+
+name		Orthox
+return		void
+param		left		GLfixed
+param		right		GLfixed
+param		bottom		GLfixed
+param		top		GLfixed
+param		zNear		GLfixed
+param		zFar		GLfixed
+convertalias	Ortho
+convertparams	GLdouble        left right bottom top zNear zFar
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name            PopMatrix
+return          void
+category        GLES1.1
+
+name            PushMatrix
+return          void
+category        GLES1.1
+
+name		Rotatef
+return		void
+param		angle		GLfloat
+param		x		GLfloat
+param		y		GLfloat
+param		z		GLfloat
+category	1.0 GLES1.1
+
+name		Rotatex
+return		void
+param		angle		GLfixed
+param		x		GLfixed
+param		y		GLfixed
+param		z		GLfixed
+convertalias	Rotatef
+convertparams	GLfloat         angle x y z
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Scalef
+return		void
+param		x		GLfloat
+param		y		GLfloat
+param		z		GLfloat
+category	1.0 GLES1.1
+
+name		Scalex
+return		void
+param		x		GLfixed
+param		y		GLfixed
+param		z		GLfixed
+convertalias	Scalef
+convertparams	GLfloat         x y z
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Translatef
+return		void
+param		x		GLfloat
+param		y		GLfloat
+param		z		GLfloat
+category	1.0 GLES1.1
+
+name		Translatex
+return		void
+param		x		GLfixed
+param		y		GLfixed
+param		z		GLfixed
+convertalias	Translatef
+convertparams	GLfloat         x y z
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		Viewport
+return		void
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+category	1.0 GLES1.1 GLES2.0
+
+name		ColorPointer
+return		void
+param		size		GLint
+param		type		GLenum
+param		stride		GLsizei
+paramlist	stride		0
+param		pointer		const GLvoid *
+checkparam      size            /GL_INVALID_VALUE 4
+checkparam      type            GL_UNSIGNED_BYTE GL_FIXED GL_FLOAT
+# OES_vertex_half_float: its values aren't in glext.h yet
+#checkparam	type		GL_HALF_FLOAT_OES
+category	1.1 GLES1.1
+
+name		DisableClientState
+return		void
+param		array		GLenum
+checkparam	array		GL_COLOR_ARRAY GL_NORMAL_ARRAY GL_TEXTURE_COORD_ARRAY GL_VERTEX_ARRAY
+# OES_matrix_palette
+checkparam      array GL_MATRIX_INDEX_ARRAY_OES GL_WEIGHT_ARRAY_OES
+# OES_point_size_array
+checkparam      array           GL_POINT_SIZE_ARRAY_OES
+category	1.1 GLES1.1
+
+name		DrawArrays
+return		void
+param		mode		GLenum
+checkparam	mode		GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES
+param		first		GLint
+param		count		GLsizei
+category	1.1 GLES1.1 GLES2.0
+
+name		DrawElements
+return		void
+param		mode		GLenum
+checkparam	mode		GL_POINTS GL_LINE_STRIP GL_LINE_LOOP GL_LINES GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES
+param		count		GLsizei
+param		type		GLenum
+checkparam	type		GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT 
+param		indices		const GLvoid *
+# OES_element_index_uint - not in GLES1.1 extension headers yet
+checkparam	type		GLES2.0:GL_UNSIGNED_INT
+category	1.1 GLES1.1 GLES2.0
+
+name		EnableClientState
+return		void
+param		array		GLenum
+checkparam	array		GL_COLOR_ARRAY GL_NORMAL_ARRAY GL_TEXTURE_COORD_ARRAY GL_VERTEX_ARRAY
+# OES_matrix_palette
+checkparam      array GL_MATRIX_INDEX_ARRAY_OES GL_WEIGHT_ARRAY_OES
+# OES_point_size_array
+checkparam      array           GL_POINT_SIZE_ARRAY_OES
+category	1.1 GLES1.1
+
+name		GetPointerv
+return		void
+param		pname		GLenum
+checkparam	pname		GL_COLOR_ARRAY_POINTER GL_NORMAL_ARRAY_POINTER GL_TEXTURE_COORD_ARRAY_POINTER GL_VERTEX_ARRAY_POINTER
+param		params		GLvoid **
+props		get
+# OES_matrix_palette
+checkparam      pname           GL_MATRIX_INDEX_ARRAY_POINTER_OES GL_WEIGHT_ARRAY_POINTER_OES
+# OES_point_size_array
+checkparam      pname           GL_POINT_SIZE_ARRAY_POINTER_OES
+category	1.1 GLES1.1
+
+name		Normal3f
+aliasprefix	_vbo_
+return		void
+param		nx		GLfloat
+param		ny		GLfloat
+param		nz		GLfloat
+category	GLES1.1
+
+name		Normal3x
+aliasprefix	_vbo_
+return		void
+param		nx		GLfixed
+param		ny		GLfixed
+param		nz		GLfixed
+convertalias	Normal3f
+convertparams	GLfloat         nx ny nz
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		NormalPointer
+return		void
+param		type		GLenum
+checkparam	type		GL_BYTE GL_SHORT GL_FIXED GL_FLOAT
+param		stride		GLsizei
+param		pointer		const GLvoid *
+# OES_vertex_half_float - not yet in glext.h
+#checkparam	type		GL_HALF_FLOAT_OES
+category	1.1 GLES1.1
+
+name		TexCoordPointer
+return		void
+param		size		GLint
+param		type		GLenum
+param		stride		GLsizei
+param		pointer		const GLvoid *
+checkparam      size            /GL_INVALID_VALUE 2 3 4
+checkparam	type		GL_BYTE GL_SHORT GL_FIXED GL_FLOAT
+# OES_vertex_half_float - not yet in glext.h
+#checkparam	type		GL_HALF_FLOAT_OES
+category	1.1 GLES1.1
+
+name		VertexPointer
+return		void
+param		size		GLint
+param		type		GLenum
+param		stride		GLsizei
+param		pointer		const GLvoid *
+checkparam      size  /GL_INVALID_VALUE 2 3 4
+checkparam	type		GL_BYTE GL_SHORT GL_FIXED GL_FLOAT
+# OES_vertex_half_float - not yet in glext.h
+#checkparam	type		GL_HALF_FLOAT_OES
+category	1.1 GLES1.1
+
+name		PolygonOffset
+return		void
+param		factor		GLfloat
+param		units		GLfloat
+category	1.1 GLES1.1 GLES2.0
+
+name		PolygonOffsetx
+return		void
+param		factor		GLfixed
+param		units		GLfixed
+convertalias	PolygonOffset
+convertparams	GLfloat         factor units
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		CopyTexImage2D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+param		level		GLint
+param		internalFormat	GLenum
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		border		GLint
+checkparam      internalFormat /GL_INVALID_VALUE GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+checkparam      border         /GL_INVALID_VALUE 0
+# OES_texture_cube_map
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+# OES_depth_texture
+checkparam     internalFormat   GLES2.0:GL_DEPTH_COMPONENT
+category	GLES1.1 GLES2.0
+
+name		CopyTexSubImage2D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+# OES_texture_cube_map
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+category	GLES1.1 GLES2.0
+
+name		TexSubImage2D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		format		GLenum
+param		type		GLenum
+param		pixels		const GLvoid *
+checkparam      format /GL_INVALID_VALUE GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+checkdependentparam format GL_RGBA type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_4_4_4_4  GL_UNSIGNED_SHORT_5_5_5_1
+checkdependentparam format GL_RGB type GL_UNSIGNED_BYTE GL_UNSIGNED_SHORT_5_6_5
+checkdependentparam format GL_LUMINANCE_ALPHA type GL_UNSIGNED_BYTE
+checkdependentparam format GL_LUMINANCE type GL_UNSIGNED_BYTE
+checkdependentparam format GL_ALPHA type GL_UNSIGNED_BYTE
+# OES_texture_cube_map
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+# OES_texture_float
+checkdependentparam format GL_ALPHA type GL_FLOAT
+checkdependentparam format GL_RGB type GL_FLOAT
+checkdependentparam format GL_RGBA type GL_FLOAT
+checkdependentparam format GL_LUMINANCE type GL_FLOAT
+checkdependentparam format GL_LUMINANCE_ALPHA type GL_FLOAT
+# OES_texture_half_float
+checkdependentparam format GL_ALPHA type GLES2.0:GL_HALF_FLOAT_OES
+checkdependentparam format GL_RGB type GLES2.0:GL_HALF_FLOAT_OES
+checkdependentparam format GL_RGBA type GLES2.0:GL_HALF_FLOAT_OES
+checkdependentparam format GL_LUMINANCE type GLES2.0:GL_HALF_FLOAT_OES
+checkdependentparam format GL_LUMINANCE_ALPHA type GLES2.0:GL_HALF_FLOAT_OES
+# EXT_texture_type_2_10_10_10_REV
+checkdependentparam format GL_RGBA type GLES2.0:GL_UNSIGNED_INT_2_10_10_10_REV_EXT
+# OES_depth_texture
+checkdependentparam format GL_DEPTH_COMPONENT type GLES2.0:GL_UNSIGNED_SHORT GLES2.0:GL_UNSIGNED_INT
+category	GLES1.1 GLES2.0
+
+name		BindTexture
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+param		texture		GLuint
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+category	GLES1.1 GLES2.0
+
+name		DeleteTextures
+return		void
+param		n		GLsizei
+param		textures	const GLuint *
+category	1.1 GLES1.1 GLES2.0
+
+name		GenTextures
+return		void
+param		n		GLsizei
+param		textures	GLuint *
+props		get
+category	1.1 GLES1.1 GLES2.0
+
+name		IsTexture
+return		GLboolean
+param		texture		GLuint
+props		get
+category	1.1 GLES1.1 GLES2.0
+
+name		BlendColor
+return		void
+param		red		GLclampf
+param		green		GLclampf
+param		blue		GLclampf
+param		alpha		GLclampf
+category	1.2 GLES2.0
+
+name		BlendEquation
+return		void
+param		mode		GLenum
+checkparam	mode		GLES1.1:GL_FUNC_ADD_OES GLES1.1:GL_FUNC_SUBTRACT_OES GLES1.1:GL_FUNC_REVERSE_SUBTRACT_OES
+checkparam	mode		GLES2.0:GL_FUNC_ADD GLES2.0:GL_FUNC_SUBTRACT GLES2.0:GL_FUNC_REVERSE_SUBTRACT
+category	GLES1.1:OES_blend_subtract GLES2.0
+
+name            BlendEquationSeparate
+alias		BlendEquationSeparateEXT
+return          void
+param           modeRGB         GLenum
+param           modeAlpha       GLenum
+checkparam	modeRGB GLES1.1:GL_FUNC_ADD_OES GLES1.1:GL_FUNC_SUBTRACT_OES GLES1.1:GL_FUNC_REVERSE_SUBTRACT_OES
+checkparam	modeAlpha GLES1.1:GL_FUNC_ADD_OES GLES1.1:GL_FUNC_SUBTRACT_OES GLES1.1:GL_FUNC_REVERSE_SUBTRACT_OES
+checkparam	modeRGB GLES1.1:GL_FUNC_ADD_OES GLES1.1:GL_FUNC_SUBTRACT_OES GLES1.1:GL_FUNC_REVERSE_SUBTRACT_OES
+checkparam	modeAlpha GLES1.1:GL_FUNC_ADD_OES GLES1.1:GL_FUNC_SUBTRACT_OES GLES1.1:GL_FUNC_REVERSE_SUBTRACT_OES
+checkparam	modeRGB GLES2.0:GL_FUNC_ADD GLES2.0:GL_FUNC_SUBTRACT GLES2.0:GL_FUNC_REVERSE_SUBTRACT
+checkparam	modeAlpha GLES2.0:GL_FUNC_ADD GLES2.0:GL_FUNC_SUBTRACT GLES2.0:GL_FUNC_REVERSE_SUBTRACT
+checkparam	modeRGB GLES2.0:GL_FUNC_ADD GLES2.0:GL_FUNC_SUBTRACT GLES2.0:GL_FUNC_REVERSE_SUBTRACT
+checkparam	modeAlpha GLES2.0:GL_FUNC_ADD GLES2.0:GL_FUNC_SUBTRACT GLES2.0:GL_FUNC_REVERSE_SUBTRACT
+category        GLES1.1:OES_blend_equation_separate GLES2.0
+
+name		TexImage3D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_3D_OES
+param		level		GLint
+param		internalFormat	GLenum
+checkparam      internalFormat  GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+param		width		GLsizei
+param		height		GLsizei
+param		depth		GLsizei
+param		border		GLint
+param		format		GLenum
+param		type		GLenum
+param		pixels		const GLvoid *
+# OES_texture_float
+checkparam    type            GL_FLOAT
+# OES_texture_half_float
+checkparam    type            GL_HALF_FLOAT_OES
+category	GLES2.0:OES_texture_3D
+
+name		TexSubImage3D
+return		void
+param		target		GLenum
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		zoffset		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		depth		GLsizei
+param		format		GLenum
+param		type		GLenum
+param		pixels		const GLvoid *
+# OES_texture_float
+checkparam    type            GL_FLOAT
+# OES_texture_half_float
+checkparam    type            GL_HALF_FLOAT_OES
+category	GLES2.0:OES_texture_3D
+
+name		CopyTexSubImage3D
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_3D_OES
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		zoffset		GLint
+param		x		GLint
+param		y		GLint
+param		width		GLsizei
+param		height		GLsizei
+category	GLES2.0:OES_texture_3D
+
+name		MultiTexCoord4x
+return		void
+param		texture		GLenum
+checkparam	texture		GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7
+param		s		GLfixed
+param		t		GLfixed
+param		r		GLfixed
+param		q		GLfixed
+aliasprefix	_vbo_
+convertalias	MultiTexCoord4f
+convertparams	GLfloat         s t r q
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		CompressedTexImage3D
+alias		CompressedTexImage3DARB
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_3D_OES
+param		level		GLint
+param		internalFormat	GLenum
+checkparam      internalFormat  GL_ALPHA GL_LUMINANCE GL_LUMINANCE_ALPHA GL_RGB GL_RGBA
+param		width		GLsizei
+param		height		GLsizei
+param		depth		GLsizei
+param		border		GLint
+param		imagesize	GLsizei
+param		data		const GLvoid *
+# AMD_compressed_3DC_texture
+checkparam      internalFormat  GL_3DC_X_AMD GL_3DC_XY_AMD
+# AMD_compressed_ATC_texture
+checkparam      internalFormat  GL_ATC_RGB_AMD GL_ATC_RGBA_EXPLICIT_ALPHA_AMD GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD
+category	GLES2.0:OES_texture_3D
+
+name		CompressedTexSubImage3D
+alias		CompressedTexSubImage3DARB
+return		void
+param		target		GLenum
+checkparam	target		GL_TEXTURE_3D_OES
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		zoffset		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		depth		GLsizei
+param		format		GLenum
+param		imagesize	GLsizei
+param		data		const GLvoid *
+category	GLES2.0:OES_texture_3D
+
+name		ActiveTexture
+alias		ActiveTextureARB
+return		void
+param		texture		GLenum
+checkparam	texture		GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.3 GLES1.1 GLES2.0
+
+name		ClientActiveTexture
+alias		ClientActiveTextureARB
+return		void
+param		texture		GLenum
+checkparam	texture		GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+category	1.3 GLES1.1
+
+name		MultiTexCoord4f
+aliasprefix	_vbo_
+return		void
+param		texture		GLenum
+checkparam	texture		GL_TEXTURE0 GL_TEXTURE1 GL_TEXTURE2 GL_TEXTURE3 GL_TEXTURE4 GL_TEXTURE5 GL_TEXTURE6 GL_TEXTURE7 GL_TEXTURE8 GL_TEXTURE9 GL_TEXTURE10 GL_TEXTURE11 GL_TEXTURE12 GL_TEXTURE13 GL_TEXTURE14 GL_TEXTURE15 GL_TEXTURE16 GL_TEXTURE17 GL_TEXTURE18 GL_TEXTURE19 GL_TEXTURE20 GL_TEXTURE21 GL_TEXTURE22 GL_TEXTURE23 GL_TEXTURE24 GL_TEXTURE25 GL_TEXTURE26 GL_TEXTURE27 GL_TEXTURE28 GL_TEXTURE29 GL_TEXTURE30 GL_TEXTURE31
+param		s		GLfloat
+param		t		GLfloat
+param		r		GLfloat
+param		q		GLfloat
+category	1.3 GLES1.1
+
+name		SampleCoverage
+alias		SampleCoverageARB
+return		void
+param		value		GLclampf
+param		invert		GLboolean
+category	1.3 GLES1.1 GLES2.0
+
+name		SampleCoveragex
+return		void
+param		value		GLclampx
+param		invert		GLboolean
+convertalias	SampleCoverageARB
+convertparams	GLclampf        value
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		CompressedTexImage2D
+alias		CompressedTexImage2DARB
+return		void
+param		target		GLenum
+param		level		GLint
+param		internalFormat	GLenum
+param		width		GLsizei
+param		height		GLsizei
+param		border		GLint
+param		imageSize	GLsizei
+param		data		const GLvoid *
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+checkparam      border         /GL_INVALID_VALUE 0
+# OES_texture_cube_map
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+# OES_compressed_paletted_texture
+checkparam	internalFormat	/GL_INVALID_VALUE GL_PALETTE4_RGB8_OES GL_PALETTE4_RGBA8_OES GL_PALETTE4_R5_G6_B5_OES GL_PALETTE4_RGBA4_OES GL_PALETTE4_RGB5_A1_OES GL_PALETTE8_RGB8_OES GL_PALETTE8_RGBA8_OES GL_PALETTE8_R5_G6_B5_OES GL_PALETTE8_RGBA4_OES GL_PALETTE8_RGB5_A1_OES
+# OES_compressed_ETC1_RGB8_texture
+checkparam      internalFormat  GL_ETC1_RGB8_OES
+# AMD_compressed_3DC_texture
+checkparam      internalFormat  GL_3DC_X_AMD GL_3DC_XY_AMD
+# AMD_compressed_ATC_texture (GLES2.0 only?)
+checkparam      internalFormat  GL_ATC_RGB_AMD GL_ATC_RGBA_EXPLICIT_ALPHA_AMD GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD
+category	GLES1.1 GLES2.0
+
+name		CompressedTexSubImage2D
+alias		CompressedTexSubImage2DARB
+return		void
+param		target		GLenum
+param		level		GLint
+param		xoffset		GLint
+param		yoffset		GLint
+param		width		GLsizei
+param		height		GLsizei
+param		format		GLenum
+param		imageSize	GLsizei
+param		data		const GLvoid *
+checkparam	target		GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+checkparam	format	GL_PALETTE4_RGB8_OES GL_PALETTE4_RGBA8_OES GL_PALETTE4_R5_G6_B5_OES GL_PALETTE4_RGBA4_OES GL_PALETTE4_RGB5_A1_OES GL_PALETTE8_RGB8_OES GL_PALETTE8_RGBA8_OES GL_PALETTE8_R5_G6_B5_OES GL_PALETTE8_RGBA4_OES GL_PALETTE8_RGB5_A1_OES
+# OES_texture_cube_map
+checkparam	target		GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+category	GLES1.1 GLES2.0
+
+name		BlendFuncSeparate
+alias		BlendFuncSeparateEXT
+return		void
+param		srcRGB	GLenum
+param		dstRGB	GLenum
+param		srcAlpha	GLenum
+param		dstAlpha	GLenum
+checkparam      srcRGB      GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_DST_COLOR GL_ONE_MINUS_DST_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_ALPHA GL_ONE_MINUS_DST_ALPHA GL_SRC_ALPHA_SATURATE GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+checkparam      dstRGB      GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_DST_COLOR GL_ONE_MINUS_DST_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_ALPHA GL_ONE_MINUS_DST_ALPHA  GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+checkparam      srcAlpha    GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_DST_COLOR GL_ONE_MINUS_DST_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_ALPHA GL_ONE_MINUS_DST_ALPHA GL_SRC_ALPHA_SATURATE GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+checkparam      dstAlpha    GL_ZERO GL_ONE GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR GL_DST_COLOR GL_ONE_MINUS_DST_COLOR GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA GL_DST_ALPHA GL_ONE_MINUS_DST_ALPHA GLES2.0:GL_CONSTANT_COLOR GLES2.0:GL_ONE_MINUS_CONSTANT_COLOR GLES2.0:GL_CONSTANT_ALPHA GLES2.0:GL_ONE_MINUS_CONSTANT_ALPHA
+category	GLES1.1:OES_blend_func_separate GLES2.0
+
+name		PointParameterf
+return		void
+param		pname		GLenum
+checkparam	pname		GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE
+param		param		GLfloat
+category	1.4 GLES1.1
+
+name		PointParameterfv
+return		void
+param		pname		GLenum
+checkparam	pname		GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE GL_POINT_DISTANCE_ATTENUATION
+param		params		const GLfloat *
+dependentvector	params 1 pname GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE
+dependentvector params 3 pname GL_POINT_DISTANCE_ATTENUATION
+category	1.4 GLES1.1
+
+name		PointParameterx
+return		void
+param		pname		GLenum
+checkparam	pname		GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE
+param		param		GLfixed
+convertalias	PointParameterf
+convertparams	GLfloat         param
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name		PointParameterxv
+return		void
+param		pname		GLenum
+checkparam	pname		GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE GL_POINT_DISTANCE_ATTENUATION
+param		params		const GLfixed *
+dependentvector	params 1 pname GL_POINT_SIZE_MIN GL_POINT_SIZE_MAX GL_POINT_FADE_THRESHOLD_SIZE
+dependentvector params 3 pname GL_POINT_DISTANCE_ATTENUATION
+convertalias	PointParameterfv
+convertparams	GLfloat         params
+category	GLES1.1 GLES1.1:OES_fixed_point
+
+name            VertexAttrib1f
+return		void
+param		index		GLuint
+param		x		GLfloat
+category	GLES2.0
+
+name		VertexAttrib2f
+return		void
+param		index		GLuint
+param		x		GLfloat
+param		y		GLfloat
+category	GLES2.0
+
+name		VertexAttrib3f
+return		void
+param		index		GLuint
+param		x		GLfloat
+param		y		GLfloat
+param		z		GLfloat
+category	GLES2.0
+
+name		VertexAttrib4f
+return		void
+param		index		GLuint
+param		x		GLfloat
+param		y		GLfloat
+param		z		GLfloat
+param		w		GLfloat
+category	GLES2.0
+
+name		VertexAttrib1fv
+return		void
+param		index		GLuint
+param		v		const GLfloat *
+vector		v		1
+category	GLES2.0
+
+name		VertexAttrib2fv
+return		void
+param		index		GLuint
+param		v		const GLfloat *
+vector		v		2
+category	GLES2.0
+
+name		VertexAttrib3fv
+return		void
+param		index		GLuint
+param		v		const GLfloat *
+vector		v		3
+category	GLES2.0
+
+name		VertexAttrib4fv
+return		void
+param		index		GLuint
+param		v		const GLfloat *
+vector		v		4
+category	GLES2.0
+
+name		VertexAttribPointer
+alias		VertexAttribPointerARB
+return		void
+param		index		GLuint
+param		size		GLint
+checkparam      size            /GL_INVALID_VALUE 1 2 3 4
+param		type		GLenum
+checkparam	type		/GL_INVALID_VALUE GL_BYTE GL_UNSIGNED_BYTE GL_SHORT GL_UNSIGNED_SHORT GL_FIXED GL_FLOAT
+param		normalized	GLboolean
+param		stride		GLsizei
+param		pointer		const GLvoid *
+# OES_vertex_half_float
+checkparam	type		GL_HALF_FLOAT_OES
+# OES_vertex_type_10_10_10_2
+checkdependentparam type GL_UNSIGNED_INT_10_10_10_2_OES size /GL_INVALID_VALUE 3 4
+checkdependentparam type GL_INT_10_10_10_2_OES size /GL_INVALID_VALUE 3 4
+category	GLES2.0
+
+name		EnableVertexAttribArray
+alias		EnableVertexAttribArrayARB
+return		void
+param		index		GLuint
+category	GLES2.0
+
+name		DisableVertexAttribArray
+alias		DisableVertexAttribArrayARB
+return		void
+param		index		GLuint
+category	GLES2.0
+
+name		IsProgram
+return		GLboolean
+param		program		GLuint
+props		get
+category	GLES2.0
+
+name		GetProgramiv
+return		void
+param		program         GLuint
+param		pname		GLenum
+checkparam      pname           GL_DELETE_STATUS GL_LINK_STATUS GL_VALIDATE_STATUS GL_INFO_LOG_LENGTH GL_ATTACHED_SHADERS GL_ACTIVE_ATTRIBUTES GL_ACTIVE_ATTRIBUTE_MAX_LENGTH GL_ACTIVE_UNIFORMS GL_ACTIVE_UNIFORM_MAX_LENGTH
+param		params		GLint *
+props		get
+# OES_get_program_binary
+checkparam      pname           GL_PROGRAM_BINARY_LENGTH_OES
+category	GLES2.0
+
+name		GetVertexAttribfv
+alias		GetVertexAttribfvARB
+return		void
+param		index		GLuint
+param		pname		GLenum
+param		params		GLfloat *
+dependentvector params 1 pname GL_VERTEX_ATTRIB_ARRAY_ENABLED GL_VERTEX_ATTRIB_ARRAY_SIZE GL_VERTEX_ATTRIB_ARRAY_STRIDE GL_VERTEX_ATTRIB_ARRAY_TYPE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 
+dependentvector params 16? pname GL_CURRENT_VERTEX_ATTRIB
+props		get
+category	GLES2.0
+
+name		GetVertexAttribiv
+alias		GetVertexAttribivARB
+return		void
+param		index		GLuint
+param		pname		GLenum
+param		params		GLint *
+dependentvector params 1 pname GL_VERTEX_ATTRIB_ARRAY_ENABLED GL_VERTEX_ATTRIB_ARRAY_SIZE GL_VERTEX_ATTRIB_ARRAY_STRIDE GL_VERTEX_ATTRIB_ARRAY_TYPE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING GL_CURRENT_VERTEX_ATTRIB
+props		get
+category	GLES2.0
+
+name		GetVertexAttribPointerv
+alias		GetVertexAttribPointervARB
+return		void
+param		index		GLuint
+param		pname		GLenum
+checkparam	pname		GL_VERTEX_ATTRIB_ARRAY_POINTER
+param		pointer		GLvoid **
+props		get
+category	GLES2.0
+
+name		GetBufferPointerv
+alias		GetBufferPointervARB
+return		void
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		pname		GLenum
+checkparam	pname		GL_BUFFER_MAP_POINTER_OES
+param		params		GLvoid **
+props		get 
+category	GLES1.1:OES_mapbuffer GLES2.0:OES_mapbuffer
+
+name		MapBuffer
+alias		MapBufferARB
+return		void *
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		access		GLenum
+checkparam      access          GL_WRITE_ONLY_OES
+props		get
+category	GLES1.1:OES_mapbuffer GLES2.0:OES_mapbuffer
+
+name		UnmapBuffer
+alias		UnmapBufferARB
+return		GLboolean
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+props		get
+category	GLES1.1:OES_mapbuffer GLES2.0:OES_mapbuffer
+
+name		BindBuffer
+alias		BindBufferARB
+return		void
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		buffer		GLuint
+category	1.5 GLES1.1 GLES2.0
+
+name		BufferData
+alias		BufferDataARB
+return		void
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		size		GLsizeiptr
+param		data		const GLvoid *
+param		usage		GLenum
+checkparam	usage		GL_STATIC_DRAW GL_DYNAMIC_DRAW GLES2.0:GL_STREAM_DRAW
+category	GLES1.1 GLES2.0
+
+name		BufferSubData
+alias		BufferSubDataARB
+return		void
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		offset		GLintptr
+param		size		GLsizeiptr
+param		data		const GLvoid *
+category	1.5 GLES1.1 GLES2.0
+
+name		DeleteBuffers
+return		void
+param		n		GLsizei
+param		buffer		const GLuint *
+category	1.5 GLES1.1 GLES2.0
+alias		DeleteBuffersARB
+
+name		GenBuffers
+alias		GenBuffersARB
+return		void
+param		n		GLsizei
+param		buffer		GLuint *
+props		get
+category	1.5 GLES1.1 GLES2.0
+
+name		GetBufferParameteriv
+alias		GetBufferParameterivARB
+return		void
+param		target		GLenum
+checkparam	target		GL_ARRAY_BUFFER GL_ELEMENT_ARRAY_BUFFER
+param		pname		GLenum
+checkparam	pname		GL_BUFFER_SIZE GL_BUFFER_USAGE
+param		params		GLint *
+props		get
+# OES_mapbuffer
+checkparam      pname           GL_BUFFER_ACCESS_OES GL_BUFFER_MAPPED_OES
+category	1.5 GLES1.1 GLES2.0
+
+name		IsBuffer
+alias		IsBufferARB
+return		GLboolean
+param		buffer		GLuint
+paramlist	buffer		0
+props		get
+category	1.5 GLES1.1 GLES2.0
+
+name		CreateShader
+return		GLuint
+param		type		GLenum
+checkparam	type		GL_VERTEX_SHADER GL_FRAGMENT_SHADER
+category	GLES2.0
+
+name            ShaderSource
+alias		ShaderSourceARB
+return          void
+param           shader          GLuint
+param           count           GLsizei
+param           string          const GLchar **
+param           length          const int *
+category        GLES2.0
+
+name            CompileShader
+alias		CompileShaderARB
+return          void
+param           shader          GLuint
+category        GLES2.0
+
+name            ReleaseShaderCompiler
+return          void
+category        GLES2.0
+
+name            DeleteShader
+return          void
+param           shader          GLuint
+category        GLES2.0
+
+name            ShaderBinary
+return          void
+param           n               GLsizei
+param           shaders         const GLuint *
+param           binaryformat    GLenum
+param           binary          const GLvoid *
+param           length          GLsizei
+category        GLES2.0
+
+name            CreateProgram
+return          GLuint
+category        GLES2.0
+
+name            AttachShader
+return          void
+param           program         GLuint
+param           shader          GLuint
+category        GLES2.0
+
+name            DetachShader
+return          void
+param           program         GLuint
+param           shader          GLuint
+category        GLES2.0
+
+name            LinkProgram
+alias		LinkProgramARB
+return          void
+param           program         GLuint
+category        GLES2.0
+
+name            UseProgram
+alias		UseProgramObjectARB
+return          void
+param           program         GLuint
+category        GLES2.0
+
+name            DeleteProgram
+return          void
+param           program         GLuint
+category        GLES2.0
+
+name            GetActiveAttrib
+alias		GetActiveAttribARB
+return          void
+param           program         GLuint
+param           index           GLuint
+param           bufSize         GLsizei
+param           length          GLsizei *
+param           size            GLint *
+param           type            GLenum *
+param           name            GLchar *
+props get
+category        GLES2.0
+
+name            GetAttribLocation
+alias		GetAttribLocationARB
+return          GLint
+param           program         GLuint
+param           name            const char *
+props get
+category        GLES2.0
+
+name            BindAttribLocation
+alias		BindAttribLocationARB
+return          void
+param           program         GLuint
+param           index           GLuint
+param           name            const char *
+category        GLES2.0
+
+name            GetUniformLocation
+alias		GetUniformLocationARB
+return          GLint
+param           program         GLuint
+param           name            const char *
+props           get
+category        GLES2.0
+
+name            GetActiveUniform
+alias		GetActiveUniformARB
+return          void
+param           program         GLuint
+param           index           GLuint
+param           bufSize         GLsizei
+param           length          GLsizei *
+param           size            GLint *
+param           type            GLenum *
+param           name            GLchar *
+props           get
+category        GLES2.0
+
+name            Uniform1f
+alias		Uniform1fARB
+return          void
+param           location        GLint
+param           v0              GLfloat
+category        GLES2.0
+
+name            Uniform2f
+alias		Uniform2fARB
+return          void
+return          void
+param           location        GLint
+param           v0              GLfloat
+param           v1              GLfloat
+category        GLES2.0
+
+name            Uniform3f
+alias		Uniform3fARB
+return          void
+return          void
+param           location        GLint
+param           v0              GLfloat
+param           v1              GLfloat
+param           v2              GLfloat
+category        GLES2.0
+
+name            Uniform4f
+alias		Uniform4fARB
+return          void
+return          void
+param           location        GLint
+param           v0              GLfloat
+param           v1              GLfloat
+param           v2              GLfloat
+param           v3              GLfloat
+category        GLES2.0
+
+name            Uniform1i
+alias		Uniform1iARB
+return          void
+param           location        GLint
+param           v0              GLint
+category        GLES2.0
+
+name            Uniform2i
+alias		Uniform2iARB
+return          void
+param           location        GLint
+param           v0              GLint
+param           v1              GLint
+category        GLES2.0
+
+name            Uniform3i
+alias		Uniform3iARB
+return          void
+param           location        GLint
+param           v0              GLint
+param           v1              GLint
+param           v2              GLint
+category        GLES2.0
+
+name            Uniform4i
+alias		Uniform4iARB
+return          void
+param           location        GLint
+param           v0              GLint
+param           v1              GLint
+param           v2              GLint
+param           v3              GLint
+category        GLES2.0
+
+name            Uniform1fv
+alias		Uniform1fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLfloat *
+category        GLES2.0
+
+name            Uniform2fv
+alias		Uniform2fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLfloat *
+category        GLES2.0
+
+name            Uniform3fv
+alias		Uniform3fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLfloat *
+category        GLES2.0
+
+name            Uniform4fv
+alias		Uniform4fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLfloat *
+category        GLES2.0
+
+name            Uniform1iv
+alias           Uniform1ivARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLint *
+category        GLES2.0
+
+name            Uniform2iv
+alias           Uniform2ivARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLint *
+category        GLES2.0
+
+name            Uniform3iv
+alias           Uniform3ivARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLint *
+category        GLES2.0
+
+name            Uniform4iv
+alias           Uniform4ivARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           values          const GLint *
+category        GLES2.0
+
+name            UniformMatrix2fv
+alias           UniformMatrix2fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           transpose       GLboolean
+param           value           const GLfloat *
+category        GLES2.0
+
+name            UniformMatrix3fv
+alias           UniformMatrix3fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           transpose       GLboolean
+param           value           const GLfloat *
+category        GLES2.0
+
+name            UniformMatrix4fv
+alias           UniformMatrix4fvARB
+return          void
+param           location        GLint
+param           count           GLsizei
+param           transpose       GLboolean
+param           value           const GLfloat *
+category        GLES2.0
+
+name            ValidateProgram
+alias           ValidateProgramARB
+return          void
+param           program         GLuint
+category        GLES2.0
+
+name            GenerateMipmap
+alias           GenerateMipmapEXT
+return          void
+param           target          GLenum
+checkparam      target          GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP
+# OES_texture_cube_map
+checkparam      target          GLES1.1:GL_TEXTURE_CUBE_MAP_OES
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+
+name            BindFramebuffer
+alias           BindFramebufferEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_FRAMEBUFFER_OES GLES2.0:GL_FRAMEBUFFER
+param           framebuffer     GLuint
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            DeleteFramebuffers
+alias           DeleteFramebuffersEXT
+return          void
+param           n               GLsizei
+param           framebuffers    const GLuint *
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            GenFramebuffers
+alias           GenFramebuffersEXT
+return          void
+param           n               GLsizei
+param           ids             GLuint *
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            BindRenderbuffer
+alias           BindRenderbufferEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_RENDERBUFFER_OES GLES2.0:GL_RENDERBUFFER
+param           renderbuffer    GLuint
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            DeleteRenderbuffers
+alias           DeleteRenderbuffersEXT
+return          void
+param           n               GLsizei
+param           renderbuffers   const GLuint *
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            GenRenderbuffers
+alias           GenRenderbuffersEXT
+return          void
+param           n               GLsizei
+param           renderbuffers   GLuint *
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            RenderbufferStorage
+alias           RenderbufferStorageEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_RENDERBUFFER_OES GLES2.0:GL_RENDERBUFFER
+param           internalFormat  GLenum
+checkparam      internalFormat  GL_DEPTH_COMPONENT16_OES GL_RGBA4_OES GL_RGB5_A1_OES GL_RGB565_OES
+param           width           GLsizei
+param           height          GLsizei
+# OES_depth24
+checkparam      internalFormat  GL_DEPTH_COMPONENT24_OES
+# OES_depth32
+checkparam      internalFormat  GL_DEPTH_COMPONENT32_OES
+# OES_rgb8_rgba8
+checkparam      internalFormat  GL_RGB8_OES GL_RGBA8_OES
+# OES_stencil1
+checkparam      internalFormat  GL_STENCIL_INDEX1_OES
+# OES_stencil4
+checkparam      internalFormat  GL_STENCIL_INDEX4_OES
+# OES_stencil8
+checkparam      internalFormat  GL_STENCIL_INDEX8_OES
+# OES_packed_depth_stencil - not in glext.h yet
+checkparam      internalFormat  GLES2.0:GL_DEPTH24_STENCIL8_OES
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            FramebufferRenderbuffer
+alias           FramebufferRenderbufferEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_FRAMEBUFFER_OES  GLES2.0:GL_FRAMEBUFFER
+param           attachment      GLenum
+checkparam      attachment      GLES1.1:GL_COLOR_ATTACHMENT0_OES GLES1.1:GL_DEPTH_ATTACHMENT_OES GLES1.1:GL_STENCIL_ATTACHMENT_OES
+checkparam      attachment      GLES2.0:GL_COLOR_ATTACHMENT0 GLES2.0:GL_DEPTH_ATTACHMENT GLES2.0:GL_STENCIL_ATTACHMENT
+param           renderbuffertarget      GLenum
+checkparam      renderbuffertarget      GLES1.1:GL_RENDERBUFFER_OES GLES2.0:GL_RENDERBUFFER
+param           renderbuffer    GLuint
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            FramebufferTexture2D
+alias           FramebufferTexture2DEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_FRAMEBUFFER_OES GLES2.0:GL_FRAMEBUFFER
+param           attachment      GLenum
+checkparam      attachment      GLES1.1:GL_COLOR_ATTACHMENT0_OES GLES1.1:GL_DEPTH_ATTACHMENT_OES GLES1.1:GL_STENCIL_ATTACHMENT_OES
+checkparam      attachment      GLES2.0:GL_COLOR_ATTACHMENT0 GLES2.0:GL_DEPTH_ATTACHMENT GLES2.0:GL_STENCIL_ATTACHMENT
+param           textarget       GLenum
+checkparam      textarget       /GL_INVALID_OPERATION GL_TEXTURE_2D GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_POSITIVE_Z GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_X GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y GLES2.0:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+param           texture         GLuint
+param           level           GLint
+# OES_texture_cube_map
+checkparam      textarget       GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES GLES1.1:GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES
+# According to the base specification, "level" must be 0.  But
+# extension GL_OES_fbo_render_mipmap lifts that restriction,
+# so no restriction is placed here.
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            FramebufferTexture3D
+alias           FramebufferTexture3DEXT
+return          void
+param           target          GLenum
+param           attachment      GLenum
+param           textarget       GLenum
+param           texture         GLuint
+param           level           GLint
+param           zoffset         GLint
+category        GLES2.0:OES_texture_3D
+
+name            CheckFramebufferStatus
+alias           CheckFramebufferStatusEXT
+return          GLenum
+param           target          GLenum
+checkparam      target          GLES1.1:GL_FRAMEBUFFER_OES GLES2.0:GL_FRAMEBUFFER
+props           get
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+# One for GLES1.1 extension, one for GLES2.0 core
+name            GetFramebufferAttachmentParameteriv
+alias           GetFramebufferAttachmentParameterivEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_FRAMEBUFFER_OES GLES2.0:GL_FRAMEBUFFER
+param           attachment      GLenum
+param           pname           GLenum
+param           params          GLint *
+props           get
+dependentvector params 1 pname GLES1.1:GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES GLES1.1:GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES GLES1.1:GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES GLES1.1:GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES 
+dependentvector params 1 pname GLES2.0:GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE GLES2.0:GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME GLES2.0:GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL GLES2.0:GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 
+# OES_texture3D
+dependentvector params 1 pname GLES2.0:GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            GetRenderbufferParameteriv
+alias           GetRenderbufferParameterivEXT
+return          void
+param           target          GLenum
+checkparam      target          GLES1.1:GL_RENDERBUFFER_OES GLES2.0:GL_RENDERBUFFER
+param           pname           GLenum
+param           params          GLint *
+props           get
+dependentvector params 1 pname GLES1.1:GL_RENDERBUFFER_WIDTH_OES GLES1.1:GL_RENDERBUFFER_HEIGHT_OES GLES1.1:GL_RENDERBUFFER_INTERNAL_FORMAT_OES GLES1.1:GL_RENDERBUFFER_RED_SIZE_OES GLES1.1:GL_RENDERBUFFER_GREEN_SIZE_OES GLES1.1:GL_RENDERBUFFER_BLUE_SIZE_OES GLES1.1:GL_RENDERBUFFER_ALPHA_SIZE_OES GLES1.1:GL_RENDERBUFFER_DEPTH_SIZE_OES GLES1.1:GL_RENDERBUFFER_STENCIL_SIZE_OES
+dependentvector params 1 pname GLES2.0:GL_RENDERBUFFER_WIDTH GLES2.0:GL_RENDERBUFFER_HEIGHT GLES2.0:GL_RENDERBUFFER_INTERNAL_FORMAT GLES2.0:GL_RENDERBUFFER_RED_SIZE GLES2.0:GL_RENDERBUFFER_GREEN_SIZE GLES2.0:GL_RENDERBUFFER_BLUE_SIZE GLES2.0:GL_RENDERBUFFER_ALPHA_SIZE GLES2.0:GL_RENDERBUFFER_DEPTH_SIZE GLES2.0:GL_RENDERBUFFER_STENCIL_SIZE
+category        GLES1.1:OES_framebuffer_object GLES2.0
+
+name            IsRenderbuffer
+alias           IsRenderbufferEXT
+return          GLboolean
+param           renderbuffer    GLuint
+props           get
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            IsFramebuffer
+alias           IsFramebufferEXT
+return          GLboolean
+param           framebuffer    GLuint
+props           get
+category        GLES2.0 GLES1.1:OES_framebuffer_object
+
+name            IsShader
+return          GLboolean
+param           shader          GLuint
+props           get
+category        GLES2.0
+
+name            GetShaderiv
+return          void
+param           shader          GLuint
+param           pname           GLenum
+param           params          GLint *
+props           get
+checkparam      pname           GL_SHADER_TYPE GL_COMPILE_STATUS GL_DELETE_STATUS GL_INFO_LOG_LENGTH GL_SHADER_SOURCE_LENGTH
+category        GLES2.0
+
+name            GetAttachedShaders
+return          void
+param           program         GLuint
+param           maxCount        GLsizei
+param           count           GLsizei *
+param           shaders         GLuint *
+props           get
+category        GLES2.0
+
+name            GetShaderInfoLog
+return          void
+param           shader          GLuint
+param           bufSize         GLsizei
+param           length          GLsizei *
+param           infoLog         GLchar *
+props           get
+category        GLES2.0
+
+name            GetProgramInfoLog
+return          void
+param           program         GLuint
+param           bufSize         GLsizei
+param           length          GLsizei *
+param           infoLog         GLchar *
+props           get
+category        GLES2.0
+
+name            GetShaderSource
+alias		GetShaderSourceARB
+return          void
+param           shader          GLuint
+param           bufSize         GLsizei
+param           length          GLsizei *
+param           source          GLchar *
+props           get
+category        GLES2.0
+
+name            GetShaderPrecisionFormat
+return          void
+param           shadertype      GLenum
+param           precisiontype   GLenum
+param           range           GLint *
+param           precision       GLint *
+props           get
+checkparam      shadertype      GL_VERTEX_SHADER GL_FRAGMENT_SHADER
+checkparam      precisiontype   GL_LOW_FLOAT GL_MEDIUM_FLOAT GL_HIGH_FLOAT GL_LOW_INT GL_MEDIUM_INT GL_HIGH_INT
+category        GLES2.0
+
+name            GetUniformfv
+alias		GetUniformfvARB
+return          void
+param           program         GLuint
+param           location        GLint
+param           params          GLfloat *
+props           get
+category        GLES2.0
+
+name            GetUniformiv
+alias		GetUniformivARB
+return          void
+param           program         GLuint
+param           location        GLint
+param           params          GLint *
+props           get
+category        GLES2.0
+
+name            QueryMatrixx
+return          GLbitfield
+param           mantissa        GLfixed *
+vector		mantissa	16
+param           exponent        GLint *
+vector		exponent        16
+props           get
+category        GLES1.1:OES_query_matrix
+
+# OES_draw_texture doesn't appear to be supported in Mesa yet
+name            DrawTexf
+return          void
+param           x               GLfloat
+param           y               GLfloat
+param           z               GLfloat
+param           w               GLfloat
+param           h               GLfloat
+category        GLES1.1:OES_draw_texture
+
+name            DrawTexi
+return          void
+param           x               GLint
+param           y               GLint
+param           z               GLint
+param           w               GLint
+param           h               GLint
+convertalias    DrawTexf
+convertparams   GLfloat        x y z w h
+category        GLES1.1:OES_draw_texture
+
+name            DrawTexx
+return          void
+param           x               GLfixed
+param           y               GLfixed
+param           z               GLfixed
+param           w               GLfixed
+param           h               GLfixed
+convertalias    DrawTexf
+convertparams   GLfloat        x y z w h
+category        GLES1.1:OES_draw_texture
+
+name            DrawTexfv
+return          void
+param           coords          const GLfloat *
+vector          coords          5
+category        GLES1.1:OES_draw_texture
+
+name            DrawTexiv
+return          void
+param           coords          const GLint *
+vector          coords          5
+convertalias    DrawTexfv
+convertparams   GLfloat         coords
+category        GLES1.1:OES_draw_texture
+
+name            DrawTexxv
+return          void
+param           coords          const GLfixed *
+vector          coords          5
+convertalias    DrawTexfv
+convertparams   GLfloat         coords
+category        GLES1.1:OES_draw_texture
+
+# We don't support OES_get_program_binary yet either
+#name GetProgramBinary
+#return void
+#param          program         GLuint
+#param          bufSize         GLsizei
+#param          length          GLsizei *
+#param          binaryFormat    GLenum *
+#param          binary          GLvoid *
+#category       GLES2.0:OES_get_program_binary
+#
+#name           ProgramBinary
+#return         void
+#param          program         GLuint
+#param          binaryFormat    GLenum
+#param          binary          const GLvoid *
+#param          length          GLint
+#category       GLES2.0:OES_get_program_binary
diff --git a/src/mesa/es/main/apiutil.py b/src/mesa/es/main/apiutil.py
new file mode 100644
index 0000000..7fb1afc
--- /dev/null
+++ b/src/mesa/es/main/apiutil.py
@@ -0,0 +1,1117 @@
+
+# apiutil.py
+#
+# This file defines a bunch of utility functions for OpenGL API code
+# generation.
+
+import sys, string, re
+
+
+#======================================================================
+
+def CopyrightC( ):
+        print """/* Copyright (c) 2001, Stanford University
+        All rights reserved.
+
+        See the file LICENSE.txt for information on redistributing this software. */
+        """
+
+def CopyrightDef( ):
+        print """; Copyright (c) 2001, Stanford University
+        ; All rights reserved.
+        ;
+        ; See the file LICENSE.txt for information on redistributing this software.
+        """
+
+
+#======================================================================
+
+class APIFunction:
+        """Class to represent a GL API function (name, return type,
+        parameters, etc)."""
+        def __init__(self):
+                self.name = ''
+                self.returnType = ''
+                self.category = ''
+                self.categories = []
+                self.offset = -1
+                self.alias = ''
+                self.vectoralias = ''
+                self.convertalias = ''
+                self.aliasprefix = ''
+                self.params = []
+                self.paramlist = []
+                self.paramvec = []
+                self.paramaction = []
+                self.paramprop = []
+                self.paramset = []
+                self.props = []
+                self.chromium = []
+
+def FindParamIndex(params, paramName):
+        """Given a function record, find the index of a named parameter"""
+        for i in range (len(params)):
+                if paramName == params[i][0]:
+                        return i
+        # If we get here, there was no such parameter
+        return None
+
+def SetTupleIndex(tuple, index, value):
+        t = ()
+        for i in range(len(tuple)):
+                if i == index:
+                        t += (value,)
+                else:
+                        t += (tuple[i],)
+        return t
+
+def VersionSpecificValues(category, values):
+        selectedValues = []
+        for value in values:
+                # Version-specific values are prefixed with the version
+                # number, e.g. GLES1.0:GL_TEXTURE_CUBE_MAP_OES
+                splitValue = value.split(":")
+                if len(splitValue) == 2:
+                        if category != None and splitValue[0] != category:
+                                # Don't want this one.
+                                continue
+                        else:
+                                selectedValues.append(splitValue[1])
+                else:
+                        selectedValues.append(value)
+        return selectedValues
+
+def ProcessSpecFile(filename, userFunc, category = None):
+        """Open the named API spec file and call userFunc(record, category) for each record
+        processed."""
+        specFile = open(filename, "r")
+        if not specFile:
+                print >>sys.stderr, "Error: couldn't open %s file!" % filename
+                sys.exit()
+
+        record = APIFunction()
+
+        for line in specFile.readlines():
+
+                # split line into tokens
+                tokens = string.split(line)
+
+                if len(tokens) > 0 and line[0] != '#':
+
+                        if tokens[0] == 'name':
+                                if record.name != '':
+                                        # process the old function now
+                                        userFunc(record, category)
+                                        # reset the record
+                                        record = APIFunction()
+
+                                record.name = tokens[1]
+
+                        elif tokens[0] == 'return':
+                                record.returnType = string.join(tokens[1:], ' ')
+                        
+                        elif tokens[0] == 'param':
+                                name = tokens[1]
+                                type = string.join(tokens[2:], ' ')
+                                vecSize = 0
+                                record.params.append((name, type, vecSize, None, [], None))
+
+                        elif tokens[0] == 'paramprop':
+                                name = tokens[1]
+                                str = tokens[2:]
+                                enums = []
+                                for i in range(len(str)):
+                                        enums.append(str[i]) 
+                                record.paramprop.append((name, enums))
+
+                        elif tokens[0] == 'paramlist':
+                                name = tokens[1]
+                                str = tokens[2:]
+                                list = []
+                                for i in range(len(str)):
+                                        list.append(str[i]) 
+                                record.paramlist.append((name,list))
+
+                        elif tokens[0] == 'paramvec':
+                                name = tokens[1]
+                                str = tokens[2:]
+                                vec = []
+                                for i in range(len(str)):
+                                        vec.append(str[i]) 
+                                record.paramvec.append((name,vec))
+
+                        elif tokens[0] == 'paramset':
+                                line = tokens[1:]
+                                result = []
+                                for i in range(len(line)):
+                                        tset = line[i]
+                                        if tset == '[':
+                                                nlist = []
+                                        elif tset == ']':
+                                                result.append(nlist)
+                                                nlist = []
+                                        else:
+                                                nlist.append(tset)
+                                if result != []:
+                                        record.paramset.append(result)
+
+                        elif tokens[0] == 'paramaction':
+                                name = tokens[1]
+                                str = tokens[2:]
+                                list = []
+                                for i in range(len(str)):
+                                        list.append(str[i]) 
+                                record.paramaction.append((name,list))
+
+                        elif tokens[0] == 'category':
+                                record.category = tokens[1]
+                                record.categories = tokens[1:]
+
+                        elif tokens[0] == 'offset':
+                                if tokens[1] == '?':
+                                        record.offset = -2
+                                else:
+                                        record.offset = int(tokens[1])
+
+                        elif tokens[0] == 'alias':
+                                record.alias = tokens[1]
+
+                        elif tokens[0] == 'vectoralias':
+                                record.vectoralias = tokens[1]
+
+                        elif tokens[0] == 'convertalias':
+                                record.convertalias = tokens[1]
+
+                        elif tokens[0] == 'aliasprefix':
+                                record.aliasprefix = tokens[1]
+
+                        elif tokens[0] == 'props':
+                                record.props = tokens[1:]
+
+                        elif tokens[0] == 'chromium':
+                                record.chromium = tokens[1:]
+
+                        elif tokens[0] == 'vector':
+                                vecName = tokens[1]
+                                vecSize = int(tokens[2])
+                                index = FindParamIndex(record.params, vecName)
+                                if index == None:
+                                        print >>sys.stderr, "Can't find vector '%s' for function '%s'" % (vecName, record.name)
+                                # Adjust just the vector size
+                                record.params[index] = SetTupleIndex(record.params[index], 2, vecSize)
+
+                        elif tokens[0] == 'dependentvector':
+                                dependentVecName = tokens[1]
+                                # the dependentVecSize may be an int
+                                # expression
+                                dependentVecSize = tokens[2]
+                                controllingParam = tokens[3]
+                                controllingParamIndex = FindParamIndex(record.params, controllingParam)
+                                if controllingParamIndex == None:
+                                        print >>sys.stderr, "Can't find controlling param '%s' for function '%s'" % (controllingParam, record.name)
+                                controllingValues = tokens[4:]
+
+                                # Remember that all of the controllingValues
+                                # are valid values for the controllingParam.
+                                # We may be duplicating controllingValues
+                                # here (i.e. if we get them from different
+                                # places); we'll sort them out later.
+                                validValues = record.params[controllingParamIndex][4]
+                                for value in VersionSpecificValues(category, controllingValues):
+                                        validValues.append((value, dependentVecSize, dependentVecName, [], None, None))
+                                # Don't need to reassign validValues back
+                                # to the tuple - it's a shallow pointer,
+                                # so the tuple is already modified.  
+                                # (And attempting to do so would produce an
+                                # error anyway.)
+
+                        elif tokens[0] == "dependentnovalueconvert":
+                                paramName = tokens[1]
+                                controllingParamName = tokens[2]
+                                controllingValues = tokens[3:]
+
+                                controllingParamIndex = FindParamIndex(record.params, controllingParamName)
+                                if controllingParamIndex == None:
+                                        print >>sys.stderr, "Can't find controlling param '%s' for function '%s'" % (controllingParamName, record.name)
+
+                                validValues = record.params[controllingParamIndex][4]
+                                for value in VersionSpecificValues(category, controllingValues):
+                                        validValues.append((value, None, None, [], None, "noconvert"))
+
+
+
+                        elif tokens[0] == 'checkparam':
+                                paramName = tokens[1]
+                                values = tokens[2:]
+                                paramIndex = FindParamIndex(record.params, paramName)
+                                if paramIndex == None:
+                                        print >>sys.stderr, "Can't find checked param '%s' for function '%s'" % (paramName, record.name)
+
+                                errorCode = None
+
+                                # We may be duplicating valid values here;
+                                # just add all values to the existing
+                                # record, and we'll prune out duplicates
+                                # later
+                                validValues = record.params[paramIndex][4]
+
+                                # A /GL_* value represents an error, not
+                                # a real value.  Look through the values
+                                # and only append the non-error values.
+                                for v in VersionSpecificValues(category, values):
+                                        if v[0] == "/":
+                                                errorCode = v[1:]
+                                        else:
+                                            validValues.append((v, None, None, [], errorCode, None))
+                                # Don't need to reassign validValues back
+                                # to the parameter tuple - it's a shallow pointer,
+                                # so the tuple is already modified.  
+                                # (And attempting to do so would produce an
+                                # error anyway.)
+
+                        elif tokens[0] == 'checkdependentparam':
+                                paramName = tokens[1]
+                                controllingValue = tokens[2]
+                                dependentParamName = tokens[3]
+                                validDependentValues = tokens[4:]
+                                errorCode = None
+
+                                # A /GL_* value represents an error, not
+                                # a real value.  Look through the values
+                                # and only append the non-error values.
+                                validDependentValues = []
+                                for v in tokens[4:]:
+                                        if v[0] == "/":
+                                                errorCode = v[1:]
+                                        else:
+                                            validDependentValues.append(v)
+
+                                paramIndex = FindParamIndex(record.params, paramName)
+                                if paramIndex == None:
+                                        print >>sys.stderr, "Can't find dependent param '%s' for function '%s'" % (paramName, record.name)
+
+                                validValues = record.params[paramIndex][4]
+                                # We may be duplicating valid values here;
+                                # we'll sort them out later.  Avoid
+                                # adding a controlling value record
+                                # at all if there are no values
+                                # in the list of values (so that
+                                # controlling values with only
+                                # version-specific values listed
+                                # end up as version-specific
+                                # themselves).
+                                versionSpecificValues = VersionSpecificValues(category, validDependentValues)
+                                if versionSpecificValues != []:
+                                        validValues.append((controllingValue, None, dependentParamName, versionSpecificValues, errorCode, None))
+                                # Don't need to reassign validValues back
+                                # to the tuple - it's a shallow pointer,
+                                # so the tuple is already modified.  
+                                # (And attempting to do so would produce an
+                                # error anyway.)
+
+                        elif tokens[0] == 'convertparams':
+                                convertToType = tokens[1]
+                                # Replace the conversion type in each named
+                                # parameter
+                                for paramName in tokens[2:]:
+                                        paramIndex = FindParamIndex(record.params, paramName)
+                                        if paramIndex == None:
+                                            print >>sys.stderr, "Can't find converted param '%s' for function '%s'" % (paramName, record.name)
+                                        # Tuples don't support item assignment,
+                                        # so to replace scalar values in a
+                                        # tuple, you have to reassign the
+                                        # whole friggin' thing.
+                                        record.params[paramIndex] = SetTupleIndex(record.params[paramIndex], 3, convertToType)
+
+                        else:
+                                print >>sys.stderr, 'Invalid token %s after function %s' % (tokens[0], record.name)
+                        #endif
+                #endif
+        #endfor
+
+        # Call the user function for the last record, if we still have one
+        # lying around nearly finished
+        if record.name != '':
+                # process the function now
+                userFunc(record, category)
+        specFile.close()
+#enddef
+
+
+# Dictionary [name] of APIFunction:
+__FunctionDict = {}
+
+# Dictionary [name] of name
+__VectorVersion = {}
+
+# Reverse mapping of function name aliases
+__ReverseAliases = {}
+
+def CheckCategories(category, categories):
+    for c in categories:
+        if category == c.split(":")[0]:
+            return 1
+
+    return 0
+
+def AddFunction(record, category):
+        # If there is a category, we only want records from that category.
+        # Note that a category may be in the form "GLES1.1:OES_extension_name",
+        # which means that the function is supported as an extension in 
+        # GLES1.1...
+        if category and not CheckCategories(category, record.categories):
+                return
+
+        # Don't allow duplicates
+        if __FunctionDict.has_key(record.name):
+                print >>sys.stderr, "Duplicate record name '%s' ignored" % record.name
+                return
+
+        # Clean up a bit.  We collected valid values for parameters
+        # on the fly; it's quite possible that there are duplicates.
+        # If there are, collect them together.
+        # 
+        # We're also going to keep track of all the dependent values
+        # that can show up for a parameter; the number of GLenum values
+        # (identified with a prefixed "GL_") affects how parameter
+        # value conversion happens, as GLenum values are not scaled
+        # when converted to or from GLfixed values, the way integer
+        # and floating point values are.
+        paramValueConversion = {}
+
+        for i in range(len(record.params)):
+                foundValidValues = {}
+
+                (name, type, maxVecSize, convertToType, validValues, valueConversion) = record.params[i]
+                for (controllingValue, vecSize, dependentParamName, dependentValues, errorCode, valueConvert) in validValues:
+                        # Keep track of the maximum vector size for the
+                        # *dependent* parameter, not for the controlling
+                        # parameter.  Note that the dependent parameter
+                        # may be an expression - in this case, don't
+                        # consider it.
+                        if dependentParamName != None and vecSize != None and vecSize.isdigit():
+                                dependentParamIndex = FindParamIndex(record.params, dependentParamName)
+                                if dependentParamIndex == None:
+                                        print >>sys.stderr, "Couldn't find dependent parameter '%s' of function '%s'" % (dependentParamName, record.name)
+                                (dName, dType, dMaxVecSize, dConvert, dValid, dValueConversion) = record.params[dependentParamIndex]
+                                if dMaxVecSize == None or int(vecSize) > dMaxVecSize:
+                                        dMaxVecSize = int(vecSize)
+                                        record.params[dependentParamIndex] = (dName, dType, dMaxVecSize, dConvert, dValid, dValueConversion)
+
+                        # Make sure an entry for the controlling value
+                        # exists in the foundValidValues dictionary
+                        if controllingValue in foundValidValues:
+                                # The value was already there.  Merge the
+                                # two together, giving errors if needed.
+                                (oldControllingValue, oldVecSize, oldDependentParamName, oldDependentValues, oldErrorCode, oldValueConvert) = foundValidValues[controllingValue]
+
+                                # Make sure the vector sizes are compatible;
+                                # either one should be None (and be 
+                                # overridden by the other), or they should
+                                # match exactly.  If one is not an
+                                # integer (this can happen if the 
+                                # dependent value is an integer expression,
+                                # which occurs a couple of times), don't
+                                # use it.
+                                if oldVecSize == None:
+                                        oldVecSize = vecSize
+                                elif vecSize != None and vecSize != oldVecSize:
+                                        print >>sys.stderr, "Found two different vector sizes (%s and %s) for the same controlling value '%s' of the same parameter '%s' of function '%s'" % (oldVecSize, vecSize, controllingValue, name, record.name)
+
+                                # Same for the dependent parameter name.
+                                if oldDependentParamName == None:
+                                        oldDependentParamName = dependentParamName
+                                elif dependentParamName != None and dependentParamName != oldDependentParamName:
+                                        print >>sys.stderr, "Found two different dependent parameter names (%s and %s) for the same controlling value '%s' of the same parameter '%s' of function '%s'" % (oldDependentParamName, dependentParamName, controllingValue, name, record.name)
+
+                                # And for the error code.
+                                if oldErrorCode == None:
+                                        oldErrorCode = errorCode
+                                elif errorCode != None and errorCode != oldErrorCode:
+                                        print >>sys.stderr, "Found two different error codes(%s and %s) for the same controlling value '%s' of the same parameter '%s' of function '%s'" % (oldErrorCode, errorCode, controllingValue, name, record.name)
+
+                                # And for the value conversion flag
+                                if oldValueConvert == None:
+                                        oldValueConvert = valueConvert
+                                elif valueConvert != None and valueConvert != oldValueConvert:
+                                        print >>sys.stderr, "Found two different value conversions(%s and %s) for the same controlling value '%s' of the same parameter '%s' of function '%s'" % (oldValueConvert, valueConvert, controllingValue, name, record.name)
+
+                                # Combine the dependentValues together
+                                # directly, but uniquely
+                                for value in dependentValues:
+                                        if value not in oldDependentValues:
+                                                oldDependentValues.append(value)
+
+                                # Stick the combined value back into the
+                                # dictionary.  We'll sort it back to the
+                                # array later.
+                                foundValidValues[oldControllingValue] = (oldControllingValue, oldVecSize, oldDependentParamName, oldDependentValues, oldErrorCode, oldValueConvert)
+                        else: # new controlling value
+                                # Just add it to the dictionary so we don't
+                                # add the same value more than once.
+                                foundValidValues[controllingValue] = (controllingValue, vecSize, dependentParamName, dependentValues, errorCode, valueConvert)
+                        # endif a new controlling value
+
+                # endfor all valid values for this parameter
+
+                # Now the foundValidValues[] dictionary holds all the
+                # pruned values (at most one for each valid value).
+                # But the validValues[] array still holds the order,
+                # which we want to maintain.  Go through the validValues
+                # array just for the names of the controlling values; 
+                # add any uncopied values to the prunedValidValues array.
+                prunedValidValues = []
+
+                for (controllingValue, vecSize, dependentParamName, dependentValues, errorCode, valueConvert) in validValues:
+                        if controllingValue in foundValidValues:
+                                prunedValidValues.append(foundValidValues[controllingValue])
+                                # Delete it from the dictionary so it isn't
+                                # copied again.
+                                del foundValidValues[controllingValue]
+
+                # Each parameter that is being converted may have a
+                # subset of values that are GLenums and are never
+                # converted.  In some cases, the parameter will 
+                # be implicitly determined to be such, by examining
+                # the listed possible values and determining for
+                # any particular controlling value whether there are
+                # any GLenum-valued allowed values.
+                #
+                # In other cases, the parameter will be explicitly
+                # marked as such with the "dependentnovalueconvert" flag;
+                # this is the way it has to be done with queries (which
+                # cannot list a valid list of values to be passed,
+                # because values are returned, not passed).
+                #
+                # For each value of controlling GLenum, we'll also
+                # need to know whether its dependent values are
+                # always converted (none of its values require
+                # GLenums to be passed in dependent parameters),
+                # never converted (all of its values require GLenums),
+                # or sometimes converted.
+                numNoConvertValues = 0
+                allDependentParams = []
+                for j in range(len(prunedValidValues)):
+                        (controllingValue, vecSize, dependentParamName, dependentValues, errorCode, valueConvert) = prunedValidValues[j]
+                        if dependentParamName != None and dependentParamName not in allDependentParams:
+                                allDependentParams.append(dependentParamName)
+
+                        # Check for an explicit noconvert marking...
+                        if valueConvert == "noconvert":
+                                numNoConvertValues += 1
+                        else:
+                                # Or check for an implicit one.
+                                for value in dependentValues:
+                                        if value[0:3] == "GL_":
+                                                valueConvert = "noconvert"
+                                                prunedValidValues[j] = (controllingValue, vecSize, dependentParamName, dependentValues, errorCode, valueConvert)
+                                                numNoConvertValues += 1
+                                                break
+
+                # For each named dependent param, set the value conversion
+                # flag based on whether all values, none, or some need
+                # value conversion.  This value is set stepwise
+                # for each parameter examined - 
+                for dp in allDependentParams:
+                        if numNoConvertValues == 0:
+                                if not paramValueConversion.has_key(dp):
+                                        paramValueConversion[dp] = "all"
+                                elif paramValueConversion[dp] == "none":
+                                        paramValueConversion[dp] = "some"
+                        elif numNoConvertValues == len(prunedValidValues):
+                                if not paramValueConversion.has_key(dp):
+                                        paramValueConversion[dp] = "none"
+                                elif paramValueConversion[dp] == "all":
+                                        paramValueConversion[dp] = "some"
+                        else:
+                                paramValueConversion[dp] = "some"
+
+                # Save away the record.  Save a placeholder in the
+                # valueConversion field - we can't set that until we've
+                # examined all the parameters.
+                record.params[i] = (name, type, maxVecSize, convertToType, prunedValidValues, None)
+
+        # endfor each param of the passed-in function record
+
+        # One more pass: for each parameter, if it is a parameter that
+        # needs conversion, save its value conversion type ("all", "none",
+        # or "some").  We only have to worry about conditional value 
+        # conversion for GLfixed parameters; in all other cases, we
+        # either don't convert at all (for non-converting parameters) or
+        # we convert everything.
+        for i in range(len(record.params)):
+                (name, type, maxVecSize, convertToType, validValues, valueConversion) = record.params[i]
+                if convertToType == None:
+                    valueConversion = None
+                elif paramValueConversion.has_key(name):
+                    valueConversion = paramValueConversion[name]
+                else:
+                    valueConversion = "all"
+
+                record.params[i] = (name, type, maxVecSize, convertToType, validValues, valueConversion)
+                                        
+        # We're done cleaning up!
+        # Add the function to the permanent record and we're done.
+        __FunctionDict[record.name] = record
+
+
+def GetFunctionDict(specFile = "", category = None):
+        if not specFile:
+                specFile = "../glapi_parser/APIspec.txt"
+        if len(__FunctionDict) == 0:
+                ProcessSpecFile(specFile, AddFunction, category)
+                # Look for vector aliased functions
+                for func in __FunctionDict.keys():
+                        va = __FunctionDict[func].vectoralias
+                        if va != '':
+                                __VectorVersion[va] = func
+                        #endif
+
+                        # and look for regular aliases (for glloader)
+                        a = __FunctionDict[func].alias
+                        if a:
+                                __ReverseAliases[a] = func
+                        #endif
+                #endfor
+        #endif
+        return __FunctionDict
+
+
+def GetAllFunctions(specFile = "", category = None):
+        """Return sorted list of all functions known to Chromium."""
+        d = GetFunctionDict(specFile, category)
+        funcs = []
+        for func in d.keys():
+                rec = d[func]
+                if not "omit" in rec.chromium:
+                        funcs.append(func)
+        funcs.sort()
+        return funcs
+        
+
+def GetDispatchedFunctions(specFile = "", category = None):
+        """Return sorted list of all functions handled by SPU dispatch table."""
+        d = GetFunctionDict(specFile, category)
+        funcs = []
+        for func in d.keys():
+                rec = d[func]
+                if (not "omit" in rec.chromium and
+                        not "stub" in rec.chromium and
+                        rec.alias == ''):
+                        funcs.append(func)
+        funcs.sort()
+        return funcs
+
+#======================================================================
+
+def ReturnType(funcName):
+        """Return the C return type of named function.
+        Examples: "void" or "const GLubyte *". """
+        d = GetFunctionDict()
+        return d[funcName].returnType
+
+
+def Parameters(funcName):
+        """Return list of tuples (name, type, vecSize) of function parameters.
+        Example: if funcName=="ClipPlane" return
+        [ ("plane", "GLenum", 0), ("equation", "const GLdouble *", 4) ] """
+        d = GetFunctionDict()
+        return d[funcName].params
+
+def ParamAction(funcName):
+        """Return list of names of actions for testing.
+        For PackerTest only."""
+        d = GetFunctionDict()
+        return d[funcName].paramaction
+
+def ParamList(funcName):
+        """Return list of tuples (name, list of values) of function parameters.
+        For PackerTest only."""
+        d = GetFunctionDict()
+        return d[funcName].paramlist
+
+def ParamVec(funcName):
+        """Return list of tuples (name, vector of values) of function parameters.
+        For PackerTest only."""
+        d = GetFunctionDict()
+        return d[funcName].paramvec
+
+def ParamSet(funcName):
+        """Return list of tuples (name, list of values) of function parameters.
+        For PackerTest only."""
+        d = GetFunctionDict()
+        return d[funcName].paramset
+
+
+def Properties(funcName):
+        """Return list of properties of the named GL function."""
+        d = GetFunctionDict()
+        return d[funcName].props
+
+def AllWithProperty(property):
+        """Return list of functions that have the named property."""
+        funcs = []
+        for funcName in GetDispatchedFunctions():
+                if property in Properties(funcName):
+                        funcs.append(funcName)
+        return funcs
+
+def Category(funcName):
+        """Return the primary category of the named GL function."""
+        d = GetFunctionDict()
+        return d[funcName].category
+
+def Categories(funcName):
+        """Return all the categories of the named GL function."""
+        d = GetFunctionDict()
+        return d[funcName].categories
+
+def ChromiumProps(funcName):
+        """Return list of Chromium-specific properties of the named GL function."""
+        d = GetFunctionDict()
+        return d[funcName].chromium
+
+def ParamProps(funcName):
+        """Return list of Parameter-specific properties of the named GL function."""
+        d = GetFunctionDict()
+        return d[funcName].paramprop
+
+def Alias(funcName):
+        """Return the function that the named function is an alias of.
+        Ex: Alias('DrawArraysEXT') = 'DrawArrays'.
+        """
+        d = GetFunctionDict()
+        return d[funcName].alias
+
+def AliasPrefix(funcName):
+        """Return the function that the named function is an alias of.
+        Ex: Alias('DrawArraysEXT') = 'DrawArrays'.
+        """
+        d = GetFunctionDict()
+        if d[funcName].aliasprefix == '':
+            return "_mesa_"
+        else:
+            return d[funcName].aliasprefix
+
+def ReverseAlias(funcName):
+        """Like Alias(), but the inverse."""
+        d = GetFunctionDict()
+        if funcName in __ReverseAliases.keys():
+                return __ReverseAliases[funcName]
+        else:
+                return ''
+
+def NonVectorFunction(funcName):
+        """Return the non-vector version of the given function, or ''.
+        For example: NonVectorFunction("Color3fv") = "Color3f"."""
+        d = GetFunctionDict()
+        return d[funcName].vectoralias
+
+def ConversionFunction(funcName):
+        """Return a function that can be used to implement the
+        given function, using different types.
+        For example: ConvertedFunction("Color4x") = "Color4f"."""
+        d = GetFunctionDict()
+        return d[funcName].convertalias
+
+def VectorFunction(funcName):
+        """Return the vector version of the given non-vector-valued function,
+        or ''.
+        For example: VectorVersion("Color3f") = "Color3fv"."""
+        d = GetFunctionDict()
+        if funcName in __VectorVersion.keys():
+                return __VectorVersion[funcName]
+        else:
+                return ''
+
+def GetCategoryWrapper(func_name):
+        """Return a C preprocessor token to test in order to wrap code.
+        This handles extensions.
+        Example: GetTestWrapper("glActiveTextureARB") = "CR_multitexture"
+        Example: GetTestWrapper("glBegin") = ""
+        """
+        cat = Category(func_name)
+        if (cat == "1.0" or
+                cat == "1.1" or
+                cat == "1.2" or
+                cat == "Chromium" or
+                cat == "GL_chromium"):
+                return ''
+        elif cat[0] =='1':
+                # i.e. OpenGL 1.3 or 1.4 or 1.5
+                return "OPENGL_VERSION_" + string.replace(cat, ".", "_")
+        else:
+                assert cat != ''
+                return string.replace(cat, "GL_", "")
+
+
+def CanCompile(funcName):
+        """Return 1 if the function can be compiled into display lists, else 0."""
+        props = Properties(funcName)
+        if ("nolist" in props or
+                "get" in props or
+                "setclient" in props):
+                return 0
+        else:
+                return 1
+
+def HasChromiumProperty(funcName, propertyList):
+        """Return 1 if the function or any alias has any property in the
+        propertyList"""
+        for funcAlias in [funcName, NonVectorFunction(funcName), VectorFunction(funcName)]:
+                if funcAlias:
+                        props = ChromiumProps(funcAlias)
+                        for p in propertyList:
+                                if p in props:
+                                        return 1
+        return 0
+
+def CanPack(funcName):
+        """Return 1 if the function can be packed, else 0."""
+        return HasChromiumProperty(funcName, ['pack', 'extpack', 'expandpack'])
+
+def HasPackOpcode(funcName):
+        """Return 1 if the function has a true pack opcode"""
+        return HasChromiumProperty(funcName, ['pack', 'extpack'])
+
+def SetsState(funcName):
+        """Return 1 if the function sets server-side state, else 0."""
+        props = Properties(funcName)
+
+        # Exceptions.  The first set of these functions *do* have 
+        # server-side state-changing  effects, but will be missed 
+        # by the general query, because they either render (e.g. 
+        # Bitmap) or do not compile into display lists (e.g. all the others).
+        # 
+        # The second set do *not* have server-side state-changing
+        # effects, despite the fact that they do not render
+        # and can be compiled.  They are control functions
+        # that are not trackable via state.
+        if funcName in ['Bitmap', 'DeleteTextures', 'FeedbackBuffer', 
+                'RenderMode', 'BindBufferARB', 'DeleteFencesNV']:
+                return 1
+        elif funcName in ['ExecuteProgramNV']:
+                return 0
+
+        # All compilable functions that do not render and that do
+        # not set or use client-side state (e.g. DrawArrays, et al.), set
+        # server-side state.
+        if CanCompile(funcName) and "render" not in props and "useclient" not in props and "setclient" not in props:
+                return 1
+
+        # All others don't set server-side state.
+        return 0
+
+def SetsClientState(funcName):
+        """Return 1 if the function sets client-side state, else 0."""
+        props = Properties(funcName)
+        if "setclient" in props:
+                return 1
+        return 0
+
+def SetsTrackedState(funcName):
+        """Return 1 if the function sets state that is tracked by
+        the state tracker, else 0."""
+        # These functions set state, but aren't tracked by the state
+        # tracker for various reasons: 
+        # - because the state tracker doesn't manage display lists
+        #   (e.g. CallList and CallLists)
+        # - because the client doesn't have information about what
+        #   the server supports, so the function has to go to the
+        #   server (e.g. CompressedTexImage calls)
+        # - because they require a round-trip to the server (e.g.
+        #   the CopyTexImage calls, SetFenceNV, TrackMatrixNV)
+        if funcName in [
+                'CopyTexImage1D', 'CopyTexImage2D',
+                'CopyTexSubImage1D', 'CopyTexSubImage2D', 'CopyTexSubImage3D',
+                'CallList', 'CallLists',
+                'CompressedTexImage1DARB', 'CompressedTexSubImage1DARB',
+                'CompressedTexImage2DARB', 'CompressedTexSubImage2DARB',
+                'CompressedTexImage3DARB', 'CompressedTexSubImage3DARB',
+                'SetFenceNV'
+                ]:
+                return 0
+
+        # Anything else that affects client-side state is trackable.
+        if SetsClientState(funcName):
+                return 1
+
+        # Anything else that doesn't set state at all is certainly
+        # not trackable.
+        if not SetsState(funcName):
+                return 0
+
+        # Per-vertex state isn't tracked the way other state is
+        # tracked, so it is specifically excluded.
+        if "pervertex" in Properties(funcName):
+                return 0
+
+        # Everything else is fine
+        return 1
+
+def UsesClientState(funcName):
+        """Return 1 if the function uses client-side state, else 0."""
+        props = Properties(funcName)
+        if "pixelstore" in props or "useclient" in props:
+                return 1
+        return 0
+
+def IsQuery(funcName):
+        """Return 1 if the function returns information to the user, else 0."""
+        props = Properties(funcName)
+        if "get" in props:
+                return 1
+        return 0
+
+def FuncGetsState(funcName):
+        """Return 1 if the function gets GL state, else 0."""
+        d = GetFunctionDict()
+        props = Properties(funcName)
+        if "get" in props:
+                return 1
+        else:
+                return 0
+
+def IsPointer(dataType):
+        """Determine if the datatype is a pointer.  Return 1 or 0."""
+        if string.find(dataType, "*") == -1:
+                return 0
+        else:
+                return 1
+
+
+def PointerType(pointerType):
+        """Return the type of a pointer.
+        Ex: PointerType('const GLubyte *') = 'GLubyte'
+        """
+        t = string.split(pointerType, ' ')
+        if t[0] == "const":
+                t[0] = t[1]
+        return t[0]
+
+
+
+
+def OpcodeName(funcName):
+        """Return the C token for the opcode for the given function."""
+        return "CR_" + string.upper(funcName) + "_OPCODE"
+
+
+def ExtendedOpcodeName(funcName):
+        """Return the C token for the extended opcode for the given function."""
+        return "CR_" + string.upper(funcName) + "_EXTEND_OPCODE"
+
+
+
+
+#======================================================================
+
+def MakeCallString(params):
+        """Given a list of (name, type, vectorSize) parameters, make a C-style
+        formal parameter string.
+        Ex return: 'index, x, y, z'.
+        """
+        result = ''
+        i = 1
+        n = len(params)
+        for (name, type, vecSize, convertToType, validValues, valueConversion) in params:
+                result += name
+                if i < n:
+                        result = result + ', '
+                i += 1
+        #endfor
+        return result
+#enddef
+
+
+def MakeDeclarationString(params):
+        """Given a list of (name, type, vectorSize) parameters, make a C-style
+        parameter declaration string.
+        Ex return: 'GLuint index, GLfloat x, GLfloat y, GLfloat z'.
+        """
+        n = len(params)
+        if n == 0:
+                return 'void'
+        else:
+                result = ''
+                i = 1
+                for (name, type, vecSize, convertToType, validValues, valueConversion) in params:
+                        result = result + type + ' ' + name
+                        if i < n:
+                                result = result + ', '
+                        i += 1
+                #endfor
+                return result
+        #endif
+#enddef
+
+
+def MakePrototypeString(params):
+        """Given a list of (name, type, vectorSize) parameters, make a C-style
+        parameter prototype string (types only).
+        Ex return: 'GLuint, GLfloat, GLfloat, GLfloat'.
+        """
+        n = len(params)
+        if n == 0:
+                return 'void'
+        else:
+                result = ''
+                i = 1
+                for (name, type, vecSize, convertToType, validValues, valueConversion) in params:
+                        result = result + type
+                        # see if we need a comma separator
+                        if i < n:
+                                result = result + ', '
+                        i += 1
+                #endfor
+                return result
+        #endif
+#enddef
+
+
+#======================================================================
+        
+__lengths = {
+        'GLbyte': 1,
+        'GLubyte': 1,
+        'GLshort': 2,
+        'GLushort': 2,
+        'GLint': 4,
+        'GLuint': 4,
+        'GLfloat': 4,
+        'GLclampf': 4,
+        'GLdouble': 8,
+        'GLclampd': 8,
+        'GLenum': 4,
+        'GLboolean': 1,
+        'GLsizei': 4,
+        'GLbitfield': 4,
+        'void': 0,  # XXX why?
+        'int': 4,
+        'GLintptrARB': 4,   # XXX or 8 bytes?
+        'GLsizeiptrARB': 4  # XXX or 8 bytes?
+}
+
+def sizeof(type):
+        """Return size of C datatype, in bytes."""
+        if not type in __lengths.keys():
+                print >>sys.stderr, "%s not in lengths!" % type
+        return __lengths[type]
+
+
+#======================================================================
+align_types = 1
+
+def FixAlignment( pos, alignment ):
+        # if we want double-alignment take word-alignment instead,
+        # yes, this is super-lame, but we know what we are doing
+        if alignment > 4:
+                alignment = 4
+        if align_types and alignment and ( pos % alignment ):
+                pos += alignment - ( pos % alignment )
+        return pos
+
+def WordAlign( pos ):
+        return FixAlignment( pos, 4 )
+
+def PointerSize():
+        return 8 # Leave room for a 64 bit pointer
+
+def PacketLength( params ):
+        len = 0
+        for (name, type, vecSize, convertToType, validValues, valueConversion) in params:
+                if IsPointer(type):
+                        size = PointerSize()
+                else:
+                        assert string.find(type, "const") == -1
+                        size = sizeof(type)
+                len = FixAlignment( len, size ) + size
+        len = WordAlign( len )
+        return len
+
+#======================================================================
+
+__specials = {}
+
+def LoadSpecials( filename ):
+        table = {}
+        try:
+                f = open( filename, "r" )
+        except:
+                __specials[filename] = {}
+                print >>sys.stderr, "%s not present" % filename
+                return {}
+        
+        for line in f.readlines():
+                line = string.strip(line)
+                if line == "" or line[0] == '#':
+                        continue
+                table[line] = 1
+        
+        __specials[filename] = table
+        return table
+
+
+def FindSpecial( filename, glName ):
+        table = {}
+        try:
+                table = __specials[filename]
+        except KeyError:
+                table = LoadSpecials( filename )
+        
+        try:
+                if (table[glName] == 1):
+                        return 1
+                else:
+                        return 0 #should never happen
+        except KeyError:
+                return 0
+
+
+def AllSpecials( table_file ):
+        table = {}
+        filename = table_file + "_special"
+        try:
+                table = __specials[filename]
+        except KeyError:
+                table = LoadSpecials( filename )
+        
+        keys = table.keys()
+        keys.sort()
+        return keys
+
+
+def AllSpecials( table_file ):
+        filename = table_file + "_special"
+        table = {}
+        try:
+                table = __specials[filename]
+        except KeyError:
+                table = LoadSpecials(filename)
+        
+        ret = table.keys()
+        ret.sort()
+        return ret
+        
+
+def NumSpecials( table_file ):
+        filename = table_file + "_special"
+        table = {}
+        try:
+                table = __specials[filename]
+        except KeyError:
+                table = LoadSpecials(filename)
+        return len(table.keys())
+
+def PrintRecord(record):
+        argList = MakeDeclarationString(record.params)
+        if record.category == "Chromium":
+                prefix = "cr"
+        else:
+                prefix = "gl"
+        print '%s %s%s(%s);' % (record.returnType, prefix, record.name, argList )
+        if len(record.props) > 0:
+                print '   /* %s */' % string.join(record.props, ' ')
+
+#ProcessSpecFile("APIspec.txt", PrintRecord)
+
diff --git a/src/mesa/es/main/es1_special b/src/mesa/es/main/es1_special
new file mode 100644
index 0000000..17cf7ec
--- /dev/null
+++ b/src/mesa/es/main/es1_special
@@ -0,0 +1,11 @@
+# GetString is always special.
+GetString
+# GetPointer needs to be special to get the GL_POINT_SIZE_ARRAY_POINTER_OES
+# to work correctly, until support for that appears in Mesa.
+GetPointerv
+# CompressedTexImage2D calls out to two different functions based on
+# whether the image is a paletted image or not
+CompressedTexImage2D
+# QueryMatrixx returns values in an unusual, decomposed, fixed-value
+# form; it has its own code for this
+QueryMatrixx
diff --git a/src/mesa/es/main/es2_special b/src/mesa/es/main/es2_special
new file mode 100644
index 0000000..8de76a3
--- /dev/null
+++ b/src/mesa/es/main/es2_special
@@ -0,0 +1,5 @@
+# GetString must always have its own implementation, so we return our
+# implementation values instead of Mesa's.
+GetString
+CompressedTexImage2D
+RenderbufferStorage
diff --git a/src/mesa/es/main/es_generator.py b/src/mesa/es/main/es_generator.py
new file mode 100644
index 0000000..74d4998
--- /dev/null
+++ b/src/mesa/es/main/es_generator.py
@@ -0,0 +1,775 @@
+#*************************************************************************
+# Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+# All Rights Reserved.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# TUNGSTEN GRAPHICS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+#*************************************************************************
+
+
+import sys, os
+import apiutil
+
+# These dictionary entries are used for automatic conversion.
+# The string will be used as a format string with the conversion
+# variable.
+Converters = {
+    'GLint': {
+        'GLfloat': "(GLfloat) (%s)",
+    },
+    'GLfloat': {
+        'GLdouble': "(GLdouble) (%s)",
+        'GLint': "(GLint) (%s)",
+        'GLfixed' : "(GLint) (%s * 65536)",
+    },
+    'GLfixed': {
+        'GLfloat': "(GLfloat) (%s / 65536.0f)",
+        'GLdouble': "(GLdouble) (%s / 65536.0)",
+    },
+    'GLdouble': {
+        'GLfloat': "(GLfloat) (%s)",
+        'GLfixed': "(GLfixed) (%s * 65536)",
+    },
+    'GLclampf': {
+        'GLclampd': "(GLclampd) (%s)",
+        'GLclampx': "(GLclampx) (%s * 65536)",
+    },
+    'GLclampx': {
+        'GLclampf': "(GLclampf) (%s / 65536.0f)",
+        'GLclampd': "(GLclampd) (%s / 65536.0)",
+    },
+    'GLubyte': {
+        'GLfloat': "(GLfloat) (%s / 255.0f)",
+    },
+}
+
+def GetBaseType(type):
+    typeTokens = type.split(' ')
+    baseType = None
+    typeModifiers = []
+    for t in typeTokens:
+        if t in ['const', '*']:
+            typeModifiers.append(t)
+        else:
+            baseType = t
+    return (baseType, typeModifiers)
+
+def ConvertValue(value, fromType, toType):
+    """Returns a string that represents the given parameter string, 
+    type-converted if necessary."""
+
+    if not Converters.has_key(fromType):
+        sys.stderr.write("No base converter for type '%s' found.  Ignoring." % fromType)
+        return value
+
+    if not Converters[fromType].has_key(toType):
+        sys.stderr.write("No converter found for type '%s' to type '%s'.  Ignoring." % (fromType, toType))
+        return value
+
+    # This part is simple.  Return the proper conversion.
+    conversionString = Converters[fromType][toType]
+    return conversionString % value
+
+def GetLoopSizeExpression(funcName, paramName, paramMaxVecSize):
+    # The VariantArrays() list will have all the information (for all
+    # parameters) on how to calculate variant array sizes.
+    variantArrays = apiutil.VariantArrays(funcName)
+    defaultSize = paramMaxVecSize
+    loopSizeExpression = ''
+
+    # There can be many different entries in the variantArrays for the
+    # same parameter.  We have to look at all of them and pick out the
+    # ones of interest.
+    for (variantName, variantSize, controllingParam, controllingValues) in variantArrays:
+        if paramName == variantName:
+            # This variant specification applies to us.  It may be of
+            # the form "param size default", meaning that the value should
+            # replace the default size, or it may be 
+            # "param size controlParam value...", in which case the size should
+            # be used if the controlParam has any one of the given values.
+            if len(controllingValues) == 0:
+                defaultSize = variantSize
+            else:
+                # Create a compound conditional that expresses
+                # all the possible values in the list
+                conditional = ''
+                for value in controllingValues:
+                    if len(conditional) > 0:
+                        conditional = conditional + " || "
+                    conditional = conditional + "%s == %s" % (controllingParam, value)
+
+                # Add the possibly compound conditional and
+                # the associated vector size to the 
+                # loop control expression
+                loopSizeExpression = loopSizeExpression + "(%s) ? %s : " % (conditional, variantSize)
+
+        # end if the name matches
+    # end for the list of all variant array declarations
+
+    # Return the expression that returns the actual size of the
+    # array.  Note that 'loopSizeExpression' will already have a 
+    # trailing ": " if it is nonempty.
+    if len(loopSizeExpression) > 0:
+        return "(%s%s)" % (loopSizeExpression, defaultSize)
+    else:
+        return "%s" % defaultSize
+
+FormatStrings = {
+    'GLenum' : '0x%x',
+    'GLfloat' : '%f',
+    'GLint' : '%d',
+    'GLbitfield' : '0x%x',
+}
+def GetFormatString(type):
+    if FormatStrings.has_key(type):
+        return FormatStrings[type]
+    else:
+        return None
+
+
+######################################################################
+# Version-specific values to be used in the main script
+# header: which header file to include
+# api: what text specifies an API-level function
+# special: the name of the "specials" file
+VersionSpecificValues = {
+    'GLES1.1' : {
+        'description' : 'GLES1.1 functions',
+        'header' : 'GLES/gl.h',
+        'extheader' : 'GLES/glext.h',
+        'special' : 'es1_special',
+    },
+    'GLES2.0': {
+        'description' : 'GLES2.0 functions',
+        'header' : 'GLES2/gl2.h',
+        'extheader' : 'GLES2/gl2ext.h',
+        'special' : 'es2_special',
+    }
+}
+
+
+######################################################################
+# Main code for the script begins here.
+
+# Get the name of the program (without the directory part) for use in
+# error messages.
+program = os.path.basename(sys.argv[0])
+
+# We assume that the directory that the Python script is in also
+# houses the "special" files.
+programDir = os.path.dirname(sys.argv[0])
+
+# Set default values
+verbose = 0
+functionList = "APIspec.txt"
+version = "GLES1.1"
+
+# Allow for command-line switches
+import getopt, time
+options = "hvV:S:"
+try:
+    optlist, args = getopt.getopt(sys.argv[1:], options)
+except getopt.GetoptError, message:
+    sys.stderr.write("%s: %s.  Use -h for help.\n" % (program, message))
+    sys.exit(1)
+
+for option, optarg in optlist:
+    if option == "-h":
+        sys.stderr.write("Usage: %s [-%s]\n" % (program, options))
+        sys.stderr.write("Parse an API specification file and generate wrapper functions for a given GLES version\n")
+        sys.stderr.write("-h gives help\n")
+        sys.stderr.write("-v is verbose\n")
+        sys.stderr.write("-V specifies GLES version to generate [%s]:\n" % version)
+        for key in VersionSpecificValues.keys():
+            sys.stderr.write("    %s - %s\n" % (key, VersionSpecificValues[key]['description']))
+        sys.stderr.write("-S specifies API specification file to use [%s]\n" % functionList)
+        sys.exit(1)
+    elif option == "-v":
+        verbose += 1
+    elif option == "-V":
+        version = optarg
+    elif option == "-S":
+        functionList = optarg
+
+# Beyond switches, we support no further command-line arguments
+if len(args) >  0:
+    sys.stderr.write("%s: only switch arguments are supported - use -h for help\n" % program)
+    sys.exit(1)
+
+# If we don't have a valid version, abort.
+if not VersionSpecificValues.has_key(version):
+    sys.stderr.write("%s: version '%s' is not valid - use -h for help\n" % (program, version))
+    sys.exit(1)
+
+# Grab the version-specific items we need to use
+versionHeader = VersionSpecificValues[version]['header']
+versionExtHeader = VersionSpecificValues[version]['extheader']
+versionSpecial = VersionSpecificValues[version]['special']
+
+# We're probably being invoked from a different directory,
+# so look for the "special" file in the same directory that
+# holds the Python script
+specialFile = os.path.join(programDir, versionSpecial)
+if not os.path.isfile(specialFile):
+    sys.stderr.write("%s: can't find special file '%s' for version '%s' - aborting" % (program, specialFile, version))
+    sys.exit(1)
+
+allSpecials = apiutil.AllSpecials(specialFile.split("_")[0])
+
+# If we get to here, we're good to go.  The "version" parameter
+# directs GetDispatchedFunctions to only allow functions from
+# that "category" (version in our parlance).  This allows 
+# functions with different declarations in different categories
+# to exist (glTexImage2D, for example, is different between
+# GLES1 and GLES2).
+keys = apiutil.GetAllFunctions(functionList, version)
+
+print """/* DO NOT EDIT *************************************************
+ * THIS FILE AUTOMATICALLY GENERATED BY THE %s SCRIPT
+ * API specification file:   %s
+ * GLES version:             %s
+ * date:                     %s
+ */
+""" % (program, functionList, version, time.strftime("%Y-%m-%d %H:%M:%S"))
+
+# The headers we choose are version-specific.
+print """
+#include "%s"
+#include "%s"
+""" % (versionHeader, versionExtHeader)
+
+# Everyone needs these types.
+print """
+/* These types are needed for the Mesa veneer, but are not defined in
+ * the standard GLES headers.
+ */
+typedef double GLdouble;
+typedef double GLclampd;
+
+/* This type is normally in glext.h, but needed here */
+typedef char GLchar;
+
+/* Mesa error handling requires these */
+extern void *_mesa_get_current_context(void);
+extern void _mesa_error(void *ctx, GLenum error, const char *fmtString, ... );
+
+#include "main/compiler.h"
+#include "main/api_exec.h"
+#define HAVE_GLES_TYPES
+#include "glapi/dispatch.h"
+"""
+
+# All variant-length arrays in the GLES API are controlled by some
+# selector parameter.  Almost all of those are constant length based
+# on the selector parameter (e.g., in glFogfv(), if the "pname" 
+# parameter is GL_FOG_COLOR, the "params" array is considered to be
+# 4 floats long; for any other value of "pname", the "params' array
+# is considered to be 1 float long.
+#
+# There are a very few instances where the selector parameter chooses
+# a runtime-determined value:
+#   glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS)
+#   glGetIntegerv(GL_SHADER_BINARY_FORMATS)
+# plus the glGetBooleanv, glGetFloatv, glGetFixedv counterparts.
+#
+# The number of formats in both cases is not a constant, but is a
+# runtime-determined value (based on the return value of
+# glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS) or
+# glGetIntegerv(GL_NUM_SHADER_BINARY_FORMATS).
+#
+# Rather than hard-code some value (and risk memory errors when we
+# overshoot arrays), in these cases we'll use a constant expresssion
+# (e.g. _get_size(GL_NUM_COMPRESSED_TEXTURE_FORMATS)) to get the
+# value of the variant array.  Note, though, that in these cases the
+# "vector" parameter should be set to some size large enough to hold
+# all values  (and must be set for GLfixed-based conversions, which
+# need it to define an auxiliary array size).
+#
+# Here's the function itself.  Although we only need a couple of values,
+# we'll make it general.
+print """
+extern void GLAPIENTRY _mesa_GetIntegerv(GLenum, GLint *);
+static INLINE unsigned int _get_size(GLenum pname)
+{
+    /* In case of error, make sure the value returned is 0. */
+    GLint value = 0;
+    _mesa_GetIntegerv(pname, &value);
+    return (unsigned int) value;
+}
+"""
+
+# Finally we get to the all-important functions
+print """/*************************************************************
+ * Generated functions begin here
+ */
+"""
+for funcName in keys:
+    if verbose > 0: sys.stderr.write("%s: processing function %s\n" % (program, funcName))
+
+    # start figuring out what this function will look like.
+    returnType = apiutil.ReturnType(funcName)
+    props = apiutil.Properties(funcName)
+    params = apiutil.Parameters(funcName)
+    declarationString = apiutil.MakeDeclarationString(params)
+
+    # In case of error, a function may have to return.  Make
+    # sure we have valid return values in this case.
+    if returnType == "void":
+        errorReturn = "return"
+    elif returnType == "GLboolean":
+        errorReturn = "return GL_FALSE"
+    else:
+        errorReturn = "return (%s) 0" % returnType
+
+    # These are the output of this large calculation block.
+    # passthroughDeclarationString: a typed set of parameters that
+    # will be used to create the "extern" reference for the
+    # underlying Mesa or support function.  Note that as generated
+    # these have an extra ", " at the beginning, which will be
+    # removed before use.
+    # 
+    # passthroughDeclarationString: an untyped list of parameters
+    # that will be used to call the underlying Mesa or support
+    # function (including references to converted parameters).
+    # This will also be generated with an extra ", " at the
+    # beginning, which will be removed before use.
+    #
+    # variables: C code to create any local variables determined to
+    # be necessary.
+    # conversionCodeOutgoing: C code to convert application parameters
+    # to a necessary type before calling the underlying support code.
+    # May be empty if no conversion is required.  
+    # conversionCodeIncoming: C code to do the converse: convert 
+    # values returned by underlying Mesa code to the types needed
+    # by the application.
+    # Note that *either* the conversionCodeIncoming will be used (for
+    # generated query functions), *or* the conversionCodeOutgoing will
+    # be used (for generated non-query functions), never both.
+    passthroughFuncName = ""
+    passthroughDeclarationString = ""
+    passthroughCallString = ""
+    variables = []
+    conversionCodeOutgoing = []
+    conversionCodeIncoming = []
+    switchCode = []
+
+    # Calculate the name of the underlying support function to call.
+    # By default, the passthrough function is named _mesa_<funcName>.
+    # We're allowed to override the prefix and/or the function name
+    # for each function record, though.  The "ConversionFunction"
+    # utility is poorly named, BTW...
+    aliasprefix = apiutil.AliasPrefix(funcName)
+    alias = apiutil.ConversionFunction(funcName)
+    if not alias:
+        # There may still be a Mesa alias for the function
+        if apiutil.Alias(funcName):
+            passthroughFuncName = "%s%s" % (aliasprefix, apiutil.Alias(funcName))
+        else:
+            passthroughFuncName = "%s%s" % (aliasprefix, funcName)
+    else: # a specific alias is provided
+        passthroughFuncName = "%s%s" % (aliasprefix, alias)
+
+    # Look at every parameter: each one may have only specific
+    # allowed values, or dependent parameters to check, or 
+    # variant-sized vector arrays to calculate
+    for (paramName, paramType, paramMaxVecSize, paramConvertToType, paramValidValues, paramValueConversion) in params:
+        # We'll need this below if we're doing conversions
+        (paramBaseType, paramTypeModifiers) = GetBaseType(paramType)
+
+        # Conversion management.
+        # We'll handle three cases, easiest to hardest: a parameter
+        # that doesn't require conversion, a scalar parameter that
+        # requires conversion, and a vector parameter that requires
+        # conversion.
+        if paramConvertToType == None:
+            # Unconverted parameters are easy, whether they're vector
+            # or scalar - just add them to the call list.  No conversions
+            # or anything to worry about.
+            passthroughDeclarationString += ", %s %s" % (paramType, paramName)
+            passthroughCallString += ", %s" % paramName
+
+        elif paramMaxVecSize == 0: # a scalar parameter that needs conversion
+            # A scalar to hold a converted parameter
+            variables.append("    %s converted_%s;" % (paramConvertToType, paramName))
+
+            # Outgoing conversion depends on whether we have to conditionally
+            # perform value conversion.
+            if paramValueConversion == "none":
+                conversionCodeOutgoing.append("    converted_%s = (%s) %s;" % (paramName, paramConvertToType, paramName))
+            elif paramValueConversion == "some":
+                # We'll need a conditional variable to keep track of
+                # whether we're converting values or not.
+                if ("    int convert_%s_value = 1;" % paramName) not in variables:
+                    variables.append("    int convert_%s_value = 1;" % paramName)
+
+                # Write code based on that conditional.
+                conversionCodeOutgoing.append("    if (convert_%s_value) {" % paramName)
+                conversionCodeOutgoing.append("        converted_%s = %s;" % (paramName, ConvertValue(paramName, paramBaseType, paramConvertToType))) 
+                conversionCodeOutgoing.append("    } else {")
+                conversionCodeOutgoing.append("        converted_%s = (%s) %s;" % (paramName, paramConvertToType, paramName))
+                conversionCodeOutgoing.append("    }")
+            else: # paramValueConversion == "all"
+                conversionCodeOutgoing.append("    converted_%s = %s;" % (paramName, ConvertValue(paramName, paramBaseType, paramConvertToType)))
+
+            # Note that there can be no incoming conversion for a
+            # scalar parameter; changing the scalar will only change
+            # the local value, and won't ultimately change anything
+            # that passes back to the application.
+
+            # Call strings.  The unusual " ".join() call will join the
+            # array of parameter modifiers with spaces as separators.
+            passthroughDeclarationString += ", %s %s %s" % (paramConvertToType, " ".join(paramTypeModifiers), paramName)
+            passthroughCallString += ", converted_%s" % paramName
+
+        else: # a vector parameter that needs conversion
+            # We'll need an index variable for conversions
+            if "    register unsigned int i;" not in variables:
+                variables.append("    register unsigned int i;")
+
+            # This variable will hold the (possibly variant) size of
+            # this array needing conversion.  By default, we'll set
+            # it to the maximal size (which is correct for functions
+            # with a constant-sized vector parameter); for true
+            # variant arrays, we'll modify it with other code.
+            variables.append("    unsigned int n_%s = %d;" % (paramName, paramMaxVecSize))
+
+            # This array will hold the actual converted values.
+            variables.append("    %s converted_%s[%d];" % (paramConvertToType, paramName, paramMaxVecSize))
+
+            # Again, we choose the conversion code based on whether we
+            # have to always convert values, never convert values, or 
+            # conditionally convert values.
+            if paramValueConversion == "none":
+                conversionCodeOutgoing.append("    for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeOutgoing.append("        converted_%s[i] = (%s) %s[i];" % (paramName, paramConvertToType, paramName))
+                conversionCodeOutgoing.append("    }")
+            elif paramValueConversion == "some":
+                # We'll need a conditional variable to keep track of
+                # whether we're converting values or not.
+                if ("    int convert_%s_value = 1;" % paramName) not in variables:
+                    variables.append("    int convert_%s_value = 1;" % paramName)
+                # Write code based on that conditional.
+                conversionCodeOutgoing.append("    if (convert_%s_value) {" % paramName)
+                conversionCodeOutgoing.append("        for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeOutgoing.append("            converted_%s[i] = %s;" % (paramName, ConvertValue("%s[i]" % paramName, paramBaseType, paramConvertToType))) 
+                conversionCodeOutgoing.append("        }")
+                conversionCodeOutgoing.append("    } else {")
+                conversionCodeOutgoing.append("        for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeOutgoing.append("            converted_%s[i] = (%s) %s[i];" % (paramName, paramConvertToType, paramName))
+                conversionCodeOutgoing.append("        }")
+                conversionCodeOutgoing.append("    }")
+            else: # paramValueConversion == "all"
+                conversionCodeOutgoing.append("    for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeOutgoing.append("        converted_%s[i] = %s;" % (paramName, ConvertValue("%s[i]" % paramName, paramBaseType, paramConvertToType)))
+
+                conversionCodeOutgoing.append("    }")
+
+            # If instead we need an incoming conversion (i.e. results
+            # from Mesa have to be converted before handing back
+            # to the application), this is it.  Fortunately, we don't
+            # have to worry about conditional value conversion - the
+            # functions that do (e.g. glGetFixedv()) are handled
+            # specially, outside this code generation.
+            #
+            # Whether we use incoming conversion or outgoing conversion
+            # is determined later - we only ever use one or the other.
+
+            if paramValueConversion == "none":
+                conversionCodeIncoming.append("    for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeIncoming.append("        %s[i] = (%s) converted_%s[i];" % (paramName, paramConvertToType, paramName))
+                conversionCodeIncoming.append("    }")
+            elif paramValueConversion == "some":
+                # We'll need a conditional variable to keep track of
+                # whether we're converting values or not.
+                if ("    int convert_%s_value = 1;" % paramName) not in variables:
+                    variables.append("    int convert_%s_value = 1;" % paramName)
+
+                # Write code based on that conditional.
+                conversionCodeIncoming.append("    if (convert_%s_value) {" % paramName)
+                conversionCodeIncoming.append("        for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeIncoming.append("            %s[i] = %s;" % (paramName, ConvertValue("converted_%s[i]" % paramName, paramConvertToType, paramBaseType))) 
+                conversionCodeIncoming.append("        }")
+                conversionCodeIncoming.append("    } else {")
+                conversionCodeIncoming.append("        for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeIncoming.append("            %s[i] = (%s) converted_%s[i];" % (paramName, paramConvertToType, paramName))
+                conversionCodeIncoming.append("        }")
+                conversionCodeIncoming.append("    }")
+            else: # paramValueConversion == "all"
+                conversionCodeIncoming.append("    for (i = 0; i < n_%s; i++) {" % paramName)
+                conversionCodeIncoming.append("        %s[i] = %s;" % (paramName, ConvertValue("converted_%s[i]" % paramName, paramConvertToType, paramBaseType)))
+                conversionCodeIncoming.append("    }")
+
+            # Call strings.  The unusual " ".join() call will join the
+            # array of parameter modifiers with spaces as separators.
+            passthroughDeclarationString += ", %s %s %s" % (paramConvertToType, " ".join(paramTypeModifiers), paramName)
+            passthroughCallString += ", converted_%s" % paramName
+
+        # endif conversion management
+
+        # Parameter checking.  If the parameter has a specific list of
+        # valid values, we have to make sure that the passed-in values
+        # match these, or we make an error.
+        if len(paramValidValues) > 0:
+            # We're about to make a big switch statement with an
+            # error at the end.  By default, the error is GL_INVALID_ENUM,
+            # unless we find a "case" statement in the middle with a
+            # non-GLenum value.
+            errorDefaultCase = "GL_INVALID_ENUM"
+
+            # This parameter has specific valid values.  Make a big
+            # switch statement to handle it.  Note that the original
+            # parameters are always what is checked, not the
+            # converted parameters.
+            switchCode.append("    switch(%s) {" % paramName)
+
+            for valueIndex in range(len(paramValidValues)):
+                (paramValue, dependentVecSize, dependentParamName, dependentValidValues, errorCode, valueConvert) = paramValidValues[valueIndex]
+
+                # We're going to need information on the dependent param
+                # as well.
+                if dependentParamName:
+                    depParamIndex = apiutil.FindParamIndex(params, dependentParamName)
+                    if depParamIndex == None:
+                        sys.stderr.write("%s: can't find dependent param '%s' for function '%s'\n" % (program, dependentParamName, funcName))
+
+                    (depParamName, depParamType, depParamMaxVecSize, depParamConvertToType, depParamValidValues, depParamValueConversion) = params[depParamIndex]
+                else:
+                    (depParamName, depParamType, depParamMaxVecSize, depParamConvertToType, depParamValidValues, depParamValueConversion) = (None, None, None, None, [], None)
+
+                # This is a sneaky trick.  It's valid syntax for a parameter
+                # that is *not* going to be converted to be declared
+                # with a dependent vector size; but in this case, the
+                # dependent vector size is unused and unnecessary.
+                # So check for this and ignore the dependent vector size
+                # if the parameter is not going to be converted.
+                if depParamConvertToType:
+                    usedDependentVecSize = dependentVecSize
+                else:
+                    usedDependentVecSize = None
+
+                # We'll peek ahead at the next parameter, to see whether
+                # we can combine cases
+                if valueIndex + 1 < len(paramValidValues) :
+                    (nextParamValue, nextDependentVecSize, nextDependentParamName, nextDependentValidValues, nextErrorCode, nextValueConvert) = paramValidValues[valueIndex + 1]
+                    if depParamConvertToType:
+                        usedNextDependentVecSize = nextDependentVecSize
+                    else:
+                        usedNextDependentVecSize = None
+
+                # Create a case for this value.  As a mnemonic,
+                # if we have a dependent vector size that we're ignoring,
+                # add it as a comment.
+                if usedDependentVecSize == None and dependentVecSize != None:
+                    switchCode.append("        case %s: /* size %s */" % (paramValue, dependentVecSize))
+                else:
+                    switchCode.append("        case %s:" % paramValue)
+
+                # If this is not a GLenum case, then switch our error
+                # if no value is matched to be GL_INVALID_VALUE instead
+                # of GL_INVALID_ENUM.  (Yes, this does get confused
+                # if there are both values and GLenums in the same
+                # switch statement, which shouldn't happen.)
+                if paramValue[0:3] != "GL_":
+                    errorDefaultCase = "GL_INVALID_VALUE"
+
+                # If all the remaining parameters are identical to the
+                # next set, then we're done - we'll just create the
+                # official code on the next pass through, and the two
+                # cases will share the code.
+                if valueIndex + 1 < len(paramValidValues) and usedDependentVecSize == usedNextDependentVecSize and dependentParamName == nextDependentParamName and dependentValidValues == nextDependentValidValues and errorCode == nextErrorCode and valueConvert == nextValueConvert:
+                    continue
+
+                # Otherwise, we'll have to generate code for this case.
+                # Start off with a check: if there is a dependent parameter,
+                # and a list of valid values for that parameter, we need
+                # to generate an error if something other than one
+                # of those values is passed.
+                if len(dependentValidValues) > 0:
+                    conditional=""
+
+                    # If the parameter being checked is actually an array,
+                    # check only its first element.
+                    if depParamMaxVecSize == 0:
+                        valueToCheck = dependentParamName
+                    else:
+                        valueToCheck = "%s[0]" % dependentParamName
+
+                    for v in dependentValidValues:
+                        conditional += " && %s != %s" % (valueToCheck, v)
+                    switchCode.append("            if (%s) {" % conditional[4:])
+                    if errorCode == None:
+                        errorCode = "GL_INVALID_ENUM"
+                    switchCode.append('                _mesa_error(_mesa_get_current_context(), %s, "gl%s(%s=0x%s)", %s);' % (errorCode, funcName, paramName, "%x", paramName))
+                    switchCode.append("                %s;" % errorReturn)
+                    switchCode.append("            }")
+                # endif there are dependent valid values
+
+                # The dependent parameter may require conditional
+                # value conversion.  If it does, and we don't want
+                # to convert values, we'll have to generate code for that
+                if depParamValueConversion == "some" and valueConvert == "noconvert":
+                    switchCode.append("            convert_%s_value = 0;" % dependentParamName)
+
+                # If there's a dependent vector size for this parameter
+                # that we're actually going to use (i.e. we need conversion),
+                # mark it.
+                if usedDependentVecSize:
+                    switchCode.append("            n_%s = %s;" % (dependentParamName, dependentVecSize))
+
+                # In all cases, break out of the switch if any valid
+                # value is found.
+                switchCode.append("            break;")
+
+
+            # Need a default case to catch all the other, invalid
+            # parameter values.  These will all generate errors.
+            switchCode.append("        default:")
+            if errorCode == None:
+                errorCode = "GL_INVALID_ENUM"
+            formatString = GetFormatString(paramType)
+            if formatString == None:
+                switchCode.append('            _mesa_error(_mesa_get_current_context(), %s, "gl%s(%s)");' % (errorCode, funcName, paramName))
+            else:
+                switchCode.append('            _mesa_error(_mesa_get_current_context(), %s, "gl%s(%s=%s)", %s);' % (errorCode, funcName, paramName, formatString, paramName))
+            switchCode.append("            %s;" % errorReturn)
+
+            # End of our switch code.
+            switchCode.append("    }")
+
+        # endfor every recognized parameter value
+
+    # endfor every param
+
+    # Here, the passthroughDeclarationString and passthroughCallString
+    # are complete; remove the extra ", " at the front of each.
+    passthroughDeclarationString = passthroughDeclarationString[2:]
+    passthroughCallString = passthroughCallString[2:]
+
+    # The Mesa functions are scattered across all the Mesa
+    # header files.  The easiest way to manage declarations
+    # is to create them ourselves.
+    if funcName not in allSpecials:
+        print "extern %s GLAPIENTRY %s(%s);" % (returnType, passthroughFuncName, passthroughDeclarationString)
+
+    # A function may be a core function (i.e. it exists in
+    # the core specification), a core addition (extension
+    # functions added officially to the core), a required
+    # extension (usually an extension for an earlier version
+    # that has been officially adopted), or an optional extension.
+    #
+    # Core functions have a simple category (e.g. "GLES1.1");
+    # we generate only a simple callback for them.
+    #
+    # Core additions have two category listings, one simple
+    # and one compound (e.g.  ["GLES1.1", "GLES1.1:OES_fixed_point"]).  
+    # We generate the core function, and also an extension function.
+    #
+    # Required extensions and implemented optional extensions
+    # have a single compound category "GLES1.1:OES_point_size_array".
+    # For these we generate just the extension function.
+    for categorySpec in apiutil.Categories(funcName):
+        compoundCategory = categorySpec.split(":")
+
+        # This category isn't for us, if the base category doesn't match
+        # our version
+        if compoundCategory[0] != version:
+            continue
+
+        # Otherwise, determine if we're writing code for a core
+        # function (no suffix) or an extension function.
+        if len(compoundCategory) == 1:
+            # This is a core function
+            extensionName = None
+            fullFuncName = "_es_" + funcName
+        else:
+            # This is an extension function.  We'll need to append
+            # the extension suffix.
+            extensionName = compoundCategory[1]
+            extensionSuffix = extensionName.split("_")[0]
+            fullFuncName = "_es_" + funcName + extensionSuffix
+
+        # Now the generated function.  The text used to mark an API-level
+        # function, oddly, is version-specific.
+        if extensionName:
+            print "/* Extension %s */" % extensionName
+
+        if funcName in allSpecials:
+            print "/* this function is special and is defined elsewhere */"
+            print "extern %s %s(%s);" % (returnType, fullFuncName, declarationString)
+            print
+            continue
+
+        print "static %s %s(%s)" % (returnType, fullFuncName, declarationString)
+        print "{"
+
+        # Start printing our code pieces.  Start with any local
+        # variables we need.  This unusual syntax joins the 
+        # lines in the variables[] array with the "\n" separator.
+        if len(variables) > 0:
+            print "\n".join(variables), "\n";
+
+        # If there's any sort of parameter checking or variable
+        # array sizing, the switch code will contain it.
+        if len(switchCode) > 0:
+            print "\n".join(switchCode), "\n";
+
+        # In the case of an outgoing conversion (i.e. parameters must
+        # be converted before calling the underlying Mesa function),
+        # use the appropriate code.
+        if "get" not in props and len(conversionCodeOutgoing) > 0:
+            print "\n".join(conversionCodeOutgoing), "\n";
+
+        # Call the Mesa function.  Note that there are very few functions
+        # that return a value (i.e. returnType is not "void"), and that
+        # none of them require incoming translation; so we're safe
+        # to generate code that directly returns in those cases,
+        # even though it's not completely independent.
+
+        if returnType == "void":
+            print "    %s(%s);" % (passthroughFuncName, passthroughCallString)
+        else:
+            print "    return %s(%s);" % (passthroughFuncName, passthroughCallString)
+
+        # If the function is one that returns values (i.e. "get" in props),
+        # it might return values of a different type than we need, that
+        # require conversion before passing back to the application.
+        if "get" in props and len(conversionCodeIncoming) > 0:
+            print "\n".join(conversionCodeIncoming)
+
+        # All done.
+        print "}"
+        print
+    # end for each category provided for a function
+
+# end for each function
+
+print "void"
+print "_mesa_init_exec_table(struct _glapi_table *exec)"
+print "{"
+for func in keys:
+    for spec in apiutil.Categories(func):
+        ext = spec.split(":")
+        # version does not match
+        if ext.pop(0) != version:
+            continue
+        entry = func
+        if ext:
+            suffix = ext[0].split("_")[0]
+            entry += suffix
+        print "    SET_%s(exec, _es_%s);" % (entry, entry)
+print "}"
diff --git a/src/mesa/es/main/get_gen.py b/src/mesa/es/main/get_gen.py
new file mode 100644
index 0000000..516facc
--- /dev/null
+++ b/src/mesa/es/main/get_gen.py
@@ -0,0 +1,785 @@
+#!/usr/bin/env python
+
+# Mesa 3-D graphics library
+#
+# Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+# This script is used to generate the get.c file:
+# python get_gen.py > get.c
+
+
+import string
+import sys
+
+
+GLint = 1
+GLenum = 2
+GLfloat = 3
+GLdouble = 4
+GLboolean = 5
+GLfloatN = 6    # A normalized value, such as a color or depth range
+
+
+TypeStrings = {
+	GLint : "GLint",
+	GLenum : "GLenum",
+	GLfloat : "GLfloat",
+	GLdouble : "GLdouble",
+	GLboolean : "GLboolean"
+}
+
+
+# Each entry is a tuple of:
+#  - the GL state name, such as GL_CURRENT_COLOR
+#  - the state datatype, one of GLint, GLfloat, GLboolean or GLenum
+#  - list of code fragments to get the state, such as ["ctx->Foo.Bar"]
+#  - optional extra code or empty string
+#  - optional extensions to check, or None
+#
+
+# Present in ES 1.x and 2.x:
+StateVars_common = [
+	( "GL_ALPHA_BITS", GLint, ["ctx->DrawBuffer->Visual.alphaBits"],
+	  "", None ),
+	( "GL_BLEND", GLboolean, ["ctx->Color.BlendEnabled"], "", None ),
+	( "GL_BLEND_SRC", GLenum, ["ctx->Color.BlendSrcRGB"], "", None ),
+	( "GL_BLUE_BITS", GLint, ["ctx->DrawBuffer->Visual.blueBits"], "", None ),
+	( "GL_COLOR_CLEAR_VALUE", GLfloatN,
+	  [ "ctx->Color.ClearColor[0]",
+		"ctx->Color.ClearColor[1]",
+		"ctx->Color.ClearColor[2]",
+		"ctx->Color.ClearColor[3]" ], "", None ),
+	( "GL_COLOR_WRITEMASK", GLint,
+	  [ "ctx->Color.ColorMask[RCOMP] ? 1 : 0",
+		"ctx->Color.ColorMask[GCOMP] ? 1 : 0",
+		"ctx->Color.ColorMask[BCOMP] ? 1 : 0",
+		"ctx->Color.ColorMask[ACOMP] ? 1 : 0" ], "", None ),
+	( "GL_CULL_FACE", GLboolean, ["ctx->Polygon.CullFlag"], "", None ),
+	( "GL_CULL_FACE_MODE", GLenum, ["ctx->Polygon.CullFaceMode"], "", None ),
+	( "GL_DEPTH_BITS", GLint, ["ctx->DrawBuffer->Visual.depthBits"],
+	  "", None ),
+	( "GL_DEPTH_CLEAR_VALUE", GLfloatN, ["ctx->Depth.Clear"], "", None ),
+	( "GL_DEPTH_FUNC", GLenum, ["ctx->Depth.Func"], "", None ),
+	( "GL_DEPTH_RANGE", GLfloatN,
+	  [ "ctx->Viewport.Near", "ctx->Viewport.Far" ], "", None ),
+	( "GL_DEPTH_TEST", GLboolean, ["ctx->Depth.Test"], "", None ),
+	( "GL_DEPTH_WRITEMASK", GLboolean, ["ctx->Depth.Mask"], "", None ),
+	( "GL_DITHER", GLboolean, ["ctx->Color.DitherFlag"], "", None ),
+	( "GL_FRONT_FACE", GLenum, ["ctx->Polygon.FrontFace"], "", None ),
+	( "GL_GREEN_BITS", GLint, ["ctx->DrawBuffer->Visual.greenBits"],
+	  "", None ),
+	( "GL_LINE_WIDTH", GLfloat, ["ctx->Line.Width"], "", None ),
+	( "GL_ALIASED_LINE_WIDTH_RANGE", GLfloat,
+	  ["ctx->Const.MinLineWidth",
+	   "ctx->Const.MaxLineWidth"], "", None ),
+	( "GL_MAX_ELEMENTS_INDICES", GLint, ["ctx->Const.MaxArrayLockSize"], "", None ),
+	( "GL_MAX_ELEMENTS_VERTICES", GLint, ["ctx->Const.MaxArrayLockSize"], "", None ),
+
+	( "GL_MAX_TEXTURE_SIZE", GLint, ["1 << (ctx->Const.MaxTextureLevels - 1)"], "", None ),
+	( "GL_MAX_VIEWPORT_DIMS", GLint,
+	  ["ctx->Const.MaxViewportWidth", "ctx->Const.MaxViewportHeight"],
+	  "", None ),
+	( "GL_PACK_ALIGNMENT", GLint, ["ctx->Pack.Alignment"], "", None ),
+	( "GL_ALIASED_POINT_SIZE_RANGE", GLfloat,
+	  ["ctx->Const.MinPointSize",
+	   "ctx->Const.MaxPointSize"], "", None ),
+	( "GL_POLYGON_OFFSET_FACTOR", GLfloat, ["ctx->Polygon.OffsetFactor "], "", None ),
+	( "GL_POLYGON_OFFSET_UNITS", GLfloat, ["ctx->Polygon.OffsetUnits "], "", None ),
+	( "GL_RED_BITS", GLint, ["ctx->DrawBuffer->Visual.redBits"], "", None ),
+	( "GL_SCISSOR_BOX", GLint,
+	  ["ctx->Scissor.X",
+	   "ctx->Scissor.Y",
+	   "ctx->Scissor.Width",
+	   "ctx->Scissor.Height"], "", None ),
+	( "GL_SCISSOR_TEST", GLboolean, ["ctx->Scissor.Enabled"], "", None ),
+	( "GL_STENCIL_BITS", GLint, ["ctx->DrawBuffer->Visual.stencilBits"], "", None ),
+	( "GL_STENCIL_CLEAR_VALUE", GLint, ["ctx->Stencil.Clear"], "", None ),
+	( "GL_STENCIL_FAIL", GLenum,
+	  ["ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_FUNC", GLenum,
+	  ["ctx->Stencil.Function[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_PASS_DEPTH_FAIL", GLenum,
+	  ["ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_PASS_DEPTH_PASS", GLenum,
+	  ["ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_REF", GLint,
+	  ["ctx->Stencil.Ref[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_TEST", GLboolean, ["ctx->Stencil.Enabled"], "", None ),
+	( "GL_STENCIL_VALUE_MASK", GLint,
+	  ["ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_STENCIL_WRITEMASK", GLint,
+	  ["ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]"], "", None ),
+	( "GL_SUBPIXEL_BITS", GLint, ["ctx->Const.SubPixelBits"], "", None ),
+	( "GL_TEXTURE_BINDING_2D", GLint,
+	  ["ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name"], "", None ),
+	( "GL_UNPACK_ALIGNMENT", GLint, ["ctx->Unpack.Alignment"], "", None ),
+	( "GL_VIEWPORT", GLint, [ "ctx->Viewport.X", "ctx->Viewport.Y",
+	  "ctx->Viewport.Width", "ctx->Viewport.Height" ], "", None ),
+
+	# GL_ARB_multitexture
+	( "GL_ACTIVE_TEXTURE_ARB", GLint,
+	  [ "GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit"], "", ["ARB_multitexture"] ),
+
+        # Note that all the OES_* extensions require that the Mesa
+        # "struct gl_extensions" include a member with the name of
+        # the extension.  That structure does not yet include OES
+        # extensions (and we're not sure whether it will).  If
+        # it does, all the OES_* extensions below should mark the
+        # dependency.
+
+	# OES_texture_cube_map
+	( "GL_TEXTURE_BINDING_CUBE_MAP_ARB", GLint,
+	  ["ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name"],
+	  "", None),
+	( "GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB", GLint,
+	  ["(1 << (ctx->Const.MaxCubeTextureLevels - 1))"],
+	  "", None),
+
+        # OES_blend_subtract
+	( "GL_BLEND_SRC_RGB_EXT", GLenum, ["ctx->Color.BlendSrcRGB"], "", None),
+	( "GL_BLEND_DST_RGB_EXT", GLenum, ["ctx->Color.BlendDstRGB"], "", None),
+	( "GL_BLEND_SRC_ALPHA_EXT", GLenum, ["ctx->Color.BlendSrcA"], "", None),
+	( "GL_BLEND_DST_ALPHA_EXT", GLenum, ["ctx->Color.BlendDstA"], "", None),
+
+        # GL_BLEND_EQUATION_RGB, which is what we're really after,
+        # is defined identically to GL_BLEND_EQUATION.
+	( "GL_BLEND_EQUATION", GLenum, ["ctx->Color.BlendEquationRGB "], "", None),
+	( "GL_BLEND_EQUATION_ALPHA_EXT", GLenum, ["ctx->Color.BlendEquationA "],
+	  "", None),
+
+	# GL_ARB_texture_compression */
+#	( "GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB", GLint,
+#	  ["_mesa_get_compressed_formats(ctx, NULL, GL_FALSE)"],
+#	  "", ["ARB_texture_compression"] ),
+#	( "GL_COMPRESSED_TEXTURE_FORMATS_ARB", GLenum,
+#	  [],
+#	  """GLint formats[100];
+#         GLuint i, n = _mesa_get_compressed_formats(ctx, formats, GL_FALSE);
+#         ASSERT(n <= 100);
+#         for (i = 0; i < n; i++)
+#            params[i] = ENUM_TO_INT(formats[i]);""",
+#	  ["ARB_texture_compression"] ),
+
+	# GL_ARB_multisample
+	( "GL_SAMPLE_ALPHA_TO_COVERAGE_ARB", GLboolean,
+	  ["ctx->Multisample.SampleAlphaToCoverage"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLE_COVERAGE_ARB", GLboolean,
+	  ["ctx->Multisample.SampleCoverage"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLE_COVERAGE_VALUE_ARB", GLfloat,
+	  ["ctx->Multisample.SampleCoverageValue"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLE_COVERAGE_INVERT_ARB", GLboolean,
+	  ["ctx->Multisample.SampleCoverageInvert"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLE_BUFFERS_ARB", GLint,
+	  ["ctx->DrawBuffer->Visual.sampleBuffers"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLES_ARB", GLint,
+	  ["ctx->DrawBuffer->Visual.samples"], "", ["ARB_multisample"] ),
+
+
+	# GL_SGIS_generate_mipmap
+	( "GL_GENERATE_MIPMAP_HINT_SGIS", GLenum, ["ctx->Hint.GenerateMipmap"],
+	  "", ["SGIS_generate_mipmap"] ),
+
+	# GL_ARB_vertex_buffer_object
+	( "GL_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ArrayBufferObj->Name"], "", ["ARB_vertex_buffer_object"] ),
+	# GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB - not supported
+	( "GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ElementArrayBufferObj->Name"],
+	  "", ["ARB_vertex_buffer_object"] ),
+
+	# GL_OES_read_format
+	( "GL_IMPLEMENTATION_COLOR_READ_TYPE_OES", GLint,
+	  ["ctx->Const.ColorReadType"], "", None),
+	( "GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES", GLint,
+	  ["ctx->Const.ColorReadFormat"], "", None),
+
+	# GL_OES_framebuffer_object
+	( "GL_FRAMEBUFFER_BINDING_EXT", GLint, ["ctx->DrawBuffer->Name"], "",
+	  None),
+	( "GL_RENDERBUFFER_BINDING_EXT", GLint,
+	  ["ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0"], "",
+	  None),
+	( "GL_MAX_RENDERBUFFER_SIZE_EXT", GLint,
+	  ["ctx->Const.MaxRenderbufferSize"], "",
+	  None),
+
+	# OpenGL ES 1/2 special:
+	( "GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB", GLint,
+	  [ "ARRAY_SIZE(compressed_formats)" ],
+	  "",
+	  None ),
+
+	("GL_COMPRESSED_TEXTURE_FORMATS_ARB", GLint,
+	 [],
+	 """
+     int i;
+     for (i = 0; i < ARRAY_SIZE(compressed_formats); i++) {
+        params[i] = compressed_formats[i];
+     }""",
+	 None ),
+
+	( "GL_POLYGON_OFFSET_FILL", GLboolean, ["ctx->Polygon.OffsetFill"], "", None ),
+
+]
+
+# Only present in ES 1.x:
+StateVars_es1 = [
+	( "GL_MAX_LIGHTS", GLint, ["ctx->Const.MaxLights"], "", None ),
+	( "GL_LIGHT0", GLboolean, ["ctx->Light.Light[0].Enabled"], "", None ),
+	( "GL_LIGHT1", GLboolean, ["ctx->Light.Light[1].Enabled"], "", None ),
+	( "GL_LIGHT2", GLboolean, ["ctx->Light.Light[2].Enabled"], "", None ),
+	( "GL_LIGHT3", GLboolean, ["ctx->Light.Light[3].Enabled"], "", None ),
+	( "GL_LIGHT4", GLboolean, ["ctx->Light.Light[4].Enabled"], "", None ),
+	( "GL_LIGHT5", GLboolean, ["ctx->Light.Light[5].Enabled"], "", None ),
+	( "GL_LIGHT6", GLboolean, ["ctx->Light.Light[6].Enabled"], "", None ),
+	( "GL_LIGHT7", GLboolean, ["ctx->Light.Light[7].Enabled"], "", None ),
+	( "GL_LIGHTING", GLboolean, ["ctx->Light.Enabled"], "", None ),
+	( "GL_LIGHT_MODEL_AMBIENT", GLfloatN,
+	  ["ctx->Light.Model.Ambient[0]",
+	   "ctx->Light.Model.Ambient[1]",
+	   "ctx->Light.Model.Ambient[2]",
+	   "ctx->Light.Model.Ambient[3]"], "", None ),
+	( "GL_LIGHT_MODEL_TWO_SIDE", GLboolean, ["ctx->Light.Model.TwoSide"], "", None ),
+	( "GL_ALPHA_TEST", GLboolean, ["ctx->Color.AlphaEnabled"], "", None ),
+	( "GL_ALPHA_TEST_FUNC", GLenum, ["ctx->Color.AlphaFunc"], "", None ),
+	( "GL_ALPHA_TEST_REF", GLfloatN, ["ctx->Color.AlphaRef"], "", None ),
+	( "GL_BLEND_DST", GLenum, ["ctx->Color.BlendDstRGB"], "", None ),
+	( "GL_MAX_CLIP_PLANES", GLint, ["ctx->Const.MaxClipPlanes"], "", None ),
+	( "GL_CLIP_PLANE0", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 0) & 1" ], "", None ),
+	( "GL_CLIP_PLANE1", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 1) & 1" ], "", None ),
+	( "GL_CLIP_PLANE2", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 2) & 1" ], "", None ),
+	( "GL_CLIP_PLANE3", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 3) & 1" ], "", None ),
+	( "GL_CLIP_PLANE4", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 4) & 1" ], "", None ),
+	( "GL_CLIP_PLANE5", GLboolean,
+	  [ "(ctx->Transform.ClipPlanesEnabled >> 5) & 1" ], "", None ),
+	( "GL_COLOR_MATERIAL", GLboolean,
+	  ["ctx->Light.ColorMaterialEnabled"], "", None ),
+	( "GL_CURRENT_COLOR", GLfloatN,
+	  [ "ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]",
+		"ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]",
+		"ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]",
+		"ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]" ],
+	  "FLUSH_CURRENT(ctx, 0);", None ),
+	( "GL_CURRENT_NORMAL", GLfloatN,
+	  [ "ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]",
+		"ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]",
+		"ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]"],
+	  "FLUSH_CURRENT(ctx, 0);", None ),
+	( "GL_CURRENT_TEXTURE_COORDS", GLfloat,
+	  ["ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0]",
+	   "ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1]",
+	   "ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2]",
+	   "ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3]"],
+	  "const GLuint texUnit = ctx->Texture.CurrentUnit;", None ),
+	( "GL_DISTANCE_ATTENUATION_EXT", GLfloat,
+	  ["ctx->Point.Params[0]",
+	   "ctx->Point.Params[1]",
+	   "ctx->Point.Params[2]"], "", None ),
+	( "GL_FOG", GLboolean, ["ctx->Fog.Enabled"], "", None ),
+	( "GL_FOG_COLOR", GLfloatN,
+	  [ "ctx->Fog.Color[0]",
+		"ctx->Fog.Color[1]",
+		"ctx->Fog.Color[2]",
+		"ctx->Fog.Color[3]" ], "", None ),
+	( "GL_FOG_DENSITY", GLfloat, ["ctx->Fog.Density"], "", None ),
+	( "GL_FOG_END", GLfloat, ["ctx->Fog.End"], "", None ),
+	( "GL_FOG_HINT", GLenum, ["ctx->Hint.Fog"], "", None ),
+	( "GL_FOG_MODE", GLenum, ["ctx->Fog.Mode"], "", None ),
+	( "GL_FOG_START", GLfloat, ["ctx->Fog.Start"], "", None ),
+	( "GL_LINE_SMOOTH", GLboolean, ["ctx->Line.SmoothFlag"], "", None ),
+	( "GL_LINE_SMOOTH_HINT", GLenum, ["ctx->Hint.LineSmooth"], "", None ),
+	( "GL_LINE_WIDTH_RANGE", GLfloat,
+	  ["ctx->Const.MinLineWidthAA",
+	   "ctx->Const.MaxLineWidthAA"], "", None ),
+	( "GL_COLOR_LOGIC_OP", GLboolean, ["ctx->Color.ColorLogicOpEnabled"], "", None ),
+	( "GL_LOGIC_OP_MODE", GLenum, ["ctx->Color.LogicOp"], "", None ),
+	( "GL_MATRIX_MODE", GLenum, ["ctx->Transform.MatrixMode"], "", None ),
+
+	( "GL_MAX_MODELVIEW_STACK_DEPTH", GLint, ["MAX_MODELVIEW_STACK_DEPTH"], "", None ),
+	( "GL_MAX_PROJECTION_STACK_DEPTH", GLint, ["MAX_PROJECTION_STACK_DEPTH"], "", None ),
+	( "GL_MAX_TEXTURE_STACK_DEPTH", GLint, ["MAX_TEXTURE_STACK_DEPTH"], "", None ),
+	( "GL_MODELVIEW_MATRIX", GLfloat,
+	  [ "matrix[0]", "matrix[1]", "matrix[2]", "matrix[3]",
+		"matrix[4]", "matrix[5]", "matrix[6]", "matrix[7]",
+		"matrix[8]", "matrix[9]", "matrix[10]", "matrix[11]",
+		"matrix[12]", "matrix[13]", "matrix[14]", "matrix[15]" ],
+	  "const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;", None ),
+	( "GL_MODELVIEW_STACK_DEPTH", GLint, ["ctx->ModelviewMatrixStack.Depth + 1"], "", None ),
+	( "GL_NORMALIZE", GLboolean, ["ctx->Transform.Normalize"], "", None ),
+	( "GL_PACK_SKIP_IMAGES_EXT", GLint, ["ctx->Pack.SkipImages"], "", None ),
+	( "GL_PERSPECTIVE_CORRECTION_HINT", GLenum,
+	  ["ctx->Hint.PerspectiveCorrection"], "", None ),
+	( "GL_POINT_SIZE", GLfloat, ["ctx->Point.Size"], "", None ),
+	( "GL_POINT_SIZE_RANGE", GLfloat,
+	  ["ctx->Const.MinPointSizeAA",
+	   "ctx->Const.MaxPointSizeAA"], "", None ),
+	( "GL_POINT_SMOOTH", GLboolean, ["ctx->Point.SmoothFlag"], "", None ),
+	( "GL_POINT_SMOOTH_HINT", GLenum, ["ctx->Hint.PointSmooth"], "", None ),
+	( "GL_POINT_SIZE_MIN_EXT", GLfloat, ["ctx->Point.MinSize"], "", None ),
+	( "GL_POINT_SIZE_MAX_EXT", GLfloat, ["ctx->Point.MaxSize"], "", None ),
+	( "GL_POINT_FADE_THRESHOLD_SIZE_EXT", GLfloat,
+	  ["ctx->Point.Threshold"], "", None ),
+	( "GL_PROJECTION_MATRIX", GLfloat,
+	  [ "matrix[0]", "matrix[1]", "matrix[2]", "matrix[3]",
+		"matrix[4]", "matrix[5]", "matrix[6]", "matrix[7]",
+		"matrix[8]", "matrix[9]", "matrix[10]", "matrix[11]",
+		"matrix[12]", "matrix[13]", "matrix[14]", "matrix[15]" ],
+	  "const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;", None ),
+	( "GL_PROJECTION_STACK_DEPTH", GLint,
+	  ["ctx->ProjectionMatrixStack.Depth + 1"], "", None ),
+	( "GL_RESCALE_NORMAL", GLboolean,
+	  ["ctx->Transform.RescaleNormals"], "", None ),
+	( "GL_SHADE_MODEL", GLenum, ["ctx->Light.ShadeModel"], "", None ),
+	( "GL_TEXTURE_2D", GLboolean, ["_mesa_IsEnabled(GL_TEXTURE_2D)"], "", None ),
+	( "GL_TEXTURE_MATRIX", GLfloat,
+	  ["matrix[0]", "matrix[1]", "matrix[2]", "matrix[3]",
+	   "matrix[4]", "matrix[5]", "matrix[6]", "matrix[7]",
+	   "matrix[8]", "matrix[9]", "matrix[10]", "matrix[11]",
+	   "matrix[12]", "matrix[13]", "matrix[14]", "matrix[15]" ],
+	  "const GLfloat *matrix = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;", None ),
+	( "GL_TEXTURE_STACK_DEPTH", GLint,
+	  ["ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1"], "", None ),
+	( "GL_VERTEX_ARRAY", GLboolean, ["ctx->Array.ArrayObj->Vertex.Enabled"], "", None ),
+	( "GL_VERTEX_ARRAY_SIZE", GLint, ["ctx->Array.ArrayObj->Vertex.Size"], "", None ),
+	( "GL_VERTEX_ARRAY_TYPE", GLenum, ["ctx->Array.ArrayObj->Vertex.Type"], "", None ),
+	( "GL_VERTEX_ARRAY_STRIDE", GLint, ["ctx->Array.ArrayObj->Vertex.Stride"], "", None ),
+	( "GL_NORMAL_ARRAY", GLenum, ["ctx->Array.ArrayObj->Normal.Enabled"], "", None ),
+	( "GL_NORMAL_ARRAY_TYPE", GLenum, ["ctx->Array.ArrayObj->Normal.Type"], "", None ),
+	( "GL_NORMAL_ARRAY_STRIDE", GLint, ["ctx->Array.ArrayObj->Normal.Stride"], "", None ),
+	( "GL_COLOR_ARRAY", GLboolean, ["ctx->Array.ArrayObj->Color.Enabled"], "", None ),
+	( "GL_COLOR_ARRAY_SIZE", GLint, ["ctx->Array.ArrayObj->Color.Size"], "", None ),
+	( "GL_COLOR_ARRAY_TYPE", GLenum, ["ctx->Array.ArrayObj->Color.Type"], "", None ),
+	( "GL_COLOR_ARRAY_STRIDE", GLint, ["ctx->Array.ArrayObj->Color.Stride"], "", None ),
+	( "GL_TEXTURE_COORD_ARRAY", GLboolean,
+	  ["ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled"], "", None ),
+	( "GL_TEXTURE_COORD_ARRAY_SIZE", GLint,
+	  ["ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size"], "", None ),
+	( "GL_TEXTURE_COORD_ARRAY_TYPE", GLenum,
+	  ["ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type"], "", None ),
+	( "GL_TEXTURE_COORD_ARRAY_STRIDE", GLint,
+	  ["ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride"], "", None ),
+	# GL_ARB_multitexture
+	( "GL_MAX_TEXTURE_UNITS_ARB", GLint,
+	  ["ctx->Const.MaxTextureUnits"], "", ["ARB_multitexture"] ),
+	( "GL_CLIENT_ACTIVE_TEXTURE_ARB", GLint,
+	  ["GL_TEXTURE0_ARB + ctx->Array.ActiveTexture"], "", ["ARB_multitexture"] ),
+        # OES_texture_cube_map
+	( "GL_TEXTURE_CUBE_MAP_ARB", GLboolean,
+	  ["_mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB)"], "", None),
+	( "GL_TEXTURE_GEN_S", GLboolean,
+	  ["((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0)"], "", None),
+	( "GL_TEXTURE_GEN_T", GLboolean,
+	  ["((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & T_BIT) ? 1 : 0)"], "", None),
+	( "GL_TEXTURE_GEN_R", GLboolean,
+	  ["((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & R_BIT) ? 1 : 0)"], "", None),
+        # ARB_multisample
+	( "GL_MULTISAMPLE_ARB", GLboolean,
+	  ["ctx->Multisample.Enabled"], "", ["ARB_multisample"] ),
+	( "GL_SAMPLE_ALPHA_TO_ONE_ARB", GLboolean,
+	  ["ctx->Multisample.SampleAlphaToOne"], "", ["ARB_multisample"] ),
+
+	( "GL_VERTEX_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ArrayObj->Vertex.BufferObj->Name"], "", ["ARB_vertex_buffer_object"] ),
+	( "GL_NORMAL_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ArrayObj->Normal.BufferObj->Name"], "", ["ARB_vertex_buffer_object"] ),
+	( "GL_COLOR_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ArrayObj->Color.BufferObj->Name"], "", ["ARB_vertex_buffer_object"] ),
+	( "GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB", GLint,
+	  ["ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name"],
+	  "", ["ARB_vertex_buffer_object"] ),
+
+	# OES_point_sprite
+	( "GL_POINT_SPRITE_NV", GLboolean, ["ctx->Point.PointSprite"], # == GL_POINT_SPRITE_ARB
+	  "", None),
+
+	# GL_ARB_fragment_shader
+	( "GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB", GLint,
+	  ["ctx->Const.FragmentProgram.MaxUniformComponents"], "",
+	  ["ARB_fragment_shader"] ),
+
+        # GL_ARB_vertex_shader
+	( "GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB", GLint,
+	  ["ctx->Const.VertexProgram.MaxUniformComponents"], "",
+	  ["ARB_vertex_shader"] ),
+	( "GL_MAX_VARYING_FLOATS_ARB", GLint,
+	  ["ctx->Const.MaxVarying * 4"], "", ["ARB_vertex_shader"] ),
+
+        # OES_matrix_get
+	( "GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES", GLint, [],
+	  """
+      /* See GL_OES_matrix_get */
+      {
+         const GLfloat *matrix = ctx->ModelviewMatrixStack.Top->m;
+         memcpy(params, matrix, 16 * sizeof(GLint));
+      }""",
+	  None),
+
+	( "GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES", GLint, [],
+	  """
+      /* See GL_OES_matrix_get */
+      {
+         const GLfloat *matrix = ctx->ProjectionMatrixStack.Top->m;
+         memcpy(params, matrix, 16 * sizeof(GLint));
+      }""",
+	  None),
+
+	( "GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES", GLint, [],
+	  """
+      /* See GL_OES_matrix_get */
+      {
+         const GLfloat *matrix =
+            ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Top->m;
+         memcpy(params, matrix, 16 * sizeof(GLint));
+      }""",
+	  None),
+
+        # OES_point_size_array
+	("GL_POINT_SIZE_ARRAY_OES", GLboolean,
+	 ["ctx->Array.ArrayObj->PointSize.Enabled"], "", None),
+	("GL_POINT_SIZE_ARRAY_TYPE_OES", GLenum,
+      ["ctx->Array.ArrayObj->PointSize.Type"], "", None),
+	("GL_POINT_SIZE_ARRAY_STRIDE_OES", GLint,
+	 ["ctx->Array.ArrayObj->PointSize.Stride"], "", None),
+	("GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES", GLint,
+	 ["ctx->Array.ArrayObj->PointSize.BufferObj->Name"], "", None),
+
+	# GL_EXT_texture_filter_anisotropic
+	( "GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT", GLfloat,
+	  ["ctx->Const.MaxTextureMaxAnisotropy"], "", ["EXT_texture_filter_anisotropic"]),
+
+]
+
+# Only present in ES 2.x:
+StateVars_es2 = [
+	# XXX These entries are not spec'ed for GLES 2, but are
+        #     needed for Mesa's GLSL:
+	( "GL_MAX_LIGHTS", GLint, ["ctx->Const.MaxLights"], "", None ),
+	( "GL_MAX_CLIP_PLANES", GLint, ["ctx->Const.MaxClipPlanes"], "", None ),
+        ( "GL_MAX_TEXTURE_COORDS_ARB", GLint, # == GL_MAX_TEXTURE_COORDS_NV
+          ["ctx->Const.MaxTextureCoordUnits"], "",
+          ["ARB_fragment_program", "NV_fragment_program"] ),
+	( "GL_MAX_DRAW_BUFFERS_ARB", GLint,
+	  ["ctx->Const.MaxDrawBuffers"], "", ["ARB_draw_buffers"] ),
+	( "GL_BLEND_COLOR_EXT", GLfloatN,
+	  [ "ctx->Color.BlendColor[0]",
+		"ctx->Color.BlendColor[1]",
+		"ctx->Color.BlendColor[2]",
+		"ctx->Color.BlendColor[3]"], "", None ),
+
+        # This is required for GLES2, but also needed for GLSL:
+        ( "GL_MAX_TEXTURE_IMAGE_UNITS_ARB", GLint, # == GL_MAX_TEXTURE_IMAGE_UNI
+          ["ctx->Const.MaxTextureImageUnits"], "",
+          ["ARB_fragment_program", "NV_fragment_program"] ),
+
+	( "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB", GLint,
+	  ["ctx->Const.MaxVertexTextureImageUnits"], "", ["ARB_vertex_shader"] ),
+	( "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB", GLint,
+	  ["MAX_COMBINED_TEXTURE_IMAGE_UNITS"], "", ["ARB_vertex_shader"] ),
+
+	# GL_ARB_shader_objects
+	# Actually, this token isn't part of GL_ARB_shader_objects, but is
+	# close enough for now.
+	( "GL_CURRENT_PROGRAM", GLint,
+	  ["ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0"],
+	  "", ["ARB_shader_objects"] ),
+
+	# OpenGL 2.0
+	( "GL_STENCIL_BACK_FUNC", GLenum, ["ctx->Stencil.Function[1]"], "", None ),
+	( "GL_STENCIL_BACK_VALUE_MASK", GLint, ["ctx->Stencil.ValueMask[1]"], "", None ),
+	( "GL_STENCIL_BACK_WRITEMASK", GLint, ["ctx->Stencil.WriteMask[1]"], "", None ),
+	( "GL_STENCIL_BACK_REF", GLint, ["ctx->Stencil.Ref[1]"], "", None ),
+	( "GL_STENCIL_BACK_FAIL", GLenum, ["ctx->Stencil.FailFunc[1]"], "", None ),
+	( "GL_STENCIL_BACK_PASS_DEPTH_FAIL", GLenum, ["ctx->Stencil.ZFailFunc[1]"], "", None ),
+	( "GL_STENCIL_BACK_PASS_DEPTH_PASS", GLenum, ["ctx->Stencil.ZPassFunc[1]"], "", None ),
+
+	( "GL_MAX_VERTEX_ATTRIBS_ARB", GLint,
+	  ["ctx->Const.VertexProgram.MaxAttribs"], "", ["ARB_vertex_program"] ),
+
+        # OES_texture_3D 
+	( "GL_TEXTURE_BINDING_3D", GLint,
+	  ["ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name"], "", None),
+	( "GL_MAX_3D_TEXTURE_SIZE", GLint, ["1 << (ctx->Const.Max3DTextureLevels - 1)"], "", None),
+
+        # OES_standard_derivatives
+	( "GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB", GLenum,
+	  ["ctx->Hint.FragmentShaderDerivative"], "", ["ARB_fragment_shader"] ),
+
+	# Unique to ES 2 (not in full GL)
+	( "GL_MAX_FRAGMENT_UNIFORM_VECTORS", GLint,
+	  ["ctx->Const.FragmentProgram.MaxUniformComponents / 4"], "", None),
+	( "GL_MAX_VARYING_VECTORS", GLint,
+	  ["ctx->Const.MaxVarying"], "", None),
+	( "GL_MAX_VERTEX_UNIFORM_VECTORS", GLint,
+	  ["ctx->Const.VertexProgram.MaxUniformComponents / 4"], "", None),
+	( "GL_SHADER_COMPILER", GLint, ["1"], "", None),
+        # OES_get_program_binary
+	( "GL_NUM_SHADER_BINARY_FORMATS", GLint, ["0"], "", None),
+	( "GL_SHADER_BINARY_FORMATS", GLint, [], "", None),
+]
+
+
+
+def ConversionFunc(fromType, toType):
+	"""Return the name of the macro to convert between two data types."""
+	if fromType == toType:
+		return ""
+	elif fromType == GLfloat and toType == GLint:
+		return "IROUND"
+	elif fromType == GLfloatN and toType == GLfloat:
+		return ""
+	elif fromType == GLint and toType == GLfloat: # but not GLfloatN!
+		return "(GLfloat)"
+	else:
+		if fromType == GLfloatN:
+			fromType = GLfloat
+		fromStr = TypeStrings[fromType]
+		fromStr = string.upper(fromStr[2:])
+		toStr = TypeStrings[toType]
+		toStr = string.upper(toStr[2:])
+		return fromStr + "_TO_" + toStr
+
+
+def EmitGetFunction(stateVars, returnType):
+	"""Emit the code to implement glGetBooleanv, glGetIntegerv or glGetFloatv."""
+	assert (returnType == GLboolean or
+			returnType == GLint or
+			returnType == GLfloat)
+
+	strType = TypeStrings[returnType]
+	# Capitalize first letter of return type
+	if returnType == GLint:
+		function = "_mesa_GetIntegerv"
+	elif returnType == GLboolean:
+		function = "_mesa_GetBooleanv"
+	elif returnType == GLfloat:
+		function = "_mesa_GetFloatv"
+	else:
+		abort()
+
+	print "void GLAPIENTRY"
+	print "%s( GLenum pname, %s *params )" % (function, strType)
+	print "{"
+	print "   GET_CURRENT_CONTEXT(ctx);"
+	print "   ASSERT_OUTSIDE_BEGIN_END(ctx);"
+	print ""
+	print "   if (!params)"
+	print "      return;"
+	print ""
+	print "   if (ctx->NewState)"
+	print "      _mesa_update_state(ctx);"
+	print ""
+	print "   switch (pname) {"
+
+	for (name, varType, state, optionalCode, extensions) in stateVars:
+		print "      case " + name + ":"
+		if extensions:
+			if len(extensions) == 1:
+				print ('         CHECK_EXT1(%s, "%s");' %
+					   (extensions[0], function))
+			elif len(extensions) == 2:
+				print ('         CHECK_EXT2(%s, %s, "%s");' %
+					   (extensions[0], extensions[1], function))
+			elif len(extensions) == 3:
+				print ('         CHECK_EXT3(%s, %s, %s, "%s");' %
+					   (extensions[0], extensions[1], extensions[2], function))
+			else:
+				assert len(extensions) == 4
+				print ('         CHECK_EXT4(%s, %s, %s, %s, "%s");' %
+					   (extensions[0], extensions[1], extensions[2], extensions[3], function))
+		if optionalCode:
+			print "         {"
+			print "         " + optionalCode
+		conversion = ConversionFunc(varType, returnType)
+		n = len(state)
+		for i in range(n):
+			if conversion:
+				print "         params[%d] = %s(%s);" % (i, conversion, state[i])
+			else:
+				print "         params[%d] = %s;" % (i, state[i])
+		if optionalCode:
+			print "         }"
+		print "         break;"
+
+	print "      default:"
+	print '         _mesa_error(ctx, GL_INVALID_ENUM, "gl%s(pname=0x%%x)", pname);' % function
+	print "   }"
+	print "}"
+	print ""
+	return
+
+
+
+def EmitHeader():
+	"""Print the get.c file header."""
+	print """
+/***
+ ***  NOTE!!!  DO NOT EDIT THIS FILE!!!  IT IS GENERATED BY get_gen.py
+ ***/
+
+#include "main/glheader.h"
+#include "main/context.h"
+#include "main/enable.h"
+#include "main/extensions.h"
+#include "main/fbobject.h"
+#include "main/get.h"
+#include "main/macros.h"
+#include "main/mtypes.h"
+#include "main/state.h"
+#include "main/texcompress.h"
+
+
+/* ES1 tokens that should be in gl.h but aren't */
+#define GL_MAX_ELEMENTS_INDICES             0x80E9
+#define GL_MAX_ELEMENTS_VERTICES            0x80E8
+
+
+/* ES2 special tokens */
+#define GL_MAX_FRAGMENT_UNIFORM_VECTORS     0x8DFD
+#define GL_MAX_VARYING_VECTORS              0x8DFC
+#define GL_MAX_VARYING_VECTORS              0x8DFC
+#define GL_MAX_VERTEX_UNIFORM_VECTORS       0x8DFB
+#define GL_SHADER_COMPILER                  0x8DFA
+#define GL_PLATFORM_BINARY                  0x8D63
+#define GL_SHADER_BINARY_FORMATS            0x8DF8
+#define GL_NUM_SHADER_BINARY_FORMATS        0x8DF9
+
+
+#ifndef GL_OES_matrix_get
+#define GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES               0x898D
+#define GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES              0x898E
+#define GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES                 0x898F
+#endif
+
+#ifndef GL_OES_compressed_paletted_texture
+#define GL_PALETTE4_RGB8_OES                                    0x8B90
+#define GL_PALETTE4_RGBA8_OES                                   0x8B91
+#define GL_PALETTE4_R5_G6_B5_OES                                0x8B92
+#define GL_PALETTE4_RGBA4_OES                                   0x8B93
+#define GL_PALETTE4_RGB5_A1_OES                                 0x8B94
+#define GL_PALETTE8_RGB8_OES                                    0x8B95
+#define GL_PALETTE8_RGBA8_OES                                   0x8B96
+#define GL_PALETTE8_R5_G6_B5_OES                                0x8B97
+#define GL_PALETTE8_RGBA4_OES                                   0x8B98
+#define GL_PALETTE8_RGB5_A1_OES                                 0x8B99
+#endif
+
+
+#define FLOAT_TO_BOOLEAN(X)   ( (X) ? GL_TRUE : GL_FALSE )
+
+#define INT_TO_BOOLEAN(I)     ( (I) ? GL_TRUE : GL_FALSE )
+
+#define BOOLEAN_TO_INT(B)     ( (GLint) (B) )
+#define BOOLEAN_TO_FLOAT(B)   ( (B) ? 1.0F : 0.0F )
+
+
+/*
+ * Check if named extension is enabled, if not generate error and return.
+ */
+#define CHECK_EXT1(EXT1, FUNC)                                         \\
+   if (!ctx->Extensions.EXT1) {                                        \\
+      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \\
+      return;                                                          \\
+   }
+
+/*
+ * Check if either of two extensions is enabled.
+ */
+#define CHECK_EXT2(EXT1, EXT2, FUNC)                                   \\
+   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2) {               \\
+      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \\
+      return;                                                          \\
+   }
+
+/*
+ * Check if either of three extensions is enabled.
+ */
+#define CHECK_EXT3(EXT1, EXT2, EXT3, FUNC)                             \\
+   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2 &&               \\
+       !ctx->Extensions.EXT3) {                                        \\
+      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \\
+      return;                                                          \\
+   }
+
+/*
+ * Check if either of four extensions is enabled.
+ */
+#define CHECK_EXT4(EXT1, EXT2, EXT3, EXT4, FUNC)                       \\
+   if (!ctx->Extensions.EXT1 && !ctx->Extensions.EXT2 &&               \\
+       !ctx->Extensions.EXT3 && !ctx->Extensions.EXT4) {               \\
+      _mesa_error(ctx, GL_INVALID_ENUM, FUNC "(0x%x)", (int) pname);  \\
+      return;                                                          \\
+   }
+
+
+
+/**
+ * List of compressed texture formats supported by ES.
+ */
+static GLenum compressed_formats[] = {
+   GL_PALETTE4_RGB8_OES,
+   GL_PALETTE4_RGBA8_OES,
+   GL_PALETTE4_R5_G6_B5_OES,
+   GL_PALETTE4_RGBA4_OES,
+   GL_PALETTE4_RGB5_A1_OES,
+   GL_PALETTE8_RGB8_OES,
+   GL_PALETTE8_RGBA8_OES,
+   GL_PALETTE8_R5_G6_B5_OES,
+   GL_PALETTE8_RGBA4_OES,
+   GL_PALETTE8_RGB5_A1_OES
+};
+
+#define ARRAY_SIZE(A)  (sizeof(A) / sizeof(A[0]))
+
+"""
+	return
+
+
+def EmitAll(stateVars):
+	EmitHeader()
+	EmitGetFunction(stateVars, GLboolean)
+	EmitGetFunction(stateVars, GLfloat)
+	EmitGetFunction(stateVars, GLint)
+
+
+def main(args):
+	# Determine whether to generate ES1 or ES2 queries
+	if len(args) > 1 and args[1] == "1":
+		API = 1
+	elif len(args) > 1 and args[1] == "2":
+		API = 2
+	else:
+		API = 1
+	#print "len args = %d  API = %d" % (len(args), API)
+
+	if API == 1:
+		vars = StateVars_common + StateVars_es1
+	else:
+		vars = StateVars_common + StateVars_es2
+
+	EmitAll(vars)
+
+
+main(sys.argv)
diff --git a/src/mesa/es/main/mfeatures.h b/src/mesa/es/main/mfeatures.h
new file mode 100644
index 0000000..b9cd251
--- /dev/null
+++ b/src/mesa/es/main/mfeatures.h
@@ -0,0 +1,106 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+/**
+ * \file mfeatures.h
+ *
+ * The #defines in this file enable/disable Mesa features needed
+ * for OpenGL ES 1.1 / 2.0
+ */
+
+
+#ifndef MFEATURES_H
+#define MFEATURES_H
+
+/* this file replaces main/mfeatures.h */
+#ifdef FEATURES_H
+#error "main/mfeatures.h was wrongly included"
+#endif
+#define FEATURES_H
+
+/*
+ * Enable/disable features (blocks of code) by setting FEATURE_xyz to 0 or 1.
+ */
+#ifndef _HAVE_FULL_GL
+#define _HAVE_FULL_GL 1
+#endif
+
+#define FEATURE_accum 0
+#define FEATURE_attrib_stack 0
+#define FEATURE_colortable 0
+#define FEATURE_convolution 0
+#define FEATURE_dispatch 1
+#define FEATURE_dlist 0
+#define FEATURE_draw_read_buffer 0
+#define FEATURE_drawpix 0
+#define FEATURE_es2_glsl 1
+#define FEATURE_evaluators 0
+#define FEATURE_feedback 0
+#define FEATURE_fixedpt 1
+#define FEATURE_histogram 0
+#define FEATURE_pixeltransfer 0
+#define FEATURE_point_size_array 1
+#define FEATURE_texgen 1
+#define FEATURE_texture_fxt1 0
+#define FEATURE_texture_s3tc 0
+#define FEATURE_userclip 1
+#define FEATURE_vertex_array_byte 1
+
+#define FEATURE_ARB_occlusion_query 0
+#define FEATURE_ARB_fragment_program  _HAVE_FULL_GL
+#define FEATURE_ARB_vertex_buffer_object  _HAVE_FULL_GL
+#define FEATURE_ARB_vertex_program  _HAVE_FULL_GL
+
+#define FEATURE_ARB_vertex_shader _HAVE_FULL_GL
+#define FEATURE_ARB_fragment_shader _HAVE_FULL_GL
+#define FEATURE_ARB_shader_objects (FEATURE_ARB_vertex_shader || FEATURE_ARB_fragment_shader)
+#define FEATURE_ARB_shading_language_100 FEATURE_ARB_shader_objects
+#define FEATURE_ARB_shading_language_120 FEATURE_ARB_shader_objects
+
+#define FEATURE_EXT_framebuffer_blit 0
+#define FEATURE_EXT_framebuffer_object _HAVE_FULL_GL
+#define FEATURE_EXT_pixel_buffer_object  _HAVE_FULL_GL
+#define FEATURE_EXT_texture_sRGB 0
+#define FEATURE_EXT_timer_query 0
+#define FEATURE_ATI_fragment_shader 0
+#define FEATURE_MESA_program_debug  _HAVE_FULL_GL
+#define FEATURE_NV_fence 0
+#define FEATURE_NV_fragment_program 0
+#define FEATURE_NV_vertex_program 0
+
+#define FEATURE_OES_framebuffer_object 1
+#define FEATURE_OES_draw_texture 1
+#define FEATURE_OES_mapbuffer 1
+
+#define FEATURE_extra_context_init 1
+
+/*@}*/
+
+
+
+
+#endif /* MFEATURES_H */
diff --git a/src/mesa/es/main/pixel.c b/src/mesa/es/main/pixel.c
new file mode 100644
index 0000000..104ec8b
--- /dev/null
+++ b/src/mesa/es/main/pixel.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2008  Tungsten Graphics, Inc.
+ */
+
+
+
+#include "main/glheader.h"
+#include "main/context.h"
+#include "main/macros.h"
+#include "main/pixel.h"
+
+
+static void
+init_pixelmap(struct gl_pixelmap *map)
+{
+   map->Size = 1;
+   map->Map[0] = 0.0;
+   map->Map8[0] = 0;
+}
+
+
+
+/**
+ * Initialize the context's PIXEL attribute group.
+ */
+void
+_mesa_init_pixel( GLcontext *ctx )
+{
+   int i;
+
+   /* Pixel group */
+   ctx->Pixel.RedBias = 0.0;
+   ctx->Pixel.RedScale = 1.0;
+   ctx->Pixel.GreenBias = 0.0;
+   ctx->Pixel.GreenScale = 1.0;
+   ctx->Pixel.BlueBias = 0.0;
+   ctx->Pixel.BlueScale = 1.0;
+   ctx->Pixel.AlphaBias = 0.0;
+   ctx->Pixel.AlphaScale = 1.0;
+   ctx->Pixel.DepthBias = 0.0;
+   ctx->Pixel.DepthScale = 1.0;
+   ctx->Pixel.IndexOffset = 0;
+   ctx->Pixel.IndexShift = 0;
+   ctx->Pixel.ZoomX = 1.0;
+   ctx->Pixel.ZoomY = 1.0;
+   ctx->Pixel.MapColorFlag = GL_FALSE;
+   ctx->Pixel.MapStencilFlag = GL_FALSE;
+   init_pixelmap(&ctx->PixelMaps.StoS);
+   init_pixelmap(&ctx->PixelMaps.ItoI);
+   init_pixelmap(&ctx->PixelMaps.ItoR);
+   init_pixelmap(&ctx->PixelMaps.ItoG);
+   init_pixelmap(&ctx->PixelMaps.ItoB);
+   init_pixelmap(&ctx->PixelMaps.ItoA);
+   init_pixelmap(&ctx->PixelMaps.RtoR);
+   init_pixelmap(&ctx->PixelMaps.GtoG);
+   init_pixelmap(&ctx->PixelMaps.BtoB);
+   init_pixelmap(&ctx->PixelMaps.AtoA);
+   ctx->Pixel.HistogramEnabled = GL_FALSE;
+   ctx->Pixel.MinMaxEnabled = GL_FALSE;
+   ASSIGN_4V(ctx->Pixel.PostColorMatrixScale, 1.0, 1.0, 1.0, 1.0);
+   ASSIGN_4V(ctx->Pixel.PostColorMatrixBias, 0.0, 0.0, 0.0, 0.0);
+   for (i = 0; i < COLORTABLE_MAX; i++) {
+      ASSIGN_4V(ctx->Pixel.ColorTableScale[i], 1.0, 1.0, 1.0, 1.0);
+      ASSIGN_4V(ctx->Pixel.ColorTableBias[i], 0.0, 0.0, 0.0, 0.0);
+      ctx->Pixel.ColorTableEnabled[i] = GL_FALSE;
+   }
+   ctx->Pixel.Convolution1DEnabled = GL_FALSE;
+   ctx->Pixel.Convolution2DEnabled = GL_FALSE;
+   ctx->Pixel.Separable2DEnabled = GL_FALSE;
+   for (i = 0; i < 3; i++) {
+      ASSIGN_4V(ctx->Pixel.ConvolutionBorderColor[i], 0.0, 0.0, 0.0, 0.0);
+      ctx->Pixel.ConvolutionBorderMode[i] = GL_REDUCE;
+      ASSIGN_4V(ctx->Pixel.ConvolutionFilterScale[i], 1.0, 1.0, 1.0, 1.0);
+      ASSIGN_4V(ctx->Pixel.ConvolutionFilterBias[i], 0.0, 0.0, 0.0, 0.0);
+   }
+   for (i = 0; i < MAX_CONVOLUTION_WIDTH * MAX_CONVOLUTION_WIDTH * 4; i++) {
+      ctx->Convolution1D.Filter[i] = 0.0;
+      ctx->Convolution2D.Filter[i] = 0.0;
+      ctx->Separable2D.Filter[i] = 0.0;
+   }
+   ASSIGN_4V(ctx->Pixel.PostConvolutionScale, 1.0, 1.0, 1.0, 1.0);
+   ASSIGN_4V(ctx->Pixel.PostConvolutionBias, 0.0, 0.0, 0.0, 0.0);
+   /* GL_SGI_texture_color_table */
+   ASSIGN_4V(ctx->Pixel.TextureColorTableScale, 1.0, 1.0, 1.0, 1.0);
+   ASSIGN_4V(ctx->Pixel.TextureColorTableBias, 0.0, 0.0, 0.0, 0.0);
+
+   if (ctx->Visual.doubleBufferMode) {
+      ctx->Pixel.ReadBuffer = GL_BACK;
+   }
+   else {
+      ctx->Pixel.ReadBuffer = GL_FRONT;
+   }
+
+   /* Miscellaneous */
+   ctx->_ImageTransferState = 0;
+}
diff --git a/src/mesa/es/main/specials_es1.c b/src/mesa/es/main/specials_es1.c
new file mode 100644
index 0000000..a7b42d1
--- /dev/null
+++ b/src/mesa/es/main/specials_es1.c
@@ -0,0 +1,118 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * TUNGSTEN GRAPHICS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ **************************************************************************/
+
+#include "GLES/glplatform.h"
+
+#include "main/imports.h"
+#include "main/get.h"
+
+/**
+ * Note: a more dynamic solution would be query the underlying GL
+ * and translate extension names...
+ */
+static const char *
+extension_string(void)
+{
+   return 
+      /* Core additions */
+      "GL_OES_byte_coordinates "
+      "GL_OES_fixed_point "
+      "GL_OES_single_precision "
+      "GL_OES_matrix_get "
+
+      /* 1.1 required extensions */
+      "GL_OES_read_format "
+      "GL_OES_compressed_paletted_texture "
+      "GL_OES_point_size_array "
+      "GL_OES_point_sprite "
+
+      /* 1.1 optional extensions */
+      "GL_OES_draw_texture "
+
+      /* 1.1 deprecated extensions */
+      "GL_OES_query_matrix "
+
+      /* Newer extensions */
+      "GL_OES_blend_equation_separate "
+      "GL_OES_blend_func_separate "
+      "GL_OES_blend_subtract "
+      "GL_OES_depth24 "
+      "GL_OES_depth32 "
+      "GL_OES_element_index_uint "
+      "GL_OES_fbo_render_mipmap "
+      "GL_OES_framebuffer_object "
+      "GL_OES_mapbuffer "
+      "GL_OES_rgb8_rgba8 "
+      "GL_OES_stencil1 "
+      "GL_OES_stencil4 "
+      "GL_OES_stencil8 "
+      "GL_OES_texture_cube_map "
+      "GL_OES_texture_env_crossbar "
+      "GL_OES_texture_mirrored_repeat "
+      "GL_EXT_texture_filter_anisotropic "
+      ;
+}
+
+const GLubyte * GLAPIENTRY _es_GetString(GLenum name);
+const GLubyte * GLAPIENTRY
+_es_GetString(GLenum name)
+{
+   switch (name) {
+   case GL_VERSION:
+      return (GLubyte *) "OpenGL ES-CM 1.1";
+   case GL_VENDOR:
+      return (GLubyte *) "Tungsten Graphics, Inc.";
+   case GL_EXTENSIONS:
+      return (GLubyte *) extension_string();
+   default:
+      return _mesa_GetString(name);
+   }
+}
+
+/* There's insufficient support in Mesa to allow a direct
+ * query of GL_POINT_SIZE_ARRAY_POINTER_OES, although
+ * the data is there.  This hack grabs the data directly in
+ * that case, and goes through Mesa for all other cases.
+ */
+void GLAPIENTRY _es_GetPointerv(GLenum pname, GLvoid **params);
+void GLAPIENTRY
+_es_GetPointerv(GLenum pname, GLvoid **params)
+{
+   GET_CURRENT_CONTEXT(ctx);
+
+   switch(pname) {
+      case GL_POINT_SIZE_ARRAY_POINTER_OES:
+         *params = (GLvoid *) ctx->Array.ArrayObj->PointSize.Ptr;
+         break;
+      case GL_COLOR_ARRAY_POINTER:
+      case GL_NORMAL_ARRAY_POINTER:
+      case GL_TEXTURE_COORD_ARRAY_POINTER:
+      case GL_VERTEX_ARRAY_POINTER:
+         _mesa_GetPointerv(pname, params);
+         break;
+      default:
+         _mesa_error(ctx, GL_INVALID_ENUM, "GetPointerv");
+         return;
+   } 
+}
diff --git a/src/mesa/es/main/specials_es2.c b/src/mesa/es/main/specials_es2.c
new file mode 100644
index 0000000..447ebe8
--- /dev/null
+++ b/src/mesa/es/main/specials_es2.c
@@ -0,0 +1,80 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * TUNGSTEN GRAPHICS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ **************************************************************************/
+
+#include "GLES/glplatform.h"
+
+#include "main/imports.h"
+#include "main/get.h"
+
+/**
+ * Note: a more dynamic solution would be query the underlying GL
+ * and translate extension names...
+ */
+static const char *
+extension_string(void)
+{
+   return 
+      /* Core additions */
+      "GL_OES_single_precision "
+
+      /* Requred extensions */
+      "GL_OES_compressed_paletted_texture "
+
+      /* Normal extensions */
+      "GL_OES_depth24 "
+      "GL_OES_depth32 "
+      "GL_OES_depth_texture "
+      "GL_OES_element_index_uint "
+      "GL_OES_fbo_render_mipmap "
+      "GL_OES_mapbuffer "
+      "GL_OES_packed_depth_stencil "
+      "GL_OES_rgb8_rgba8 "
+      "GL_OES_standard_derivatives "
+      "GL_OES_stencil1 "
+      "GL_OES_stencil4 "
+      "GL_OES_stencil8 "
+      "GL_OES_texture_3D "
+      "GL_OES_texture_npot "
+      "GL_EXT_texture_filter_anisotropic "
+      "GL_EXT_texture_type_2_10_10_10_REV "
+      "GL_OES_depth_texture "
+      "GL_OES_standard_derivatives "
+      ;
+}
+
+const GLubyte * GLAPIENTRY _es_GetString(GLenum name);
+const GLubyte * GLAPIENTRY
+_es_GetString(GLenum name)
+{
+   switch (name) {
+   case GL_VERSION:
+      return (const GLubyte *) "OpenGL ES 2.0";
+   case GL_SHADING_LANGUAGE_VERSION:
+      return (const GLubyte *) "1.0.16";
+   case GL_EXTENSIONS:
+      return (const GLubyte *) extension_string();
+   default:
+      return _mesa_GetString(name);
+   }
+}
diff --git a/src/mesa/es/main/st_cpaltex.c b/src/mesa/es/main/st_cpaltex.c
new file mode 100644
index 0000000..358ae53
--- /dev/null
+++ b/src/mesa/es/main/st_cpaltex.c
@@ -0,0 +1,254 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ **************************************************************************/
+
+
+/**
+ * Code to convert compressed/paletted texture images to ordinary 4-byte RGBA.
+ * See the GL_OES_compressed_paletted_texture spec at
+ * http://khronos.org/registry/gles/extensions/OES/OES_compressed_paletted_texture.txt
+ */
+
+
+#include "GLES/glplatform.h"
+
+#include "main/imports.h"
+#include "main/teximage.h"
+
+/*
+ * typedefs/etc from GLES/gl.h here.  Can't include that header because
+ * it generates tons of conflicts.
+ */
+#ifndef GL_OES_compressed_paletted_texture
+
+#define GL_PALETTE4_RGB8_OES                                    0x8B90
+#define GL_PALETTE4_RGBA8_OES                                   0x8B91
+#define GL_PALETTE4_R5_G6_B5_OES                                0x8B92
+#define GL_PALETTE4_RGBA4_OES                                   0x8B93
+#define GL_PALETTE4_RGB5_A1_OES                                 0x8B94
+#define GL_PALETTE8_RGB8_OES                                    0x8B95
+#define GL_PALETTE8_RGBA8_OES                                   0x8B96
+#define GL_PALETTE8_R5_G6_B5_OES                                0x8B97
+#define GL_PALETTE8_RGBA4_OES                                   0x8B98
+#define GL_PALETTE8_RGB5_A1_OES                                 0x8B99
+#endif
+
+static const struct {
+   GLenum format;
+   GLuint palette_size;
+   GLuint size;
+} formats[] = {
+   { GL_PALETTE4_RGB8_OES,      16, 3 },
+   { GL_PALETTE4_RGBA8_OES,     16, 4 },
+   { GL_PALETTE4_R5_G6_B5_OES,  16, 2 },
+   { GL_PALETTE4_RGBA4_OES,     16, 2 },
+   { GL_PALETTE4_RGB5_A1_OES,   16, 2 },
+   { GL_PALETTE8_RGB8_OES,     256, 3 },
+   { GL_PALETTE8_RGBA8_OES,    256, 4 },
+   { GL_PALETTE8_R5_G6_B5_OES, 256, 2 },
+   { GL_PALETTE8_RGBA4_OES,    256, 2 },
+   { GL_PALETTE8_RGB5_A1_OES,  256, 2 }
+};
+
+
+/**
+ * Get a color/entry from the palette.  Convert to GLubyte/RGBA format.
+ */
+static void
+get_palette_entry(GLenum format, const void *palette, GLuint index,
+                  GLubyte rgba[4])
+{
+   switch (format) {
+   case GL_PALETTE4_RGB8_OES:
+   case GL_PALETTE8_RGB8_OES:
+      {
+         const GLubyte *pal = (const GLubyte *) palette;
+         rgba[0] = pal[index * 3 + 0];
+         rgba[1] = pal[index * 3 + 1];
+         rgba[2] = pal[index * 3 + 2];
+         rgba[3] = 255;
+      }
+      break;
+   case GL_PALETTE4_RGBA8_OES:
+   case GL_PALETTE8_RGBA8_OES:
+      {
+         const GLubyte *pal = (const GLubyte *) palette;
+         rgba[0] = pal[index * 4 + 0];
+         rgba[1] = pal[index * 4 + 1];
+         rgba[2] = pal[index * 4 + 2];
+         rgba[3] = pal[index * 4 + 3];
+      }
+      break;
+   case GL_PALETTE4_R5_G6_B5_OES:
+   case GL_PALETTE8_R5_G6_B5_OES:
+      {
+         const GLushort *pal = (const GLushort *) palette;
+         const GLushort color = pal[index];
+         rgba[0] = ((color >> 8) & 0xf8) | ((color >> 11) & 0x3);
+         rgba[1] = ((color >> 3) & 0xfc) | ((color >> 1 ) & 0x3);
+         rgba[2] = ((color << 3) & 0xf8) | ((color      ) & 0x7);
+         rgba[3] = 255;
+      }
+      break;
+   case GL_PALETTE4_RGBA4_OES:
+   case GL_PALETTE8_RGBA4_OES:
+      {
+         const GLushort *pal = (const GLushort *) palette;
+         const GLushort color = pal[index];
+         rgba[0] = ((color & 0xf000) >> 8) | ((color & 0xf000) >> 12);
+         rgba[1] = ((color & 0x0f00) >> 4) | ((color & 0x0f00) >>  8);
+         rgba[2] = ((color & 0x00f0)     ) | ((color & 0x00f0) >>  4);
+         rgba[3] = ((color & 0x000f) << 4) | ((color & 0x000f)      );
+      }
+      break;
+   case GL_PALETTE4_RGB5_A1_OES:
+   case GL_PALETTE8_RGB5_A1_OES:
+      {
+         const GLushort *pal = (const GLushort *) palette;
+         const GLushort color = pal[index];
+         rgba[0] = ((color >> 8) & 0xf8) | ((color >> 11) & 0x7);
+         rgba[1] = ((color >> 3) & 0xf8) | ((color >>  6) & 0x7);
+         rgba[2] = ((color << 2) & 0xf8) | ((color >>  1) & 0x7);
+         rgba[3] = (color & 0x1) * 255;
+      }
+      break;
+   default:
+      assert(0);
+   }
+}
+
+
+/**
+ * Convert paletted texture to simple GLubyte/RGBA format.
+ */
+static void
+paletted_to_rgba(GLenum src_format,
+                 const void *palette,
+                 const void *indexes,
+                 GLsizei width, GLsizei height,
+                 GLubyte *rgba)
+{
+   GLuint pal_ents, i;
+
+   assert(src_format >= GL_PALETTE4_RGB8_OES);
+   assert(src_format <= GL_PALETTE8_RGB5_A1_OES);
+   assert(formats[src_format - GL_PALETTE4_RGB8_OES].format == src_format);
+
+   pal_ents = formats[src_format - GL_PALETTE4_RGB8_OES].palette_size;
+
+   if (pal_ents == 16) {
+      /* 4 bits per index */
+      const GLubyte *ind = (const GLubyte *) indexes;
+
+      if (width * height == 1) {
+         /* special case the only odd-sized image */
+         GLuint index0 = ind[0] >> 4;
+         get_palette_entry(src_format, palette, index0, rgba);
+         return;
+      }
+      /* two pixels per iteration */
+      for (i = 0; i < width * height / 2; i++) {
+         GLuint index0 = ind[i] >> 4;
+         GLuint index1 = ind[i] & 0xf;
+         get_palette_entry(src_format, palette, index0, rgba + i * 8);
+         get_palette_entry(src_format, palette, index1, rgba + i * 8 + 4);
+      }
+   }
+   else {
+      /* 8 bits per index */
+      const GLubyte *ind = (const GLubyte *) indexes;
+      for (i = 0; i < width * height; i++) {
+         GLuint index = ind[i];
+         get_palette_entry(src_format, palette, index, rgba + i * 4);
+      }
+   }
+}
+
+
+/**
+ * Convert a call to glCompressedTexImage2D() where internalFormat is a
+ *  compressed palette format into a regular GLubyte/RGBA glTexImage2D() call.
+ */
+static void
+cpal_compressed_teximage2d(GLenum target, GLint level,
+                           GLenum internalFormat,
+                           GLsizei width, GLsizei height,
+                           const void *pixels)
+{
+   GLuint pal_ents, pal_ent_size, pal_bytes;
+   const GLint num_levels = level + 1;
+   GLint lvl;
+   const GLubyte *indexes;
+
+   assert(internalFormat >= GL_PALETTE4_RGB8_OES);
+   assert(internalFormat <= GL_PALETTE8_RGB5_A1_OES);
+   assert(formats[internalFormat - GL_PALETTE4_RGB8_OES].format == internalFormat);
+
+   pal_ents = formats[internalFormat - GL_PALETTE4_RGB8_OES].palette_size;
+   pal_ent_size = formats[internalFormat - GL_PALETTE4_RGB8_OES].size;
+   pal_bytes = pal_ents * pal_ent_size;
+
+   /* first image follows the palette */
+   indexes = (const GLubyte *) pixels + pal_bytes;
+
+   /* No worries about glPixelStore state since the only supported parameter is
+    * GL_UNPACK_ALIGNMENT and it doesn't matter when unpacking GLubyte/RGBA.
+    */
+
+   for (lvl = 0; lvl < num_levels; lvl++) {
+      /* Allocate GLubyte/RGBA dest image buffer */
+      GLubyte *rgba = (GLubyte *) malloc(width * height * 4);
+
+      if (pixels)
+         paletted_to_rgba(internalFormat, pixels, indexes, width, height, rgba);
+
+      _mesa_TexImage2D(target, lvl, GL_RGBA, width, height, 0,
+                       GL_RGBA, GL_UNSIGNED_BYTE, rgba);
+
+      free(rgba);
+
+      /* advance index pointer to point to next src mipmap */
+      if (pal_ents == 4)
+         indexes += width * height / 2;
+      else
+         indexes += width * height;
+
+      /* next mipmap level size */
+      if (width > 1)
+         width /= 2;
+      if (height > 1)
+         height /= 2;
+   }
+}
+
+void GL_APIENTRY
+_es_CompressedTexImage2D(GLenum target, GLint level, GLenum internalFormat,
+                       GLsizei width, GLsizei height, GLint border,
+                       GLsizei imageSize, const GLvoid *data);
+void GL_APIENTRY
+_es_CompressedTexImage2D(GLenum target, GLint level, GLenum internalFormat,
+                       GLsizei width, GLsizei height, GLint border,
+                       GLsizei imageSize, const GLvoid *data)
+{
+   switch (internalFormat) {
+   case GL_PALETTE4_RGB8_OES:
+   case GL_PALETTE4_RGBA8_OES:
+   case GL_PALETTE4_R5_G6_B5_OES:
+   case GL_PALETTE4_RGBA4_OES:
+   case GL_PALETTE4_RGB5_A1_OES:
+   case GL_PALETTE8_RGB8_OES:
+   case GL_PALETTE8_RGBA8_OES:
+   case GL_PALETTE8_R5_G6_B5_OES:
+   case GL_PALETTE8_RGBA4_OES:
+   case GL_PALETTE8_RGB5_A1_OES:
+      cpal_compressed_teximage2d(target, level, internalFormat,
+                                 width, height, data);
+      break;
+   default:
+      _mesa_CompressedTexImage2DARB(target, level, internalFormat,
+                                    width, height, border, imageSize, data);
+   }
+}
diff --git a/src/mesa/es/main/st_fbo.c b/src/mesa/es/main/st_fbo.c
new file mode 100644
index 0000000..a59e7d0
--- /dev/null
+++ b/src/mesa/es/main/st_fbo.c
@@ -0,0 +1,41 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ **************************************************************************/
+
+
+#include <stdlib.h>
+#include "GLES2/gl2.h"
+#include "GLES2/gl2ext.h"
+
+
+
+extern void GL_APIENTRY
+_mesa_RenderbufferStorageEXT(GLenum target, GLenum internalFormat,
+                             GLsizei width, GLsizei height);
+
+
+extern void GL_APIENTRY
+_es_RenderbufferStorage(GLenum target, GLenum internalFormat,
+                      GLsizei width, GLsizei height);
+extern void GL_APIENTRY
+_es_RenderbufferStorage(GLenum target, GLenum internalFormat,
+                      GLsizei width, GLsizei height)
+{
+   switch (internalFormat) {
+   case GL_RGBA4:
+   case GL_RGB5_A1:
+   case GL_RGB565:
+      internalFormat = GL_RGBA;
+      break;
+   case GL_STENCIL_INDEX1_OES:
+   case GL_STENCIL_INDEX4_OES:
+   case GL_STENCIL_INDEX8:
+      internalFormat = GL_STENCIL_INDEX;
+      break;
+   default:
+      ; /* no op */
+   }
+   _mesa_RenderbufferStorageEXT(target, internalFormat, width, height);
+}
diff --git a/src/mesa/es/main/st_query_matrix.c b/src/mesa/es/main/st_query_matrix.c
new file mode 100644
index 0000000..f31cda8
--- /dev/null
+++ b/src/mesa/es/main/st_query_matrix.c
@@ -0,0 +1,198 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ **************************************************************************/
+
+/**
+ * Code to implement GL_OES_query_matrix.  See the spec at:
+ *   http://www.khronos.org/registry/gles/extensions/OES/OES_query_matrix.txt
+ */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <math.h>
+#include <GLES/gl.h>
+#define GL_GLEXT_PROTOTYPES
+#include <GLES/glext.h>
+
+/**
+ * This is from the GL_OES_query_matrix extension specification:
+ *
+ *  GLbitfield glQueryMatrixxOES( GLfixed mantissa[16],
+ *                                GLint   exponent[16] )
+ *  mantissa[16] contains the contents of the current matrix in GLfixed
+ *  format.  exponent[16] contains the unbiased exponents applied to the
+ *  matrix components, so that the internal representation of component i
+ *  is close to mantissa[i] * 2^exponent[i].  The function returns a status
+ *  word which is zero if all the components are valid. If
+ *  status & (1<<i) != 0, the component i is invalid (e.g., NaN, Inf).
+ *  The implementations are not required to keep track of overflows.  In
+ *  that case, the invalid bits are never set.
+ */
+
+#define INT_TO_FIXED(x) ((GLfixed) ((x) << 16))
+#define FLOAT_TO_FIXED(x) ((GLfixed) ((x) * 65536.0))
+
+#if defined(WIN32) || defined(_WIN32_WCE)
+/* Oddly, the fpclassify() function doesn't exist in such a form
+ * on Windows.  This is an implementation using slightly different
+ * lower-level Windows functions.
+ */
+#include <float.h>
+
+enum {FP_NAN, FP_INFINITE, FP_ZERO, FP_SUBNORMAL, FP_NORMAL}
+fpclassify(double x)
+{
+    switch(_fpclass(x)) {
+        case _FPCLASS_SNAN: /* signaling NaN */
+        case _FPCLASS_QNAN: /* quiet NaN */
+            return FP_NAN;
+        case _FPCLASS_NINF: /* negative infinity */
+        case _FPCLASS_PINF: /* positive infinity */
+            return FP_INFINITE;
+        case _FPCLASS_NN:   /* negative normal */
+        case _FPCLASS_PN:   /* positive normal */
+            return FP_NORMAL;
+        case _FPCLASS_ND:   /* negative denormalized */
+        case _FPCLASS_PD:   /* positive denormalized */
+            return FP_SUBNORMAL;
+        case _FPCLASS_NZ:   /* negative zero */
+        case _FPCLASS_PZ:   /* positive zero */
+            return FP_ZERO;
+        default:
+            /* Should never get here; but if we do, this will guarantee
+             * that the pattern is not treated like a number.
+             */
+            return FP_NAN;
+    }
+}
+#endif
+
+/* The Mesa functions we'll need */
+extern void GL_APIENTRY _mesa_GetIntegerv(GLenum pname, GLint *params);
+extern void GL_APIENTRY _mesa_GetFloatv(GLenum pname, GLfloat *params);
+
+extern GLbitfield GL_APIENTRY _es_QueryMatrixxOES(GLfixed mantissa[16], GLint exponent[16]);
+
+GLbitfield GL_APIENTRY _es_QueryMatrixxOES(GLfixed mantissa[16], GLint exponent[16])
+{
+    GLfloat matrix[16];
+    GLint tmp;
+    GLenum currentMode = GL_FALSE;
+    GLenum desiredMatrix = GL_FALSE;
+    /* The bitfield returns 1 for each component that is invalid (i.e.
+     * NaN or Inf).  In case of error, everything is invalid.
+     */
+    GLbitfield rv;
+    register unsigned int i;
+    unsigned int bit;
+
+    /* This data structure defines the mapping between the current matrix
+     * mode and the desired matrix identifier.
+     */
+    static struct {
+        GLenum currentMode;
+        GLenum desiredMatrix;
+    } modes[] = {
+        {GL_MODELVIEW, GL_MODELVIEW_MATRIX},
+        {GL_PROJECTION, GL_PROJECTION_MATRIX}, 
+        {GL_TEXTURE, GL_TEXTURE_MATRIX},
+#if 0
+        /* this doesn't exist in GLES */
+        {GL_COLOR, GL_COLOR_MATRIX},
+#endif
+    };
+
+    /* Call Mesa to get the current matrix in floating-point form.  First,
+     * we have to figure out what the current matrix mode is.
+     */
+    _mesa_GetIntegerv(GL_MATRIX_MODE, &tmp);
+    currentMode = (GLenum) tmp;
+
+    /* The mode is either GL_FALSE, if for some reason we failed to query
+     * the mode, or a given mode from the above table.  Search for the
+     * returned mode to get the desired matrix; if we don't find it,
+     * we can return immediately, as _mesa_GetInteger() will have
+     * logged the necessary error already.
+     */
+    for (i = 0; i < sizeof(modes)/sizeof(modes[0]); i++) {
+        if (modes[i].currentMode == currentMode) {
+            desiredMatrix = modes[i].desiredMatrix;
+            break;
+        }
+    }
+    if (desiredMatrix == GL_FALSE) {
+        /* Early error means all values are invalid. */
+        return 0xffff;
+    }
+
+    /* Now pull the matrix itself. */
+    _mesa_GetFloatv(desiredMatrix, matrix);
+
+    rv = 0;
+    for (i = 0, bit = 1; i < 16; i++, bit<<=1) {
+        float normalizedFraction;
+        int exp;
+
+        switch (fpclassify(matrix[i])) {
+            /* A "subnormal" or denormalized number is too small to be
+             * represented in normal format; but despite that it's a
+             * valid floating point number.  FP_ZERO and FP_NORMAL
+             * are both valid as well.  We should be fine treating
+             * these three cases as legitimate floating-point numbers.
+             */
+            case FP_SUBNORMAL:
+            case FP_NORMAL:
+            case FP_ZERO:
+                normalizedFraction = (GLfloat)frexp(matrix[i], &exp);
+                mantissa[i] = FLOAT_TO_FIXED(normalizedFraction);
+                exponent[i] = (GLint) exp;
+                break;
+
+            /* If the entry is not-a-number or an infinity, then the
+             * matrix component is invalid.  The invalid flag for
+             * the component is already set; might as well set the
+             * other return values to known values.  We'll set 
+             * distinct values so that a savvy end user could determine
+             * whether the matrix component was a NaN or an infinity,
+             * but this is more useful for debugging than anything else
+             * since the standard doesn't specify any such magic
+             * values to return.
+             */
+            case FP_NAN:
+                mantissa[i] = INT_TO_FIXED(0);
+                exponent[i] = (GLint) 0;
+                rv |= bit;
+                break;
+
+            case FP_INFINITE:
+                /* Return +/- 1 based on whether it's a positive or
+                 * negative infinity.
+                 */
+                if (matrix[i] > 0) {
+                    mantissa[i] = INT_TO_FIXED(1);
+                }
+                else {
+                    mantissa[i] = -INT_TO_FIXED(1);
+                }
+                exponent[i] = (GLint) 0;
+                rv |= bit;
+                break;
+
+            /* We should never get here; but here's a catching case
+             * in case fpclassify() is returnings something unexpected.
+             */
+            default:
+                mantissa[i] = INT_TO_FIXED(2);
+                exponent[i] = (GLint) 0;
+                rv |= bit;
+                break;
+        }
+
+    } /* for each component */
+
+    /* All done */
+    return rv;
+}
diff --git a/src/mesa/es/main/stubs.c b/src/mesa/es/main/stubs.c
new file mode 100644
index 0000000..a7106c5
--- /dev/null
+++ b/src/mesa/es/main/stubs.c
@@ -0,0 +1,167 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * TUNGSTEN GRAPHICS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ **************************************************************************/
+
+
+/**
+ * Temporary stubs for "missing" mesa functions.
+ */
+
+#include <assert.h>
+
+#include "GLES/glplatform.h"
+
+#include "main/imports.h"
+#include "main/attrib.h"
+#include "vbo/vbo.h"
+
+#if FEATURE_accum
+/* This is a sanity check that to be sure we're using the correct mfeatures.h
+ * header.  We don't want to accidentally use the one from mainline Mesa.
+ */
+#error "The wrong mfeatures.h file is being included!"
+#endif
+
+/* These functions reflect critical functionality that is not
+ * yet available in Mesa.  They're stubbed out here as Mesa
+ * functions in order to build usable libraries that will work
+ * if the function is not used.  As they're added to Mesa, they
+ * should be removed from here.
+ */
+GLAPI void GLAPIENTRY
+_mesa_GetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype,
+                               GLint* range, GLint* precision);
+GLAPI void GLAPIENTRY
+_mesa_GetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype,
+                               GLint* range, GLint* precision)
+{
+   assert(0);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_ReleaseShaderCompiler(void);
+GLAPI void GLAPIENTRY
+_mesa_ReleaseShaderCompiler(void)
+{
+   /* no-op */
+}
+
+GLAPI void GLAPIENTRY
+_mesa_ShaderBinary(GLint n, const GLuint* shaders, GLenum binaryformat,
+                   const void* binary, GLint length);
+GLAPI void GLAPIENTRY
+_mesa_ShaderBinary(GLint n, const GLuint* shaders, GLenum binaryformat,
+                   const void* binary, GLint length)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   /* We'll always return 0 for GL_NUM_SHADER_BINARY_FORMATS so the
+    * user should never call this functin.
+    */
+   _mesa_error(ctx, GL_INVALID_OPERATION, "glShaderBinary");
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib1f(GLuint indx, GLfloat x);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib1f(GLuint indx, GLfloat x)
+{
+   _vbo_VertexAttrib4f(indx, x, 0.0, 0.0, 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib1fv(GLuint indx, const GLfloat* values);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib1fv(GLuint indx, const GLfloat* values)
+{
+   _vbo_VertexAttrib4f(indx, values[0], 0.0, 0.0, 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
+{
+   _vbo_VertexAttrib4f(indx, x, y, 0.0, 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib2fv(GLuint indx, const GLfloat* values);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib2fv(GLuint indx, const GLfloat* values)
+{
+   _vbo_VertexAttrib4f(indx, values[0], values[1], 0.0, 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
+{
+   _vbo_VertexAttrib4f(indx, x, y, z, 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib3fv(GLuint indx, const GLfloat* values);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib3fv(GLuint indx, const GLfloat* values)
+{
+   _vbo_VertexAttrib4f(indx, values[0], values[1], values[2], 1.0f);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   _vbo_VertexAttrib4f(indx, x, y, z, w);
+}
+
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib4fv(GLuint indx, const GLfloat* values);
+GLAPI void GLAPIENTRY
+_mesa_VertexAttrib4fv(GLuint indx, const GLfloat* values)
+{
+   _vbo_VertexAttrib4f(indx, values[0], values[1], values[2], values[3]);
+}
+
+/* client attributes are used in main/debug.c */
+GL_API void GLAPIENTRY
+_mesa_PopClientAttrib(void)
+{
+   assert(0);
+}
+
+GL_API void GLAPIENTRY
+_mesa_PushClientAttrib(GLbitfield mask)
+{
+   assert(0);
+}
+
+/* _vbo_Materialf() doesn't exist, though _vbo_Materialfv() does... */
+GLAPI void GLAPIENTRY
+_vbo_Materialf(GLenum face, GLenum pname, GLfloat param);
+GL_API void GLAPIENTRY
+_vbo_Materialf(GLenum face, GLenum pname, GLfloat param)
+{
+    _vbo_Materialfv(face, pname, &param);
+}
diff --git a/src/mesa/es/sources.mak b/src/mesa/es/sources.mak
new file mode 100644
index 0000000..9271a75
--- /dev/null
+++ b/src/mesa/es/sources.mak
@@ -0,0 +1,170 @@
+# LOCAL sources
+
+ES1_LOCAL_SOURCES :=			\
+	main/api_exec_es1.c		\
+	main/get_es1.c			\
+	main/pixel.c			\
+	main/specials_es1.c		\
+	main/st_cpaltex.c		\
+	main/st_fbo.c			\
+	main/st_query_matrix.c		\
+	main/stubs.c
+
+ES1_GALLIUM_LOCAL_SOURCES :=		\
+	$(ES1_LOCAL_SOURCES)		\
+	state_tracker/st_cb_drawtex.c
+
+ES1_API_LOCAL_SOURCES :=		\
+
+ES1_LOCAL_INCLUDES :=			\
+	-I.				\
+	-I./glapi/headers-es1		\
+	-I./state_tracker		\
+	-I$(MESA)/state_tracker
+
+ES2_LOCAL_SOURCES := $(subst es1,es2,$(ES1_LOCAL_SOURCES))
+ES2_GALLIUM_LOCAL_SOURCES := $(subst es1,es2,$(ES1_GALLIUM_LOCAL_SOURCES))
+ES2_API_LOCAL_SOURCES := $(subst es1,es2,$(ES1_API_LOCAL_SOURCES))
+ES2_LOCAL_INCLUDES := $(subst es1,es2,$(ES1_LOCAL_INCLUDES))
+
+# MESA sources
+
+include $(MESA)/sources.mak
+
+MAIN_OMITTED :=				\
+	main/accum.c			\
+	main/attrib.c			\
+	main/api_exec.c			\
+	main/colortab.c			\
+	main/convolve.c			\
+	main/dlist.c			\
+	main/dlopen.c			\
+	main/drawpix.c			\
+	main/eval.c			\
+	main/feedback.c			\
+	main/get.c			\
+	main/histogram.c		\
+	main/queryobj.c			\
+	main/rastpos.c			\
+	main/texcompress_fxt1.c		\
+	main/texcompress_s3tc.c
+MAIN_SOURCES := $(filter-out $(MAIN_OMITTED), $(MAIN_SOURCES))
+
+VBO_OMITTED :=				\
+	vbo/vbo_save_api.c		\
+	vbo/vbo_save.c			\
+	vbo/vbo_save_draw.c		\
+	vbo/vbo_save_loopback.c
+VBO_SOURCES := $(filter-out $(VBO_OMITTED), $(VBO_SOURCES))
+
+STATETRACKER_OMITTED :=				\
+	state_tracker/st_cb_drawpixels.c	\
+	state_tracker/st_cb_feedback.c		\
+	state_tracker/st_cb_rasterpos.c		\
+	state_tracker/st_api.c			\
+	state_tracker/st_draw_feedback.c
+STATETRACKER_SOURCES := $(filter-out $(STATETRACKER_OMITTED), $(STATETRACKER_SOURCES))
+
+SHADER_OMITTED :=			\
+	shader/atifragshader.c		\
+	shader/nvfragparse.c		\
+	shader/nvprogram.c		\
+	shader/nvvertparse.c
+SHADER_SOURCES := $(filter-out $(SHADER_OMITTED), $(SHADER_SOURCES))
+
+ES1_MESA_SOURCES :=			\
+	$(MAIN_SOURCES)			\
+	$(MATH_SOURCES)			\
+	$(MATH_XFORM_SOURCES)		\
+	$(VBO_SOURCES)			\
+	$(TNL_SOURCES)			\
+	$(SHADER_SOURCES)		\
+	$(SWRAST_SOURCES)		\
+	$(SWRAST_SETUP_SOURCES)		\
+	$(COMMON_DRIVER_SOURCES)	\
+	$(ASM_C_SOURCES)		\
+	$(SLANG_SOURCES)
+
+ES1_GALLIUM_MESA_SOURCES :=		\
+	$(MAIN_SOURCES)			\
+	$(MATH_SOURCES)			\
+	$(MATH_XFORM_SOURCES)		\
+	$(VBO_SOURCES)			\
+	$(STATETRACKER_SOURCES)		\
+	$(SHADER_SOURCES)		\
+	$(SLANG_SOURCES)
+
+ES1_API_MESA_SOURCES :=			\
+	$(GLAPI_SOURCES)
+
+ES1_MESA_INCLUDES := $(INCLUDE_DIRS)
+
+# remove LOCAL sources from MESA sources
+ES1_MESA_SOURCES := $(filter-out $(ES1_LOCAL_SOURCES), $(ES1_MESA_SOURCES))
+ES1_GALLIUM_MESA_SOURCES := $(filter-out $(ES1_GALLIUM_LOCAL_SOURCES), $(ES1_GALLIUM_MESA_SOURCES))
+ES1_API_MESA_SOURCES := $(filter-out $(ES1_API_LOCAL_SOURCES), $(ES1_API_MESA_SOURCES))
+
+# es2 and es1 share sources
+ES2_MESA_SOURCES := $(ES1_MESA_SOURCES)
+ES2_GALLIUM_MESA_SOURCES := $(ES1_GALLIUM_MESA_SOURCES)
+ES2_API_MESA_SOURCES := $(ES1_API_MESA_SOURCES)
+
+ES2_MESA_INCLUDES := $(ES1_MESA_INCLUDES)
+
+
+# collect sources
+ES1_SOURCES := $(ES1_LOCAL_SOURCES) $(ES1_MESA_SOURCES)
+ES1_GALLIUM_SOURCES := $(ES1_GALLIUM_LOCAL_SOURCES) $(ES1_GALLIUM_MESA_SOURCES)
+ES1_API_SOURCES := $(ES1_API_LOCAL_SOURCES) $(ES1_API_MESA_SOURCES)
+
+ES2_SOURCES := $(ES2_LOCAL_SOURCES) $(ES2_MESA_SOURCES)
+ES2_GALLIUM_SOURCES := $(ES2_GALLIUM_LOCAL_SOURCES) $(ES2_GALLIUM_MESA_SOURCES)
+ES2_API_SOURCES := $(ES2_API_LOCAL_SOURCES) $(ES2_API_MESA_SOURCES)
+
+# collect includes
+ES1_INCLUDES := $(ES1_LOCAL_INCLUDES) $(ES1_MESA_INCLUDES)
+ES2_INCLUDES := $(ES2_LOCAL_INCLUDES) $(ES2_MESA_INCLUDES)
+
+# group sources in another way
+ALL_ES1_SOURCES :=			\
+	$(ES1_SOURCES)			\
+	$(ES1_GALLIUM_SOURCES)		\
+	$(ES1_API_SOURCES)
+ALL_ES2_SOURCES :=			\
+	$(ES2_SOURCES)			\
+	$(ES2_GALLIUM_SOURCES)		\
+	$(ES2_API_SOURCES)
+ALL_LOCAL_SOURCES :=			\
+	$(ES1_LOCAL_SOURCES)		\
+	$(ES1_GALLIUM_LOCAL_SOURCES)	\
+	$(ES1_API_LOCAL_SOURCES)	\
+	$(ES2_LOCAL_SOURCES)		\
+	$(ES2_GALLIUM_LOCAL_SOURCES)	\
+	$(ES2_API_LOCAL_SOURCES)
+ALL_MESA_SOURCES :=			\
+	$(ES1_MESA_SOURCES)		\
+	$(ES1_GALLIUM_MESA_SOURCES)	\
+	$(ES1_API_MESA_SOURCES)		\
+	$(ES2_MESA_SOURCES)		\
+	$(ES2_GALLIUM_MESA_SOURCES)	\
+	$(ES2_API_MESA_SOURCES)
+
+# sort to remove duplicates
+ALL_ES1_SOURCES := $(sort $(ALL_ES1_SOURCES))
+ALL_ES2_SOURCES := $(sort $(ALL_ES2_SOURCES))
+ALL_LOCAL_SOURCES := $(sort $(ALL_LOCAL_SOURCES))
+ALL_MESA_SOURCES := $(sort $(ALL_MESA_SOURCES))
+
+# convert to objects
+ES1_OBJECTS := $(ES1_SOURCES:.c=.o)
+ES1_GALLIUM_OBJECTS := $(ES1_GALLIUM_SOURCES:.c=.o)
+ES1_API_OBJECTS := $(ES1_API_SOURCES:.c=.o)
+
+ES2_OBJECTS := $(ES2_SOURCES:.c=.o)
+ES2_GALLIUM_OBJECTS := $(ES2_GALLIUM_SOURCES:.c=.o)
+ES2_API_OBJECTS := $(ES2_API_SOURCES:.c=.o)
+
+ALL_LOCAL_OBJECTS := $(ALL_LOCAL_SOURCES:.c=.o)
+ALL_MESA_OBJECTS := $(ALL_MESA_SOURCES:.c=.o)
+ALL_ES1_OBJECTS := $(ALL_ES1_SOURCES:.c=.o)
+ALL_ES2_OBJECTS := $(ALL_ES2_SOURCES:.c=.o)
diff --git a/src/mesa/es/state_tracker/st_cb_drawtex.c b/src/mesa/es/state_tracker/st_cb_drawtex.c
new file mode 100644
index 0000000..f675591
--- /dev/null
+++ b/src/mesa/es/state_tracker/st_cb_drawtex.c
@@ -0,0 +1,292 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ **************************************************************************/
+
+
+/**
+ * Implementation of glDrawTex() for GL_OES_draw_tex
+ */
+
+
+
+#include "main/imports.h"
+#include "main/image.h"
+#include "main/bufferobj.h"
+#include "main/macros.h"
+#include "main/state.h"
+#include "main/texformat.h"
+#include "shader/program.h"
+#include "shader/prog_parameter.h"
+#include "shader/prog_print.h"
+
+#include "st_context.h"
+#include "st_atom.h"
+#include "st_atom_constbuf.h"
+#include "st_draw.h"
+#include "st_cb_drawtex.h"
+
+#include "pipe/p_context.h"
+#include "pipe/p_defines.h"
+#include "pipe/p_inlines.h"
+#include "pipe/p_shader_tokens.h"
+#include "util/u_tile.h"
+#include "util/u_draw_quad.h"
+#include "util/u_simple_shaders.h"
+
+#include "cso_cache/cso_context.h"
+
+
+struct cached_shader
+{
+   //struct pipe_shader_state shader;
+   void *handle;
+
+   uint num_attribs;
+   uint semantic_names[2 + MAX_TEXTURE_UNITS];
+   uint semantic_indexes[2 + MAX_TEXTURE_UNITS];
+};
+
+#define MAX_SHADERS (2 * MAX_TEXTURE_UNITS)
+
+/**
+ * Simple linear list cache.
+ * Most of the time there'll only be one cached shader.
+ */
+static struct cached_shader CachedShaders[MAX_SHADERS];
+static GLuint NumCachedShaders = 0;
+
+
+static void *
+lookup_shader(struct pipe_context *pipe,
+              uint num_attribs,
+              const uint *semantic_names,
+              const uint *semantic_indexes)
+{
+   GLuint i, j;
+
+   /* look for existing shader with same attributes */
+   for (i = 0; i < NumCachedShaders; i++) {
+      if (CachedShaders[i].num_attribs == num_attribs) {
+         GLboolean match = GL_TRUE;
+         for (j = 0; j < num_attribs; j++) {
+            if (semantic_names[j] != CachedShaders[i].semantic_names[j] ||
+                semantic_indexes[j] != CachedShaders[i].semantic_indexes[j]) {
+               match = GL_FALSE;
+               break;
+            }
+         }
+         if (match)
+            return CachedShaders[i].handle;
+      }
+   }
+
+   /* not found - create new one now */
+   if (NumCachedShaders >= MAX_SHADERS) {
+      return NULL;
+   }
+
+   CachedShaders[i].num_attribs = num_attribs;
+   for (j = 0; j < num_attribs; j++) {
+      CachedShaders[i].semantic_names[j] = semantic_names[j];
+      CachedShaders[i].semantic_indexes[j] = semantic_indexes[j];
+   }
+
+   CachedShaders[i].handle =
+      util_make_vertex_passthrough_shader(pipe,
+                                          num_attribs,
+                                          semantic_names,
+                                          semantic_indexes);
+   NumCachedShaders++;
+
+   return CachedShaders[i].handle;
+}
+
+
+/**
+ * Free any cached shaders
+ */
+void
+st_destroy_drawtex(struct st_context *st)
+{
+   GLuint i;
+   for (i = 0; i < NumCachedShaders; i++) {
+      cso_delete_vertex_shader(st->cso_context, CachedShaders[i].handle);
+   }
+   NumCachedShaders = 0;
+}
+
+
+
+void
+_mesa_DrawTexf(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   struct st_context *st = ctx->st;
+   struct pipe_context *pipe = st->pipe;
+   struct cso_context *cso = ctx->st->cso_context;
+   struct pipe_buffer *vbuffer;
+   GLuint i, numTexCoords, numAttribs;
+   GLboolean emitColor;
+   uint semantic_names[2 + MAX_TEXTURE_UNITS];
+   uint semantic_indexes[2 + MAX_TEXTURE_UNITS];
+   GLbitfield inputs = VERT_BIT_POS;
+
+   /* determine if we need vertex color */
+   if (ctx->FragmentProgram._Current->Base.InputsRead & FRAG_BIT_COL0)
+      emitColor = GL_TRUE;
+   else
+      emitColor = GL_FALSE;
+
+   /* determine how many enabled sets of texcoords */
+   numTexCoords = 0;
+   for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
+      if (ctx->Texture.Unit[i]._ReallyEnabled & TEXTURE_2D_BIT) {
+         inputs |= VERT_BIT_TEX(i);
+         numTexCoords++;
+      }
+   }
+
+   /* total number of attributes per vertex */
+   numAttribs = 1 + emitColor + numTexCoords;
+
+
+   /* create the vertex buffer */
+   vbuffer = pipe_buffer_create(pipe->screen, 32, PIPE_BUFFER_USAGE_VERTEX,
+                                numAttribs * 4 * 4 * sizeof(GLfloat));
+
+   /* load vertex buffer */
+   {
+#define SET_ATTRIB(VERT, ATTR, X, Y, Z, W)                              \
+      do {                                                              \
+         GLuint k = (((VERT) * numAttribs + (ATTR)) * 4);               \
+         assert(k < 4 * 4 * numAttribs);                                \
+         vbuf[k + 0] = X;                                               \
+         vbuf[k + 1] = Y;                                               \
+         vbuf[k + 2] = Z;                                               \
+         vbuf[k + 3] = W;                                               \
+      } while (0)
+
+      const GLfloat x0 = x, y0 = y, x1 = x + width, y1 = y + height;
+      GLfloat *vbuf = (GLfloat *) pipe_buffer_map(pipe->screen, vbuffer,
+                                                  PIPE_BUFFER_USAGE_CPU_WRITE);
+      GLuint attr;
+      
+      z = CLAMP(z, 0.0f, 1.0f);
+
+      /* positions (in clip coords) */
+      {
+         const struct gl_framebuffer *fb = st->ctx->DrawBuffer;
+         const GLfloat fb_width = (GLfloat)fb->Width;
+         const GLfloat fb_height = (GLfloat)fb->Height;
+
+         const GLfloat clip_x0 = (GLfloat)(x0 / fb_width * 2.0 - 1.0);
+         const GLfloat clip_y0 = (GLfloat)(y0 / fb_height * 2.0 - 1.0);
+         const GLfloat clip_x1 = (GLfloat)(x1 / fb_width * 2.0 - 1.0);
+         const GLfloat clip_y1 = (GLfloat)(y1 / fb_height * 2.0 - 1.0);
+
+         SET_ATTRIB(0, 0, clip_x0, clip_y0, z, 1.0f);   /* lower left */
+         SET_ATTRIB(1, 0, clip_x1, clip_y0, z, 1.0f);   /* lower right */
+         SET_ATTRIB(2, 0, clip_x1, clip_y1, z, 1.0f);   /* upper right */
+         SET_ATTRIB(3, 0, clip_x0, clip_y1, z, 1.0f);   /* upper left */
+
+         semantic_names[0] = TGSI_SEMANTIC_POSITION;
+         semantic_indexes[0] = 0;
+      }
+
+      /* colors */
+      if (emitColor) {
+         const GLfloat *c = ctx->Current.Attrib[VERT_ATTRIB_COLOR0];
+         SET_ATTRIB(0, 1, c[0], c[1], c[2], c[3]);
+         SET_ATTRIB(1, 1, c[0], c[1], c[2], c[3]);
+         SET_ATTRIB(2, 1, c[0], c[1], c[2], c[3]);
+         SET_ATTRIB(3, 1, c[0], c[1], c[2], c[3]);
+         semantic_names[1] = TGSI_SEMANTIC_COLOR;
+         semantic_indexes[1] = 0;
+         attr = 2;
+      }
+      else {
+         attr = 1;
+      }
+
+      /* texcoords */
+      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
+         if (ctx->Texture.Unit[i]._ReallyEnabled & TEXTURE_2D_BIT) {
+            struct gl_texture_object *obj = ctx->Texture.Unit[i]._Current;
+            struct gl_texture_image *img = obj->Image[0][obj->BaseLevel];
+            const GLfloat wt = (GLfloat) img->Width;
+            const GLfloat ht = (GLfloat) img->Height;
+            const GLfloat s0 = obj->CropRect[0] / wt;
+            const GLfloat t0 = obj->CropRect[1] / ht;
+            const GLfloat s1 = (obj->CropRect[0] + obj->CropRect[2]) / wt;
+            const GLfloat t1 = (obj->CropRect[1] + obj->CropRect[3]) / ht;
+
+            /*printf("crop texcoords: %g, %g .. %g, %g\n", s0, t0, s1, t1);*/
+            SET_ATTRIB(0, attr, s0, t0, 0.0f, 1.0f);  /* lower left */
+            SET_ATTRIB(1, attr, s1, t0, 0.0f, 1.0f);  /* lower right */
+            SET_ATTRIB(2, attr, s1, t1, 0.0f, 1.0f);  /* upper right */
+            SET_ATTRIB(3, attr, s0, t1, 0.0f, 1.0f);  /* upper left */
+
+            semantic_names[attr] = TGSI_SEMANTIC_GENERIC;
+            semantic_indexes[attr] = 0;
+
+            attr++;
+         }
+      }
+
+      pipe_buffer_unmap(pipe->screen, vbuffer);
+
+#undef SET_ATTRIB
+   }
+
+
+   cso_save_viewport(cso);
+   cso_save_vertex_shader(cso);
+
+   {
+      void *vs = lookup_shader(pipe, numAttribs,
+                               semantic_names, semantic_indexes);
+      cso_set_vertex_shader_handle(cso, vs);
+   }
+
+   /* viewport state: viewport matching window dims */
+   {
+      const struct gl_framebuffer *fb = st->ctx->DrawBuffer;
+      const GLboolean invert = (st_fb_orientation(fb) == Y_0_TOP);
+      const GLfloat width = (GLfloat)fb->Width;
+      const GLfloat height = (GLfloat)fb->Height;
+      struct pipe_viewport_state vp;
+      vp.scale[0] =  0.5f * width;
+      vp.scale[1] = height * (invert ? -0.5f : 0.5f);
+      vp.scale[2] = 1.0f;
+      vp.scale[3] = 1.0f;
+      vp.translate[0] = 0.5f * width;
+      vp.translate[1] = 0.5f * height;
+      vp.translate[2] = 0.0f;
+      vp.translate[3] = 0.0f;
+      cso_set_viewport(cso, &vp);
+   }
+
+
+   util_draw_vertex_buffer(pipe, vbuffer,
+                           0,  /* offset */
+                           PIPE_PRIM_TRIANGLE_FAN,
+                           4,  /* verts */
+                           numAttribs); /* attribs/vert */
+
+
+   pipe_buffer_reference(&vbuffer, NULL);
+
+   /* restore state */
+   cso_restore_viewport(cso);
+   cso_restore_vertex_shader(cso);
+}
+
+
+void
+_mesa_DrawTexfv(const GLfloat *coords)
+{
+   _mesa_DrawTexf(coords[0], coords[1], coords[2], coords[3], coords[4]);
+}
diff --git a/src/mesa/es/state_tracker/st_cb_drawtex.h b/src/mesa/es/state_tracker/st_cb_drawtex.h
new file mode 100644
index 0000000..278815a
--- /dev/null
+++ b/src/mesa/es/state_tracker/st_cb_drawtex.h
@@ -0,0 +1,28 @@
+/**************************************************************************
+ * 
+ * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ **************************************************************************/
+
+
+#ifndef ST_CB_DRAWTEX_H
+#define ST_CB_DRAWTEX_H
+
+
+struct st_context;
+
+
+extern void
+_mesa_DrawTexf(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
+
+
+extern void
+_mesa_DrawTexfv(const GLfloat *coords);
+
+
+extern void
+st_destroy_drawtex(struct st_context *st);
+
+
+#endif
-- 
1.6.2.4

